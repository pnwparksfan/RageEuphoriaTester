// Generated by GTA V Euphoria Behaviours Parser v1.1.0.0 by alexguirre
namespace Rage.Euphoria
{
    using Rage;
    using Rage.Euphoria;


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageActivePose : EuphoriaMessage
    {
        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see notes for explanation)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see notes for explanation)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }

        private bool useGravityCompensation = false;
        /// <summary>
        /// Apply gravity compensation as well?
        /// </summary>
        [EuphoriaDetail("Apply gravity compensation as well?")]
        public bool UseGravityCompensation
        {
            get { return useGravityCompensation; }
            set
            {

                SetArgument("useGravityCompensation", value);
                useGravityCompensation = value;
            }
        }

        private int animSource;
        /// <summary>
        /// AnimSource 0 = CurrentItms, 1 = PreviousItms, 2 = AnimItms
        /// </summary>
        [EuphoriaDetail("AnimSource 0 = CurrentItms, 1 = PreviousItms, 2 = AnimItms")]
        public int AnimSource
        {
            get { return animSource; }
            set
            {

                SetArgument("animSource", value);
                animSource = value;
            }
        }


        public EuphoriaMessageActivePose(bool startNow) : base("activePose", startNow)
        { }

        public EuphoriaMessageActivePose() : base("activePose", true)
        { }

        public new void Reset()
        {
            mask = "fb";
            useGravityCompensation = false;
            animSource = default(int);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageApplyImpulse : EuphoriaMessage
    {
        private float equalizeAmount = 0.000f;
        /// <summary>
        /// 0 means straight impulse, 1 means multiply by the mass (change in velocity)
        /// </summary>
        [EuphoriaDetail("0 means straight impulse, 1 means multiply by the mass (change in velocity)")]
        public float EqualizeAmount
        {
            get { return equalizeAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("equalizeAmount", value);
                equalizeAmount = value;
            }
        }

        private int partIndex = 0;
        /// <summary>
        /// index of part being hit. -1 apply impulse to COM.
        /// </summary>
        [EuphoriaDetail("index of part being hit. -1 apply impulse to COM.")]
        public int PartIndex
        {
            get { return partIndex; }
            set
            {
                value = MathHelper.Clamp(value, -1, 28);
                SetArgument("partIndex", value);
                partIndex = value;
            }
        }

        private Vector3 impulse = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// impulse vector (impulse is change in momentum)
        /// </summary>
        [EuphoriaDetail("impulse vector (impulse is change in momentum)")]
        public Vector3 Impulse
        {
            get { return impulse; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -4500.0f, 4500.0f);
                value.Y = MathHelper.Clamp(value.Y, -4500.0f, 4500.0f);
                value.Z = MathHelper.Clamp(value.Z, -4500.0f, 4500.0f);
                SetArgument("impulse", value);
                impulse = value;
            }
        }

        private Vector3 hitPoint = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// optional point on part where hit.  If not supplied then the impulse is applied at the part centre.
        /// </summary>
        [EuphoriaDetail("optional point on part where hit.  If not supplied then the impulse is applied at the part centre.")]
        public Vector3 HitPoint
        {
            get { return hitPoint; }
            set
            {

                SetArgument("hitPoint", value);
                hitPoint = value;
            }
        }

        private bool localHitPointInfo = false;
        /// <summary>
        /// hitPoint in local coordinates of bodyPart
        /// </summary>
        [EuphoriaDetail("hitPoint in local coordinates of bodyPart")]
        public bool LocalHitPointInfo
        {
            get { return localHitPointInfo; }
            set
            {

                SetArgument("localHitPointInfo", value);
                localHitPointInfo = value;
            }
        }

        private bool localImpulseInfo = false;
        /// <summary>
        /// impulse in local coordinates of bodyPart
        /// </summary>
        [EuphoriaDetail("impulse in local coordinates of bodyPart")]
        public bool LocalImpulseInfo
        {
            get { return localImpulseInfo; }
            set
            {

                SetArgument("localImpulseInfo", value);
                localImpulseInfo = value;
            }
        }

        private bool angularImpulse = false;
        /// <summary>
        /// impulse should be considered an angular impulse
        /// </summary>
        [EuphoriaDetail("impulse should be considered an angular impulse")]
        public bool AngularImpulse
        {
            get { return angularImpulse; }
            set
            {

                SetArgument("angularImpulse", value);
                angularImpulse = value;
            }
        }


        public EuphoriaMessageApplyImpulse(bool startNow) : base("applyImpulse", startNow)
        { }

        public new void Reset()
        {
            equalizeAmount = 0.000f;
            partIndex = 0;
            impulse = new Vector3(0f, 0f, 0f);
            hitPoint = new Vector3(0f, 0f, 0f);
            localHitPointInfo = false;
            localImpulseInfo = false;
            angularImpulse = false;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageApplyBulletImpulse : EuphoriaMessage
    {
        private float equalizeAmount = 0.000f;
        /// <summary>
        /// 0 means straight impulse, 1 means multiply by the mass (change in velocity)
        /// </summary>
        [EuphoriaDetail("0 means straight impulse, 1 means multiply by the mass (change in velocity)")]
        public float EqualizeAmount
        {
            get { return equalizeAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("equalizeAmount", value);
                equalizeAmount = value;
            }
        }

        private int partIndex = 0;
        /// <summary>
        /// index of part being hit.
        /// </summary>
        [EuphoriaDetail("index of part being hit.")]
        public int PartIndex
        {
            get { return partIndex; }
            set
            {
                value = MathHelper.Clamp(value, 0, 28);
                SetArgument("partIndex", value);
                partIndex = value;
            }
        }

        private Vector3 impulse = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// impulse vector (impulse is change in momentum)
        /// </summary>
        [EuphoriaDetail("impulse vector (impulse is change in momentum)")]
        public Vector3 Impulse
        {
            get { return impulse; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -1000.0f, 1000.0f);
                value.Y = MathHelper.Clamp(value.Y, -1000.0f, 1000.0f);
                value.Z = MathHelper.Clamp(value.Z, -1000.0f, 1000.0f);
                SetArgument("impulse", value);
                impulse = value;
            }
        }

        private Vector3 hitPoint = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// optional point on part where hit
        /// </summary>
        [EuphoriaDetail("optional point on part where hit")]
        public Vector3 HitPoint
        {
            get { return hitPoint; }
            set
            {

                SetArgument("hitPoint", value);
                hitPoint = value;
            }
        }

        private bool localHitPointInfo = false;
        /// <summary>
        /// true = hitPoint is in local coordinates of bodyPart, false = hitpoint is in world coordinates
        /// </summary>
        [EuphoriaDetail("true = hitPoint is in local coordinates of bodyPart, false = hitpoint is in world coordinates")]
        public bool LocalHitPointInfo
        {
            get { return localHitPointInfo; }
            set
            {

                SetArgument("localHitPointInfo", value);
                localHitPointInfo = value;
            }
        }

        private float extraShare = 0.00f;
        /// <summary>
        /// if not 0.0 then have an extra bullet applied to spine0 (approximates the COM).  Uses setup from configureBulletsExtra.  0-1 shared 0.0 = no extra bullet, 0.5 = impulse split equally between extra and bullet,  1.0 only extra bullet.  LT 0.0 then bullet + scaled extra bullet.  Eg.-0.5 = bullet + 0.5 impulse extra bullet
        /// </summary>
        [EuphoriaDetail("if not 0.0 then have an extra bullet applied to spine0 (approximates the COM).  Uses setup from configureBulletsExtra.  0-1 shared 0.0 = no extra bullet, 0.5 = impulse split equally between extra and bullet,  1.0 only extra bullet.  LT 0.0 then bullet + scaled extra bullet.  Eg.-0.5 = bullet + 0.5 impulse extra bullet")]
        public float ExtraShare
        {
            get { return extraShare; }
            set
            {
                value = MathHelper.Clamp(value, -2.00f, 1.00f);
                SetArgument("extraShare", value);
                extraShare = value;
            }
        }


        public EuphoriaMessageApplyBulletImpulse(bool startNow) : base("applyBulletImpulse", startNow)
        { }

        public new void Reset()
        {
            equalizeAmount = 0.000f;
            partIndex = 0;
            impulse = new Vector3(0f, 0f, 0f);
            hitPoint = new Vector3(0f, 0f, 0f);
            localHitPointInfo = false;
            extraShare = 0.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// bodyRelax:  Set the amount of relaxation across the whole body; Used to collapse the character into a rag-doll-like state.
    /// </summary>
    [EuphoriaDetail("bodyRelax:  Set the amount of relaxation across the whole body; Used to collapse the character into a rag-doll-like state.")]
    internal class EuphoriaMessageBodyRelax : EuphoriaMessage
    {
        private float relaxation = 50.000f;
        /// <summary>
        /// How relaxed the body becomes, in percentage relaxed. 100 being totally rag-dolled, 0 being very stiff and rigid.
        /// </summary>
        [EuphoriaDetail("How relaxed the body becomes, in percentage relaxed. 100 being totally rag-dolled, 0 being very stiff and rigid.")]
        public float Relaxation
        {
            get { return relaxation; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 100.0f);
                SetArgument("relaxation", value);
                relaxation = value;
            }
        }

        private float damping = 1.0f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float Damping
        {
            get { return damping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("damping", value);
                damping = value;
            }
        }

        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }

        private bool holdPose = false;
        /// <summary>
        /// automatically hold the current pose as the character relaxes - can be used to avoid relaxing into a t-pose
        /// </summary>
        [EuphoriaDetail("automatically hold the current pose as the character relaxes - can be used to avoid relaxing into a t-pose")]
        public bool HoldPose
        {
            get { return holdPose; }
            set
            {

                SetArgument("holdPose", value);
                holdPose = value;
            }
        }

        private bool disableJointDriving = false;
        /// <summary>
        /// sets the drive state to free - this reduces drifting on the ground
        /// </summary>
        [EuphoriaDetail("sets the drive state to free - this reduces drifting on the ground")]
        public bool DisableJointDriving
        {
            get { return disableJointDriving; }
            set
            {

                SetArgument("disableJointDriving", value);
                disableJointDriving = value;
            }
        }


        public EuphoriaMessageBodyRelax(bool startNow) : base("bodyRelax", startNow)
        { }

        public new void Reset()
        {
            relaxation = 50.000f;
            damping = 1.0f;
            mask = "fb";
            holdPose = false;
            disableJointDriving = false;
            base.Reset();
        }
    }


    /// <summary>
    /// configureBalance:  This single message allows you to configure various parameters used on any behaviour that uses the dynamic balance.
    /// </summary>
    [EuphoriaDetail("configureBalance:  This single message allows you to configure various parameters used on any behaviour that uses the dynamic balance.")]
    internal class EuphoriaMessageConfigureBalance : EuphoriaMessage
    {
        private float stepHeight = 0.100f;
        /// <summary>
        /// maximum height that character steps vertically (above 0.2 is high...but ok for say underwater)
        /// </summary>
        [EuphoriaDetail("maximum height that character steps vertically (above 0.2 is high...but ok for say underwater)")]
        public float StepHeight
        {
            get { return stepHeight; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 0.40f);
                SetArgument("stepHeight", value);
                stepHeight = value;
            }
        }

        private float stepHeightInc4Step = 0.100f;
        /// <summary>
        /// added to stepHeight if going up steps
        /// </summary>
        [EuphoriaDetail("added to stepHeight if going up steps")]
        public float StepHeightInc4Step
        {
            get { return stepHeightInc4Step; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 0.40f);
                SetArgument("stepHeightInc4Step", value);
                stepHeightInc4Step = value;
            }
        }

        private float legsApartRestep = 0.200f;
        /// <summary>
        /// if the legs end up more than (legsApartRestep + hipwidth) apart even though balanced, take another step
        /// </summary>
        [EuphoriaDetail("if the legs end up more than (legsApartRestep + hipwidth) apart even though balanced, take another step")]
        public float LegsApartRestep
        {
            get { return legsApartRestep; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.00f);
                SetArgument("legsApartRestep", value);
                legsApartRestep = value;
            }
        }

        private float legsTogetherRestep = 1.0f;
        /// <summary>
        /// mmmm0.1 for drunk if the legs end up less than (hipwidth - legsTogetherRestep) apart even though balanced, take another step.  A value of 1 will turn off this feature and the max value is hipWidth = 0.23f by default but is model dependent
        /// </summary>
        [EuphoriaDetail("mmmm0.1 for drunk if the legs end up less than (hipwidth - legsTogetherRestep) apart even though balanced, take another step.  A value of 1 will turn off this feature and the max value is hipWidth = 0.23f by default but is model dependent")]
        public float LegsTogetherRestep
        {
            get { return legsTogetherRestep; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.00f);
                SetArgument("legsTogetherRestep", value);
                legsTogetherRestep = value;
            }
        }

        private float legsApartMax = 2.000f;
        /// <summary>
        /// FRICTION WORKAROUND: if the legs end up more than (legsApartMax + hipwidth) apart when balanced, adjust the feet positions to slide back so they are legsApartMax + hipwidth apart.  Needs to be less than legsApartRestep to see any effect
        /// </summary>
        [EuphoriaDetail("FRICTION WORKAROUND: if the legs end up more than (legsApartMax + hipwidth) apart when balanced, adjust the feet positions to slide back so they are legsApartMax + hipwidth apart.  Needs to be less than legsApartRestep to see any effect")]
        public float LegsApartMax
        {
            get { return legsApartMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("legsApartMax", value);
                legsApartMax = value;
            }
        }

        private bool taperKneeStrength = true;
        /// <summary>
        /// does the knee strength reduce with angle
        /// </summary>
        [EuphoriaDetail("does the knee strength reduce with angle")]
        public bool TaperKneeStrength
        {
            get { return taperKneeStrength; }
            set
            {

                SetArgument("taperKneeStrength", value);
                taperKneeStrength = value;
            }
        }

        private float legStiffness = 12.000f;
        /// <summary>
        /// stiffness of legs
        /// </summary>
        [EuphoriaDetail("stiffness of legs")]
        public float LegStiffness
        {
            get { return legStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("legStiffness", value);
                legStiffness = value;
            }
        }

        private float leftLegSwingDamping = 1.000f;
        /// <summary>
        /// damping of left leg during swing phase (mmmmDrunk used 1.25 to slow legs movement)
        /// </summary>
        [EuphoriaDetail("damping of left leg during swing phase (mmmmDrunk used 1.25 to slow legs movement)")]
        public float LeftLegSwingDamping
        {
            get { return leftLegSwingDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.20f, 4.0f);
                SetArgument("leftLegSwingDamping", value);
                leftLegSwingDamping = value;
            }
        }

        private float rightLegSwingDamping = 1.000f;
        /// <summary>
        /// damping of right leg during swing phase (mmmmDrunk used 1.25 to slow legs movement)
        /// </summary>
        [EuphoriaDetail("damping of right leg during swing phase (mmmmDrunk used 1.25 to slow legs movement)")]
        public float RightLegSwingDamping
        {
            get { return rightLegSwingDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.20f, 4.0f);
                SetArgument("rightLegSwingDamping", value);
                rightLegSwingDamping = value;
            }
        }

        private float opposeGravityLegs = 1.000f;
        /// <summary>
        /// Gravity opposition applied to hips and knees
        /// </summary>
        [EuphoriaDetail("Gravity opposition applied to hips and knees")]
        public float OpposeGravityLegs
        {
            get { return opposeGravityLegs; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 4.0f);
                SetArgument("opposeGravityLegs", value);
                opposeGravityLegs = value;
            }
        }

        private float opposeGravityAnkles = 1.000f;
        /// <summary>
        /// Gravity opposition applied to ankles.  General balancer likes 1.0.  StaggerFall likes 0.1
        /// </summary>
        [EuphoriaDetail("Gravity opposition applied to ankles.  General balancer likes 1.0.  StaggerFall likes 0.1")]
        public float OpposeGravityAnkles
        {
            get { return opposeGravityAnkles; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 4.0f);
                SetArgument("opposeGravityAnkles", value);
                opposeGravityAnkles = value;
            }
        }

        private float leanAcc = 0.00f;
        /// <summary>
        /// Multiplier on the floorAcceleration added to the lean
        /// </summary>
        [EuphoriaDetail("Multiplier on the floorAcceleration added to the lean")]
        public float LeanAcc
        {
            get { return leanAcc; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("leanAcc", value);
                leanAcc = value;
            }
        }

        private float hipLeanAcc = 0.50f;
        /// <summary>
        /// Multiplier on the floorAcceleration added to the leanHips
        /// </summary>
        [EuphoriaDetail("Multiplier on the floorAcceleration added to the leanHips")]
        public float HipLeanAcc
        {
            get { return hipLeanAcc; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("hipLeanAcc", value);
                hipLeanAcc = value;
            }
        }

        private float leanAccMax = 5.000f;
        /// <summary>
        /// Max floorAcceleration allowed for lean and leanHips
        /// </summary>
        [EuphoriaDetail("Max floorAcceleration allowed for lean and leanHips")]
        public float LeanAccMax
        {
            get { return leanAccMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.0f);
                SetArgument("leanAccMax", value);
                leanAccMax = value;
            }
        }

        private float resistAcc = 0.50f;
        /// <summary>
        /// Level of cheat force added to character to resist the effect of floorAcceleration (anti-Acceleration) - added to upperbody.
        /// </summary>
        [EuphoriaDetail("Level of cheat force added to character to resist the effect of floorAcceleration (anti-Acceleration) - added to upperbody.")]
        public float ResistAcc
        {
            get { return resistAcc; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.0f);
                SetArgument("resistAcc", value);
                resistAcc = value;
            }
        }

        private float resistAccMax = 3.00f;
        /// <summary>
        /// Max floorAcceleration allowed for anti-Acceleration. If  GT 20.0 then it is probably in a crash
        /// </summary>
        [EuphoriaDetail("Max floorAcceleration allowed for anti-Acceleration. If  GT 20.0 then it is probably in a crash")]
        public float ResistAccMax
        {
            get { return resistAccMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.0f);
                SetArgument("resistAccMax", value);
                resistAccMax = value;
            }
        }

        private bool footSlipCompOnMovingFloor = true;
        /// <summary>
        /// This parameter will be removed when footSlipCompensation preserves the foot angle on a moving floor]. If the character detects a moving floor and footSlipCompOnMovingFloor is false then it will turn off footSlipCompensation - at footSlipCompensation preserves the global heading of the feet.  If footSlipCompensation is off then the character usually turns to the side in the end although when turning the vehicle turns it looks promising for a while
        /// </summary>
        [EuphoriaDetail("This parameter will be removed when footSlipCompensation preserves the foot angle on a moving floor]. If the character detects a moving floor and footSlipCompOnMovingFloor is false then it will turn off footSlipCompensation - at footSlipCompensation preserves the global heading of the feet.  If footSlipCompensation is off then the character usually turns to the side in the end although when turning the vehicle turns it looks promising for a while")]
        public bool FootSlipCompOnMovingFloor
        {
            get { return footSlipCompOnMovingFloor; }
            set
            {

                SetArgument("footSlipCompOnMovingFloor", value);
                footSlipCompOnMovingFloor = value;
            }
        }

        private float ankleEquilibrium = 0.000f;
        /// <summary>
        /// ankle equilibrium angle used when static balancing
        /// </summary>
        [EuphoriaDetail("ankle equilibrium angle used when static balancing")]
        public float AnkleEquilibrium
        {
            get { return ankleEquilibrium; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.0f);
                SetArgument("ankleEquilibrium", value);
                ankleEquilibrium = value;
            }
        }

        private float extraFeetApart = 0.000f;
        /// <summary>
        /// additional feet apart setting
        /// </summary>
        [EuphoriaDetail("additional feet apart setting")]
        public float ExtraFeetApart
        {
            get { return extraFeetApart; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.0f);
                SetArgument("extraFeetApart", value);
                extraFeetApart = value;
            }
        }

        private float dontStepTime = 0.00f;
        /// <summary>
        /// amount of time at the start of a balance before the character is allowed to start stepping
        /// </summary>
        [EuphoriaDetail("amount of time at the start of a balance before the character is allowed to start stepping")]
        public float DontStepTime
        {
            get { return dontStepTime; }
            set
            {

                SetArgument("dontStepTime", value);
                dontStepTime = value;
            }
        }

        private float balanceAbortThreshold = 0.600f;
        /// <summary>
        /// when the character gives up and goes into a fall.  Larger values mean that the balancer can lean more before failing.
        /// </summary>
        [EuphoriaDetail("when the character gives up and goes into a fall.  Larger values mean that the balancer can lean more before failing.")]
        public float BalanceAbortThreshold
        {
            get { return balanceAbortThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("balanceAbortThreshold", value);
                balanceAbortThreshold = value;
            }
        }

        private float giveUpHeight = 0.50f;
        /// <summary>
        /// height between lowest foot and COM below which balancer will give up
        /// </summary>
        [EuphoriaDetail("height between lowest foot and COM below which balancer will give up")]
        public float GiveUpHeight
        {
            get { return giveUpHeight; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.50f);
                SetArgument("giveUpHeight", value);
                giveUpHeight = value;
            }
        }

        private float stepClampScale = 1.000f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float StepClampScale
        {
            get { return stepClampScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("stepClampScale", value);
                stepClampScale = value;
            }
        }

        private float stepClampScaleVariance = 0.000f;
        /// <summary>
        /// Variance in clamp scale every step. if negative only takes away from clampScale
        /// </summary>
        [EuphoriaDetail("Variance in clamp scale every step. if negative only takes away from clampScale")]
        public float StepClampScaleVariance
        {
            get { return stepClampScaleVariance; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("stepClampScaleVariance", value);
                stepClampScaleVariance = value;
            }
        }

        private float predictionTimeHip = 0.30f;
        /// <summary>
        /// amount of time (seconds) into the future that the character tries to move hip to (kind of).  Will be controlled by balancer in future but can help recover spine quicker from bending forwards to much.
        /// </summary>
        [EuphoriaDetail("amount of time (seconds) into the future that the character tries to move hip to (kind of).  Will be controlled by balancer in future but can help recover spine quicker from bending forwards to much.")]
        public float PredictionTimeHip
        {
            get { return predictionTimeHip; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("predictionTimeHip", value);
                predictionTimeHip = value;
            }
        }

        private float predictionTime = 0.20f;
        /// <summary>
        /// amount of time (seconds) into the future that the character tries to step to. bigger values try to recover with fewer, bigger steps. smaller values recover with smaller steps, and generally recover less.
        /// </summary>
        [EuphoriaDetail("amount of time (seconds) into the future that the character tries to step to. bigger values try to recover with fewer, bigger steps. smaller values recover with smaller steps, and generally recover less.")]
        public float PredictionTime
        {
            get { return predictionTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("predictionTime", value);
                predictionTime = value;
            }
        }

        private float predictionTimeVariance = 0.00f;
        /// <summary>
        /// Variance in predictionTime every step. if negative only takes away from predictionTime
        /// </summary>
        [EuphoriaDetail("Variance in predictionTime every step. if negative only takes away from predictionTime")]
        public float PredictionTimeVariance
        {
            get { return predictionTimeVariance; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("predictionTimeVariance", value);
                predictionTimeVariance = value;
            }
        }

        private int maxSteps = 100;
        /// <summary>
        /// Maximum number of steps that the balancer will take.
        /// </summary>
        [EuphoriaDetail("Maximum number of steps that the balancer will take.")]
        public int MaxSteps
        {
            get { return maxSteps; }
            set
            {

                SetArgument("maxSteps", value);
                maxSteps = value;
            }
        }

        private float maxBalanceTime = 50.0f;
        /// <summary>
        /// Maximum time(seconds) that the balancer will balance for.
        /// </summary>
        [EuphoriaDetail("Maximum time(seconds) that the balancer will balance for.")]
        public float MaxBalanceTime
        {
            get { return maxBalanceTime; }
            set
            {

                SetArgument("maxBalanceTime", value);
                maxBalanceTime = value;
            }
        }

        private int extraSteps = -1;
        /// <summary>
        /// Allow the balancer to take this many more steps before hitting maxSteps. If negative nothing happens(safe default)
        /// </summary>
        [EuphoriaDetail("Allow the balancer to take this many more steps before hitting maxSteps. If negative nothing happens(safe default)")]
        public int ExtraSteps
        {
            get { return extraSteps; }
            set
            {

                SetArgument("extraSteps", value);
                extraSteps = value;
            }
        }

        private float extraTime = -1.00f;
        /// <summary>
        /// Allow the balancer to balance for this many more seconds before hitting maxBalanceTime.  If negative nothing happens(safe default)
        /// </summary>
        [EuphoriaDetail("Allow the balancer to balance for this many more seconds before hitting maxBalanceTime.  If negative nothing happens(safe default)")]
        public float ExtraTime
        {
            get { return extraTime; }
            set
            {

                SetArgument("extraTime", value);
                extraTime = value;
            }
        }

        private int fallType = 0;
        /// <summary>
        /// How to fall after maxSteps or maxBalanceTime: 0=rampDown stiffness, 1= 0 and dontChangeStep, 2= 0 and forceBalance, 3=0 and slump (BCR has to be active)
        /// </summary>
        [EuphoriaDetail("How to fall after maxSteps or maxBalanceTime: 0=rampDown stiffness, 1= 0 and dontChangeStep, 2= 0 and forceBalance, 3=0 and slump (BCR has to be active)")]
        public int FallType
        {
            get { return fallType; }
            set
            {

                SetArgument("fallType", value);
                fallType = value;
            }
        }

        private float fallMult = 1.0f;
        /// <summary>
        /// Multiply the rampDown of stiffness on falling by this amount ( GT 1 fall quicker)
        /// </summary>
        [EuphoriaDetail("Multiply the rampDown of stiffness on falling by this amount ( GT 1 fall quicker)")]
        public float FallMult
        {
            get { return fallMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 100.0f);
                SetArgument("fallMult", value);
                fallMult = value;
            }
        }

        private bool fallReduceGravityComp = false;
        /// <summary>
        /// Reduce gravity compensation as the legs weaken on falling
        /// </summary>
        [EuphoriaDetail("Reduce gravity compensation as the legs weaken on falling")]
        public bool FallReduceGravityComp
        {
            get { return fallReduceGravityComp; }
            set
            {

                SetArgument("fallReduceGravityComp", value);
                fallReduceGravityComp = value;
            }
        }

        private bool rampHipPitchOnFail = false;
        /// <summary>
        /// bend over when falling after maxBalanceTime
        /// </summary>
        [EuphoriaDetail("bend over when falling after maxBalanceTime")]
        public bool RampHipPitchOnFail
        {
            get { return rampHipPitchOnFail; }
            set
            {

                SetArgument("rampHipPitchOnFail", value);
                rampHipPitchOnFail = value;
            }
        }

        private float stableLinSpeedThresh = 0.250f;
        /// <summary>
        /// Linear speed threshold for successful balance.
        /// </summary>
        [EuphoriaDetail("Linear speed threshold for successful balance.")]
        public float StableLinSpeedThresh
        {
            get { return stableLinSpeedThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 10.0f);
                SetArgument("stableLinSpeedThresh", value);
                stableLinSpeedThresh = value;
            }
        }

        private float stableRotSpeedThresh = 0.250f;
        /// <summary>
        /// Rotational speed threshold for successful balance.
        /// </summary>
        [EuphoriaDetail("Rotational speed threshold for successful balance.")]
        public float StableRotSpeedThresh
        {
            get { return stableRotSpeedThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 10.0f);
                SetArgument("stableRotSpeedThresh", value);
                stableRotSpeedThresh = value;
            }
        }

        private bool failMustCollide = false;
        /// <summary>
        /// The upper body of the character must be colliding and other failure conditions met to fail
        /// </summary>
        [EuphoriaDetail("The upper body of the character must be colliding and other failure conditions met to fail")]
        public bool FailMustCollide
        {
            get { return failMustCollide; }
            set
            {

                SetArgument("failMustCollide", value);
                failMustCollide = value;
            }
        }

        private bool ignoreFailure = false;
        /// <summary>
        /// Ignore maxSteps and maxBalanceTime and try to balance forever
        /// </summary>
        [EuphoriaDetail("Ignore maxSteps and maxBalanceTime and try to balance forever")]
        public bool IgnoreFailure
        {
            get { return ignoreFailure; }
            set
            {

                SetArgument("ignoreFailure", value);
                ignoreFailure = value;
            }
        }

        private float changeStepTime = -1.00f;
        /// <summary>
        /// time not in contact (airborne) before step is changed. If -ve don't change step
        /// </summary>
        [EuphoriaDetail("time not in contact (airborne) before step is changed. If -ve don't change step")]
        public float ChangeStepTime
        {
            get { return changeStepTime; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 5.0f);
                SetArgument("changeStepTime", value);
                changeStepTime = value;
            }
        }

        private bool balanceIndefinitely = false;
        /// <summary>
        /// Ignore maxSteps and maxBalanceTime and try to balance forever
        /// </summary>
        [EuphoriaDetail("Ignore maxSteps and maxBalanceTime and try to balance forever")]
        public bool BalanceIndefinitely
        {
            get { return balanceIndefinitely; }
            set
            {

                SetArgument("balanceIndefinitely", value);
                balanceIndefinitely = value;
            }
        }

        private bool movingFloor = false;
        /// <summary>
        /// temporary variable to ignore movingFloor code that generally causes the character to fall over if the feet probe a moving object e.g. treading on a gun
        /// </summary>
        [EuphoriaDetail("temporary variable to ignore movingFloor code that generally causes the character to fall over if the feet probe a moving object e.g. treading on a gun")]
        public bool MovingFloor
        {
            get { return movingFloor; }
            set
            {

                SetArgument("movingFloor", value);
                movingFloor = value;
            }
        }

        private bool airborneStep = true;
        /// <summary>
        /// when airborne try to step.  Set to false for e.g. shotGun reaction
        /// </summary>
        [EuphoriaDetail("when airborne try to step.  Set to false for e.g. shotGun reaction")]
        public bool AirborneStep
        {
            get { return airborneStep; }
            set
            {

                SetArgument("airborneStep", value);
                airborneStep = value;
            }
        }

        private float useComDirTurnVelThresh = 0.0f;
        /// <summary>
        /// Velocity below which the balancer turns in the direction of the COM forward instead of the ComVel - for use with shot from running with high upright constraint use 1.9
        /// </summary>
        [EuphoriaDetail("Velocity below which the balancer turns in the direction of the COM forward instead of the ComVel - for use with shot from running with high upright constraint use 1.9")]
        public float UseComDirTurnVelThresh
        {
            get { return useComDirTurnVelThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("useComDirTurnVelThresh", value);
                useComDirTurnVelThresh = value;
            }
        }

        private float minKneeAngle = -0.50f;
        /// <summary>
        /// Minimum knee angle (-ve value will mean this functionality is not applied).  0.4 seems a good value
        /// </summary>
        [EuphoriaDetail("Minimum knee angle (-ve value will mean this functionality is not applied).  0.4 seems a good value")]
        public float MinKneeAngle
        {
            get { return minKneeAngle; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 1.50f);
                SetArgument("minKneeAngle", value);
                minKneeAngle = value;
            }
        }

        private bool flatterSwingFeet = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool FlatterSwingFeet
        {
            get { return flatterSwingFeet; }
            set
            {

                SetArgument("flatterSwingFeet", value);
                flatterSwingFeet = value;
            }
        }

        private bool flatterStaticFeet = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool FlatterStaticFeet
        {
            get { return flatterStaticFeet; }
            set
            {

                SetArgument("flatterStaticFeet", value);
                flatterStaticFeet = value;
            }
        }

        private bool avoidLeg = false;
        /// <summary>
        /// If true then balancer tries to avoid leg2leg collisions/avoid crossing legs. Avoid tries to not step across a line of the inside of the stance leg's foot
        /// </summary>
        [EuphoriaDetail("If true then balancer tries to avoid leg2leg collisions/avoid crossing legs. Avoid tries to not step across a line of the inside of the stance leg's foot")]
        public bool AvoidLeg
        {
            get { return avoidLeg; }
            set
            {

                SetArgument("avoidLeg", value);
                avoidLeg = value;
            }
        }

        private float avoidFootWidth = 0.10f;
        /// <summary>
        /// NB. Very sensitive. Avoid tries to not step across a line of the inside of the stance leg's foot. avoidFootWidth = how much inwards from the ankle this line is in (m).
        /// </summary>
        [EuphoriaDetail("NB. Very sensitive. Avoid tries to not step across a line of the inside of the stance leg's foot. avoidFootWidth = how much inwards from the ankle this line is in (m).")]
        public float AvoidFootWidth
        {
            get { return avoidFootWidth; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("avoidFootWidth", value);
                avoidFootWidth = value;
            }
        }

        private float avoidFeedback = 0.60f;
        /// <summary>
        /// NB. Very sensitive. Avoid tries to not step across a line of the inside of the stance leg's foot. Avoid doesn't allow the desired stepping foot to cross the line.  avoidFeedback = how much of the actual crossing of that line is fedback as an error.
        /// </summary>
        [EuphoriaDetail("NB. Very sensitive. Avoid tries to not step across a line of the inside of the stance leg's foot. Avoid doesn't allow the desired stepping foot to cross the line.  avoidFeedback = how much of the actual crossing of that line is fedback as an error.")]
        public float AvoidFeedback
        {
            get { return avoidFeedback; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.0f);
                SetArgument("avoidFeedback", value);
                avoidFeedback = value;
            }
        }

        private float leanAgainstVelocity = 0.0f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float LeanAgainstVelocity
        {
            get { return leanAgainstVelocity; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("leanAgainstVelocity", value);
                leanAgainstVelocity = value;
            }
        }

        private float stepDecisionThreshold = 0.0f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float StepDecisionThreshold
        {
            get { return stepDecisionThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("stepDecisionThreshold", value);
                stepDecisionThreshold = value;
            }
        }

        private bool stepIfInSupport = true;
        /// <summary>
        /// The balancer sometimes decides to step even if balanced
        /// </summary>
        [EuphoriaDetail("The balancer sometimes decides to step even if balanced")]
        public bool StepIfInSupport
        {
            get { return stepIfInSupport; }
            set
            {

                SetArgument("stepIfInSupport", value);
                stepIfInSupport = value;
            }
        }

        private bool alwaysStepWithFarthest = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool AlwaysStepWithFarthest
        {
            get { return alwaysStepWithFarthest; }
            set
            {

                SetArgument("alwaysStepWithFarthest", value);
                alwaysStepWithFarthest = value;
            }
        }

        private bool standUp = false;
        /// <summary>
        /// standup more with increased velocity
        /// </summary>
        [EuphoriaDetail("standup more with increased velocity")]
        public bool StandUp
        {
            get { return standUp; }
            set
            {

                SetArgument("standUp", value);
                standUp = value;
            }
        }

        private float depthFudge = 0.010f;
        /// <summary>
        /// Supposed to increase foot friction: Impact depth of a collision with the foot is changed when the balancer is running - impact.SetDepth(impact.GetDepth() - depthFudge)
        /// </summary>
        [EuphoriaDetail("Supposed to increase foot friction: Impact depth of a collision with the foot is changed when the balancer is running - impact.SetDepth(impact.GetDepth() - depthFudge)")]
        public float DepthFudge
        {
            get { return depthFudge; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("depthFudge", value);
                depthFudge = value;
            }
        }

        private float depthFudgeStagger = 0.010f;
        /// <summary>
        /// Supposed to increase foot friction: Impact depth of a collision with the foot is changed when staggerFall is running - impact.SetDepth(impact.GetDepth() - depthFudgeStagger)
        /// </summary>
        [EuphoriaDetail("Supposed to increase foot friction: Impact depth of a collision with the foot is changed when staggerFall is running - impact.SetDepth(impact.GetDepth() - depthFudgeStagger)")]
        public float DepthFudgeStagger
        {
            get { return depthFudgeStagger; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("depthFudgeStagger", value);
                depthFudgeStagger = value;
            }
        }

        private float footFriction = 1.0f;
        /// <summary>
        /// Foot friction multiplier is multiplied by this amount if balancer is running
        /// </summary>
        [EuphoriaDetail("Foot friction multiplier is multiplied by this amount if balancer is running")]
        public float FootFriction
        {
            get { return footFriction; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 40.0f);
                SetArgument("footFriction", value);
                footFriction = value;
            }
        }

        private float footFrictionStagger = 1.0f;
        /// <summary>
        /// Foot friction multiplier is multiplied by this amount if staggerFall is running
        /// </summary>
        [EuphoriaDetail("Foot friction multiplier is multiplied by this amount if staggerFall is running")]
        public float FootFrictionStagger
        {
            get { return footFrictionStagger; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 40.0f);
                SetArgument("footFrictionStagger", value);
                footFrictionStagger = value;
            }
        }

        private float backwardsLeanCutoff = 1.10f;
        /// <summary>
        /// Backwards lean threshold to cut off stay upright forces. 0.0 Vertical - 1.0 horizontal.  0.6 is a sensible value.  NB: the balancer does not fail in order to give stagger that extra step as it falls.  A backwards lean of GT 0.6 will generally mean the balancer will soon fail without stayUpright forces.
        /// </summary>
        [EuphoriaDetail("Backwards lean threshold to cut off stay upright forces. 0.0 Vertical - 1.0 horizontal.  0.6 is a sensible value.  NB: the balancer does not fail in order to give stagger that extra step as it falls.  A backwards lean of GT 0.6 will generally mean the balancer will soon fail without stayUpright forces.")]
        public float BackwardsLeanCutoff
        {
            get { return backwardsLeanCutoff; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("backwardsLeanCutoff", value);
                backwardsLeanCutoff = value;
            }
        }

        private float giveUpHeightEnd = 0.50f;
        /// <summary>
        /// if this value is different from giveUpHeight, actual giveUpHeight will be ramped toward this value
        /// </summary>
        [EuphoriaDetail("if this value is different from giveUpHeight, actual giveUpHeight will be ramped toward this value")]
        public float GiveUpHeightEnd
        {
            get { return giveUpHeightEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.50f);
                SetArgument("giveUpHeightEnd", value);
                giveUpHeightEnd = value;
            }
        }

        private float balanceAbortThresholdEnd = 0.60f;
        /// <summary>
        /// if this value is different from balanceAbortThreshold, actual balanceAbortThreshold will be ramped toward this value
        /// </summary>
        [EuphoriaDetail("if this value is different from balanceAbortThreshold, actual balanceAbortThreshold will be ramped toward this value")]
        public float BalanceAbortThresholdEnd
        {
            get { return balanceAbortThresholdEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("balanceAbortThresholdEnd", value);
                balanceAbortThresholdEnd = value;
            }
        }

        private float giveUpRampDuration = -1.00f;
        /// <summary>
        /// duration of ramp from start of behaviour for above two parameters. If smaller than 0, no ramp is applied
        /// </summary>
        [EuphoriaDetail("duration of ramp from start of behaviour for above two parameters. If smaller than 0, no ramp is applied")]
        public float GiveUpRampDuration
        {
            get { return giveUpRampDuration; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 10.0f);
                SetArgument("giveUpRampDuration", value);
                giveUpRampDuration = value;
            }
        }

        private float leanToAbort = 0.60f;
        /// <summary>
        /// lean at which to send abort message when maxSteps or maxBalanceTime is reached
        /// </summary>
        [EuphoriaDetail("lean at which to send abort message when maxSteps or maxBalanceTime is reached")]
        public float LeanToAbort
        {
            get { return leanToAbort; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("leanToAbort", value);
                leanToAbort = value;
            }
        }


        public EuphoriaMessageConfigureBalance(bool startNow) : base("configureBalance", startNow)
        { }

        public new void Reset()
        {
            stepHeight = 0.100f;
            stepHeightInc4Step = 0.100f;
            legsApartRestep = 0.200f;
            legsTogetherRestep = 1.0f;
            legsApartMax = 2.000f;
            taperKneeStrength = true;
            legStiffness = 12.000f;
            leftLegSwingDamping = 1.000f;
            rightLegSwingDamping = 1.000f;
            opposeGravityLegs = 1.000f;
            opposeGravityAnkles = 1.000f;
            leanAcc = 0.00f;
            hipLeanAcc = 0.50f;
            leanAccMax = 5.000f;
            resistAcc = 0.50f;
            resistAccMax = 3.00f;
            footSlipCompOnMovingFloor = true;
            ankleEquilibrium = 0.000f;
            extraFeetApart = 0.000f;
            dontStepTime = 0.00f;
            balanceAbortThreshold = 0.600f;
            giveUpHeight = 0.50f;
            stepClampScale = 1.000f;
            stepClampScaleVariance = 0.000f;
            predictionTimeHip = 0.30f;
            predictionTime = 0.20f;
            predictionTimeVariance = 0.00f;
            maxSteps = 100;
            maxBalanceTime = 50.0f;
            extraSteps = -1;
            extraTime = -1.00f;
            fallType = 0;
            fallMult = 1.0f;
            fallReduceGravityComp = false;
            rampHipPitchOnFail = false;
            stableLinSpeedThresh = 0.250f;
            stableRotSpeedThresh = 0.250f;
            failMustCollide = false;
            ignoreFailure = false;
            changeStepTime = -1.00f;
            balanceIndefinitely = false;
            movingFloor = false;
            airborneStep = true;
            useComDirTurnVelThresh = 0.0f;
            minKneeAngle = -0.50f;
            flatterSwingFeet = false;
            flatterStaticFeet = false;
            avoidLeg = false;
            avoidFootWidth = 0.10f;
            avoidFeedback = 0.60f;
            leanAgainstVelocity = 0.0f;
            stepDecisionThreshold = 0.0f;
            stepIfInSupport = true;
            alwaysStepWithFarthest = false;
            standUp = false;
            depthFudge = 0.010f;
            depthFudgeStagger = 0.010f;
            footFriction = 1.0f;
            footFrictionStagger = 1.0f;
            backwardsLeanCutoff = 1.10f;
            giveUpHeightEnd = 0.50f;
            balanceAbortThresholdEnd = 0.60f;
            giveUpRampDuration = -1.00f;
            leanToAbort = 0.60f;
            base.Reset();
        }
    }


    /// <summary>
    /// configureBalanceReset:  reset the values configurable by the Configure Balance message to their defaults.
    /// </summary>
    [EuphoriaDetail("configureBalanceReset:  reset the values configurable by the Configure Balance message to their defaults.")]
    internal class EuphoriaMessageConfigureBalanceReset : EuphoriaMessage
    {

        public EuphoriaMessageConfigureBalanceReset(bool startNow) : base("configureBalanceReset", startNow)
        { }

        public new void Reset()
        {
            base.Reset();
        }
    }


    /// <summary>
    /// configureSelfAvoidance: this single message allows to configure self avoidance for the character.BBDD Self avoidance tech.
    /// </summary>
    [EuphoriaDetail("configureSelfAvoidance: this single message allows to configure self avoidance for the character.BBDD Self avoidance tech.")]
    internal class EuphoriaMessageConfigureSelfAvoidance : EuphoriaMessage
    {
        private bool useSelfAvoidance = false;
        /// <summary>
        /// Enable or disable self avoidance tech.
        /// </summary>
        [EuphoriaDetail("Enable or disable self avoidance tech.")]
        public bool UseSelfAvoidance
        {
            get { return useSelfAvoidance; }
            set
            {

                SetArgument("useSelfAvoidance", value);
                useSelfAvoidance = value;
            }
        }

        private bool overwriteDragReduction = false;
        /// <summary>
        /// Specify whether self avoidance tech should use original IK input target or the target that has been already modified by getStabilisedPos() tech i.e. function that compensates for rotational and linear velocity of shoulder/thigh.
        /// </summary>
        [EuphoriaDetail("Specify whether self avoidance tech should use original IK input target or the target that has been already modified by getStabilisedPos() tech i.e. function that compensates for rotational and linear velocity of shoulder/thigh.")]
        public bool OverwriteDragReduction
        {
            get { return overwriteDragReduction; }
            set
            {

                SetArgument("overwriteDragReduction", value);
                overwriteDragReduction = value;
            }
        }

        private float torsoSwingFraction = 0.750f;
        /// <summary>
        /// Place the adjusted target this much along the arc between effector (wrist) and target, value in range [0,1].
        /// </summary>
        [EuphoriaDetail("Place the adjusted target this much along the arc between effector (wrist) and target, value in range [0,1].")]
        public float TorsoSwingFraction
        {
            get { return torsoSwingFraction; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torsoSwingFraction", value);
                torsoSwingFraction = value;
            }
        }

        private float maxTorsoSwingAngleRad = 0.7580f;
        /// <summary>
        /// Max value on the effector (wrist) to adjusted target offset.
        /// </summary>
        [EuphoriaDetail("Max value on the effector (wrist) to adjusted target offset.")]
        public float MaxTorsoSwingAngleRad
        {
            get { return maxTorsoSwingAngleRad; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.570f);
                SetArgument("maxTorsoSwingAngleRad", value);
                maxTorsoSwingAngleRad = value;
            }
        }

        private bool selfAvoidIfInSpineBoundsOnly = false;
        /// <summary>
        /// Restrict self avoidance to operate on targets that are within character torso bounds only.
        /// </summary>
        [EuphoriaDetail("Restrict self avoidance to operate on targets that are within character torso bounds only.")]
        public bool SelfAvoidIfInSpineBoundsOnly
        {
            get { return selfAvoidIfInSpineBoundsOnly; }
            set
            {

                SetArgument("selfAvoidIfInSpineBoundsOnly", value);
                selfAvoidIfInSpineBoundsOnly = value;
            }
        }

        private float selfAvoidAmount = 0.50f;
        /// <summary>
        /// Amount of self avoidance offset applied when angle from effector (wrist) to target is greater then right angle i.e. when total offset is a blend between where effector currently is to value that is a product of total arm length and selfAvoidAmount. SelfAvoidAmount is in a range between [0, 1].
        /// </summary>
        [EuphoriaDetail("Amount of self avoidance offset applied when angle from effector (wrist) to target is greater then right angle i.e. when total offset is a blend between where effector currently is to value that is a product of total arm length and selfAvoidAmount. SelfAvoidAmount is in a range between [0, 1].")]
        public float SelfAvoidAmount
        {
            get { return selfAvoidAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("selfAvoidAmount", value);
                selfAvoidAmount = value;
            }
        }

        private bool overwriteTwist = false;
        /// <summary>
        /// Overwrite desired IK twist with self avoidance procedural twist.
        /// </summary>
        [EuphoriaDetail("Overwrite desired IK twist with self avoidance procedural twist.")]
        public bool OverwriteTwist
        {
            get { return overwriteTwist; }
            set
            {

                SetArgument("overwriteTwist", value);
                overwriteTwist = value;
            }
        }

        private bool usePolarPathAlgorithm = false;
        /// <summary>
        /// Use the alternative self avoidance algorithm that is based on linear and polar target blending. WARNING: It only requires "radius" in terms of parametrization.
        /// </summary>
        [EuphoriaDetail("Use the alternative self avoidance algorithm that is based on linear and polar target blending. WARNING: It only requires \"radius\" in terms of parametrization.")]
        public bool UsePolarPathAlgorithm
        {
            get { return usePolarPathAlgorithm; }
            set
            {

                SetArgument("usePolarPathAlgorithm", value);
                usePolarPathAlgorithm = value;
            }
        }

        private float radius = 0.30f;
        /// <summary>
        /// Self avoidance radius, measured out from the spine axis along the plane perpendicular to that axis. The closer is the proximity of reaching target to that radius, the more polar (curved) motion is used for offsetting the target. WARNING: Parameter only used by the alternative algorithm that is based on linear and polar target blending.
        /// </summary>
        [EuphoriaDetail("Self avoidance radius, measured out from the spine axis along the plane perpendicular to that axis. The closer is the proximity of reaching target to that radius, the more polar (curved) motion is used for offsetting the target. WARNING: Parameter only used by the alternative algorithm that is based on linear and polar target blending.")]
        public float Radius
        {
            get { return radius; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("radius", value);
                radius = value;
            }
        }


        public EuphoriaMessageConfigureSelfAvoidance(bool startNow) : base("configureSelfAvoidance", startNow)
        { }

        public new void Reset()
        {
            useSelfAvoidance = false;
            overwriteDragReduction = false;
            torsoSwingFraction = 0.750f;
            maxTorsoSwingAngleRad = 0.7580f;
            selfAvoidIfInSpineBoundsOnly = false;
            selfAvoidAmount = 0.50f;
            overwriteTwist = false;
            usePolarPathAlgorithm = false;
            radius = 0.30f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageConfigureBullets : EuphoriaMessage
    {
        private bool impulseSpreadOverParts = false;
        /// <summary>
        /// spreads impulse across parts. currently only for spine parts, not limbs.
        /// </summary>
        [EuphoriaDetail("spreads impulse across parts. currently only for spine parts, not limbs.")]
        public bool ImpulseSpreadOverParts
        {
            get { return impulseSpreadOverParts; }
            set
            {

                SetArgument("impulseSpreadOverParts", value);
                impulseSpreadOverParts = value;
            }
        }

        private bool impulseLeakageStrengthScaled = false;
        /// <summary>
        /// for weaker characters subsequent impulses remain strong
        /// </summary>
        [EuphoriaDetail("for weaker characters subsequent impulses remain strong")]
        public bool ImpulseLeakageStrengthScaled
        {
            get { return impulseLeakageStrengthScaled; }
            set
            {

                SetArgument("impulseLeakageStrengthScaled", value);
                impulseLeakageStrengthScaled = value;
            }
        }

        private float impulsePeriod = 0.10f;
        /// <summary>
        /// duration that impulse is spread over (triangular shaped)
        /// </summary>
        [EuphoriaDetail("duration that impulse is spread over (triangular shaped)")]
        public float ImpulsePeriod
        {
            get { return impulsePeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulsePeriod", value);
                impulsePeriod = value;
            }
        }

        private float impulseTorqueScale = 1.00f;
        /// <summary>
        /// An impulse applied at a point on a body equivalent to an impulse at the centre of the body and a torque.  This parameter scales the torque component. (The torque component seems to be excite the rage looseness bug which sends the character in a sometimes wildly different direction to an applied impulse)
        /// </summary>
        [EuphoriaDetail("An impulse applied at a point on a body equivalent to an impulse at the centre of the body and a torque.  This parameter scales the torque component. (The torque component seems to be excite the rage looseness bug which sends the character in a sometimes wildly different direction to an applied impulse)")]
        public float ImpulseTorqueScale
        {
            get { return impulseTorqueScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseTorqueScale", value);
                impulseTorqueScale = value;
            }
        }

        private bool loosenessFix = false;
        /// <summary>
        /// Fix the rage looseness bug by applying only the impulse at the centre of the body unless it is a spine part then apply the twist component only of the torque as well.
        /// </summary>
        [EuphoriaDetail("Fix the rage looseness bug by applying only the impulse at the centre of the body unless it is a spine part then apply the twist component only of the torque as well.")]
        public bool LoosenessFix
        {
            get { return loosenessFix; }
            set
            {

                SetArgument("loosenessFix", value);
                loosenessFix = value;
            }
        }

        private float impulseDelay = 0.00f;
        /// <summary>
        /// time from hit before impulses are being applied
        /// </summary>
        [EuphoriaDetail("time from hit before impulses are being applied")]
        public float ImpulseDelay
        {
            get { return impulseDelay; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseDelay", value);
                impulseDelay = value;
            }
        }

        private float impulseReductionPerShot = 0.00f;
        /// <summary>
        /// by how much are subsequent impulses reduced (e.g. 0.0: no reduction, 0.1: 10% reduction each new hit)
        /// </summary>
        [EuphoriaDetail("by how much are subsequent impulses reduced (e.g. 0.0: no reduction, 0.1: 10% reduction each new hit)")]
        public float ImpulseReductionPerShot
        {
            get { return impulseReductionPerShot; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseReductionPerShot", value);
                impulseReductionPerShot = value;
            }
        }

        private float impulseRecovery = 0.00f;
        /// <summary>
        /// recovery rate of impulse strength per second (impulse strength from 0.0:1.0).  At 60fps a impulseRecovery=60.0 will recover in 1 frame
        /// </summary>
        [EuphoriaDetail("recovery rate of impulse strength per second (impulse strength from 0.0:1.0).  At 60fps a impulseRecovery=60.0 will recover in 1 frame")]
        public float ImpulseRecovery
        {
            get { return impulseRecovery; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 60.00f);
                SetArgument("impulseRecovery", value);
                impulseRecovery = value;
            }
        }

        private float impulseMinLeakage = 0.20f;
        /// <summary>
        /// the minimum amount of impulse leakage allowed
        /// </summary>
        [EuphoriaDetail("the minimum amount of impulse leakage allowed")]
        public float ImpulseMinLeakage
        {
            get { return impulseMinLeakage; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseMinLeakage", value);
                impulseMinLeakage = value;
            }
        }

        private int torqueMode = 0;
        /// <summary>
        /// 0: Disabled | 1: character strength proportional (can reduce impulse amount) | 2: Additive (no reduction of impulse and not proportional to character strength)
        /// </summary>
        [EuphoriaDetail("0: Disabled | 1: character strength proportional (can reduce impulse amount) | 2: Additive (no reduction of impulse and not proportional to character strength)")]
        public int TorqueMode
        {
            get { return torqueMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("torqueMode", value);
                torqueMode = value;
            }
        }

        private int torqueSpinMode = 0;
        /// <summary>
        /// 0: spin direction from impulse direction | 1: random direction | 2: direction flipped with each bullet (for burst effect)
        /// </summary>
        [EuphoriaDetail("0: spin direction from impulse direction | 1: random direction | 2: direction flipped with each bullet (for burst effect)")]
        public int TorqueSpinMode
        {
            get { return torqueSpinMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("torqueSpinMode", value);
                torqueSpinMode = value;
            }
        }

        private int torqueFilterMode = 0;
        /// <summary>
        /// 0: apply torque for every bullet | 1: only apply new torque if previous has finished | 2: Only apply new torque if its spin direction is different from previous torque
        /// </summary>
        [EuphoriaDetail("0: apply torque for every bullet | 1: only apply new torque if previous has finished | 2: Only apply new torque if its spin direction is different from previous torque")]
        public int TorqueFilterMode
        {
            get { return torqueFilterMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("torqueFilterMode", value);
                torqueFilterMode = value;
            }
        }

        private bool torqueAlwaysSpine3 = true;
        /// <summary>
        /// always apply torques to spine3 instead of actual part hit
        /// </summary>
        [EuphoriaDetail("always apply torques to spine3 instead of actual part hit")]
        public bool TorqueAlwaysSpine3
        {
            get { return torqueAlwaysSpine3; }
            set
            {

                SetArgument("torqueAlwaysSpine3", value);
                torqueAlwaysSpine3 = value;
            }
        }

        private float torqueDelay = 0.00f;
        /// <summary>
        /// time from hit before torques are being applied
        /// </summary>
        [EuphoriaDetail("time from hit before torques are being applied")]
        public float TorqueDelay
        {
            get { return torqueDelay; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torqueDelay", value);
                torqueDelay = value;
            }
        }

        private float torquePeriod = 0.120f;
        /// <summary>
        /// duration of torque
        /// </summary>
        [EuphoriaDetail("duration of torque")]
        public float TorquePeriod
        {
            get { return torquePeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torquePeriod", value);
                torquePeriod = value;
            }
        }

        private float torqueGain = 4.00f;
        /// <summary>
        /// multiplies impulse magnitude to arrive at torque that is applied
        /// </summary>
        [EuphoriaDetail("multiplies impulse magnitude to arrive at torque that is applied")]
        public float TorqueGain
        {
            get { return torqueGain; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("torqueGain", value);
                torqueGain = value;
            }
        }

        private float torqueCutoff = 0.00f;
        /// <summary>
        /// minimum ratio of impulse that remains after converting to torque (if in strength-proportional mode)
        /// </summary>
        [EuphoriaDetail("minimum ratio of impulse that remains after converting to torque (if in strength-proportional mode)")]
        public float TorqueCutoff
        {
            get { return torqueCutoff; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torqueCutoff", value);
                torqueCutoff = value;
            }
        }

        private float torqueReductionPerTick = 0.00f;
        /// <summary>
        /// ratio of torque for next tick (e.g. 1.0: not reducing over time, 0.9: each tick torque is reduced by 10%)
        /// </summary>
        [EuphoriaDetail("ratio of torque for next tick (e.g. 1.0: not reducing over time, 0.9: each tick torque is reduced by 10%)")]
        public float TorqueReductionPerTick
        {
            get { return torqueReductionPerTick; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torqueReductionPerTick", value);
                torqueReductionPerTick = value;
            }
        }

        private float liftGain = 0.00f;
        /// <summary>
        /// amount of lift (directly multiplies torque axis to give lift force)
        /// </summary>
        [EuphoriaDetail("amount of lift (directly multiplies torque axis to give lift force)")]
        public float LiftGain
        {
            get { return liftGain; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("liftGain", value);
                liftGain = value;
            }
        }

        private float counterImpulseDelay = 0.033330f;
        /// <summary>
        /// time after impulse is applied that counter impulse is applied
        /// </summary>
        [EuphoriaDetail("time after impulse is applied that counter impulse is applied")]
        public float CounterImpulseDelay
        {
            get { return counterImpulseDelay; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("counterImpulseDelay", value);
                counterImpulseDelay = value;
            }
        }

        private float counterImpulseMag = 0.50f;
        /// <summary>
        /// amount of the original impulse that is countered
        /// </summary>
        [EuphoriaDetail("amount of the original impulse that is countered")]
        public float CounterImpulseMag
        {
            get { return counterImpulseMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("counterImpulseMag", value);
                counterImpulseMag = value;
            }
        }

        private bool counterAfterMagReached = false;
        /// <summary>
        /// applies the counter impulse counterImpulseDelay(secs) after counterImpulseMag of the Impulse has been applied
        /// </summary>
        [EuphoriaDetail("applies the counter impulse counterImpulseDelay(secs) after counterImpulseMag of the Impulse has been applied")]
        public bool CounterAfterMagReached
        {
            get { return counterAfterMagReached; }
            set
            {

                SetArgument("counterAfterMagReached", value);
                counterAfterMagReached = value;
            }
        }

        private bool doCounterImpulse = false;
        /// <summary>
        /// add a counter impulse to the pelvis
        /// </summary>
        [EuphoriaDetail("add a counter impulse to the pelvis")]
        public bool DoCounterImpulse
        {
            get { return doCounterImpulse; }
            set
            {

                SetArgument("doCounterImpulse", value);
                doCounterImpulse = value;
            }
        }

        private float counterImpulse2Hips = 1.00f;
        /// <summary>
        /// amount of the counter impulse applied to hips - the rest is applied to the part originally hit
        /// </summary>
        [EuphoriaDetail("amount of the counter impulse applied to hips - the rest is applied to the part originally hit")]
        public float CounterImpulse2Hips
        {
            get { return counterImpulse2Hips; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("counterImpulse2Hips", value);
                counterImpulse2Hips = value;
            }
        }

        private float impulseNoBalMult = 1.00f;
        /// <summary>
        /// amount to scale impulse by if the dynamicBalance is not OK.  1.0 means this functionality is not applied.
        /// </summary>
        [EuphoriaDetail("amount to scale impulse by if the dynamicBalance is not OK.  1.0 means this functionality is not applied.")]
        public float ImpulseNoBalMult
        {
            get { return impulseNoBalMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseNoBalMult", value);
                impulseNoBalMult = value;
            }
        }

        private float impulseBalStabStart = 3.00f;
        /// <summary>
        /// 100% LE Start to impulseBalStabMult*100% GT End. NB: Start LT End
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseBalStabMult*100% GT End. NB: Start LT End")]
        public float ImpulseBalStabStart
        {
            get { return impulseBalStabStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("impulseBalStabStart", value);
                impulseBalStabStart = value;
            }
        }

        private float impulseBalStabEnd = 10.00f;
        /// <summary>
        /// 100% LE Start to impulseBalStabMult*100% GT End. NB: Start LT End
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseBalStabMult*100% GT End. NB: Start LT End")]
        public float ImpulseBalStabEnd
        {
            get { return impulseBalStabEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("impulseBalStabEnd", value);
                impulseBalStabEnd = value;
            }
        }

        private float impulseBalStabMult = 1.00f;
        /// <summary>
        /// 100% LE Start to impulseBalStabMult*100% GT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseBalStabMult*100% GT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.")]
        public float ImpulseBalStabMult
        {
            get { return impulseBalStabMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseBalStabMult", value);
                impulseBalStabMult = value;
            }
        }

        private float impulseSpineAngStart = 0.70f;
        /// <summary>
        /// 100% GE Start to impulseSpineAngMult*100% LT End. NB: Start GT End.  This the dot of hip2Head with up.
        /// </summary>
        [EuphoriaDetail("100% GE Start to impulseSpineAngMult*100% LT End. NB: Start GT End.  This the dot of hip2Head with up.")]
        public float ImpulseSpineAngStart
        {
            get { return impulseSpineAngStart; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("impulseSpineAngStart", value);
                impulseSpineAngStart = value;
            }
        }

        private float impulseSpineAngEnd = 0.20f;
        /// <summary>
        /// 100% GE Start to impulseSpineAngMult*100% LT End. NB: Start GT End.  This the dot of hip2Head with up.
        /// </summary>
        [EuphoriaDetail("100% GE Start to impulseSpineAngMult*100% LT End. NB: Start GT End.  This the dot of hip2Head with up.")]
        public float ImpulseSpineAngEnd
        {
            get { return impulseSpineAngEnd; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("impulseSpineAngEnd", value);
                impulseSpineAngEnd = value;
            }
        }

        private float impulseSpineAngMult = 1.00f;
        /// <summary>
        /// 100% GE Start to impulseSpineAngMult*100% LT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.
        /// </summary>
        [EuphoriaDetail("100% GE Start to impulseSpineAngMult*100% LT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.")]
        public float ImpulseSpineAngMult
        {
            get { return impulseSpineAngMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseSpineAngMult", value);
                impulseSpineAngMult = value;
            }
        }

        private float impulseVelStart = 1.00f;
        /// <summary>
        /// 100% LE Start to impulseVelMult*100% GT End. NB: Start LT End
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseVelMult*100% GT End. NB: Start LT End")]
        public float ImpulseVelStart
        {
            get { return impulseVelStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("impulseVelStart", value);
                impulseVelStart = value;
            }
        }

        private float impulseVelEnd = 4.00f;
        /// <summary>
        /// 100% LE Start to impulseVelMult*100% GT End. NB: Start LT End
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseVelMult*100% GT End. NB: Start LT End")]
        public float ImpulseVelEnd
        {
            get { return impulseVelEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("impulseVelEnd", value);
                impulseVelEnd = value;
            }
        }

        private float impulseVelMult = 1.00f;
        /// <summary>
        /// 100% LE Start to impulseVelMult*100% GT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseVelMult*100% GT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.")]
        public float ImpulseVelMult
        {
            get { return impulseVelMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseVelMult", value);
                impulseVelMult = value;
            }
        }

        private float impulseAirMult = 1.00f;
        /// <summary>
        /// amount to scale impulse by if the character is airborne and dynamicBalance is OK and impulse is above impulseAirMultStart
        /// </summary>
        [EuphoriaDetail("amount to scale impulse by if the character is airborne and dynamicBalance is OK and impulse is above impulseAirMultStart")]
        public float ImpulseAirMult
        {
            get { return impulseAirMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseAirMult", value);
                impulseAirMult = value;
            }
        }

        private float impulseAirMultStart = 100.0f;
        /// <summary>
        /// if impulse is above this value scale it by impulseAirMult
        /// </summary>
        [EuphoriaDetail("if impulse is above this value scale it by impulseAirMult")]
        public float ImpulseAirMultStart
        {
            get { return impulseAirMultStart; }
            set
            {

                SetArgument("impulseAirMultStart", value);
                impulseAirMultStart = value;
            }
        }

        private float impulseAirMax = 100.0f;
        /// <summary>
        /// amount to clamp impulse to if character is airborne  and dynamicBalance is OK
        /// </summary>
        [EuphoriaDetail("amount to clamp impulse to if character is airborne  and dynamicBalance is OK")]
        public float ImpulseAirMax
        {
            get { return impulseAirMax; }
            set
            {

                SetArgument("impulseAirMax", value);
                impulseAirMax = value;
            }
        }

        private float impulseAirApplyAbove = 399.0f;
        /// <summary>
        /// if impulse is above this amount then do not scale/clamp just let it through as is - it's a shotgun or cannon
        /// </summary>
        [EuphoriaDetail("if impulse is above this amount then do not scale/clamp just let it through as is - it's a shotgun or cannon")]
        public float ImpulseAirApplyAbove
        {
            get { return impulseAirApplyAbove; }
            set
            {

                SetArgument("impulseAirApplyAbove", value);
                impulseAirApplyAbove = value;
            }
        }

        private bool impulseAirOn = false;
        /// <summary>
        /// scale and/or clamp impulse if the character is airborne and dynamicBalance is OK
        /// </summary>
        [EuphoriaDetail("scale and/or clamp impulse if the character is airborne and dynamicBalance is OK")]
        public bool ImpulseAirOn
        {
            get { return impulseAirOn; }
            set
            {

                SetArgument("impulseAirOn", value);
                impulseAirOn = value;
            }
        }

        private float impulseOneLegMult = 1.00f;
        /// <summary>
        /// amount to scale impulse by if the character is contacting with one foot only and dynamicBalance is OK and impulse is above impulseAirMultStart
        /// </summary>
        [EuphoriaDetail("amount to scale impulse by if the character is contacting with one foot only and dynamicBalance is OK and impulse is above impulseAirMultStart")]
        public float ImpulseOneLegMult
        {
            get { return impulseOneLegMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseOneLegMult", value);
                impulseOneLegMult = value;
            }
        }

        private float impulseOneLegMultStart = 100.0f;
        /// <summary>
        /// if impulse is above this value scale it by impulseOneLegMult
        /// </summary>
        [EuphoriaDetail("if impulse is above this value scale it by impulseOneLegMult")]
        public float ImpulseOneLegMultStart
        {
            get { return impulseOneLegMultStart; }
            set
            {

                SetArgument("impulseOneLegMultStart", value);
                impulseOneLegMultStart = value;
            }
        }

        private float impulseOneLegMax = 100.0f;
        /// <summary>
        /// amount to clamp impulse to if character is contacting with one foot only  and dynamicBalance is OK
        /// </summary>
        [EuphoriaDetail("amount to clamp impulse to if character is contacting with one foot only  and dynamicBalance is OK")]
        public float ImpulseOneLegMax
        {
            get { return impulseOneLegMax; }
            set
            {

                SetArgument("impulseOneLegMax", value);
                impulseOneLegMax = value;
            }
        }

        private float impulseOneLegApplyAbove = 399.0f;
        /// <summary>
        /// if impulse is above this amount then do not scale/clamp just let it through as is - it's a shotgun or cannon
        /// </summary>
        [EuphoriaDetail("if impulse is above this amount then do not scale/clamp just let it through as is - it's a shotgun or cannon")]
        public float ImpulseOneLegApplyAbove
        {
            get { return impulseOneLegApplyAbove; }
            set
            {

                SetArgument("impulseOneLegApplyAbove", value);
                impulseOneLegApplyAbove = value;
            }
        }

        private bool impulseOneLegOn = false;
        /// <summary>
        /// scale and/or clamp impulse if the character is contacting with one leg only and dynamicBalance is OK
        /// </summary>
        [EuphoriaDetail("scale and/or clamp impulse if the character is contacting with one leg only and dynamicBalance is OK")]
        public bool ImpulseOneLegOn
        {
            get { return impulseOneLegOn; }
            set
            {

                SetArgument("impulseOneLegOn", value);
                impulseOneLegOn = value;
            }
        }

        private float rbRatio = 0.000f;
        /// <summary>
        /// 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody
        /// </summary>
        [EuphoriaDetail("0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody")]
        public float RbRatio
        {
            get { return rbRatio; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbRatio", value);
                rbRatio = value;
            }
        }

        private float rbLowerShare = 0.50f;
        /// <summary>
        /// rigid body response is shared between the upper and lower body (rbUpperShare = 1-rbLowerShare). rbLowerShare=0.5 gives upper and lower share scaled by mass.  i.e. if 70% ub mass and 30% lower mass then rbLowerShare=0.5 gives actualrbShare of 0.7ub and 0.3lb. rbLowerShare GT 0.5 scales the ub share down from 0.7 and the lb up from 0.3.
        /// </summary>
        [EuphoriaDetail("rigid body response is shared between the upper and lower body (rbUpperShare = 1-rbLowerShare). rbLowerShare=0.5 gives upper and lower share scaled by mass.  i.e. if 70% ub mass and 30% lower mass then rbLowerShare=0.5 gives actualrbShare of 0.7ub and 0.3lb. rbLowerShare GT 0.5 scales the ub share down from 0.7 and the lb up from 0.3.")]
        public float RbLowerShare
        {
            get { return rbLowerShare; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbLowerShare", value);
                rbLowerShare = value;
            }
        }

        private float rbMoment = 1.000f;
        /// <summary>
        /// 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment
        /// </summary>
        [EuphoriaDetail("0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment")]
        public float RbMoment
        {
            get { return rbMoment; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbMoment", value);
                rbMoment = value;
            }
        }

        private float rbMaxTwistMomentArm = 0.50f;
        /// <summary>
        /// Maximum twist arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("Maximum twist arm moment of bullet applied")]
        public float RbMaxTwistMomentArm
        {
            get { return rbMaxTwistMomentArm; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxTwistMomentArm", value);
                rbMaxTwistMomentArm = value;
            }
        }

        private float rbMaxBroomMomentArm = 1.00f;
        /// <summary>
        /// Maximum broom((everything but the twist) arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("Maximum broom((everything but the twist) arm moment of bullet applied")]
        public float RbMaxBroomMomentArm
        {
            get { return rbMaxBroomMomentArm; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxBroomMomentArm", value);
                rbMaxBroomMomentArm = value;
            }
        }

        private float rbRatioAirborne = 0.000f;
        /// <summary>
        /// if Airborne: 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody
        /// </summary>
        [EuphoriaDetail("if Airborne: 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody")]
        public float RbRatioAirborne
        {
            get { return rbRatioAirborne; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbRatioAirborne", value);
                rbRatioAirborne = value;
            }
        }

        private float rbMomentAirborne = 1.000f;
        /// <summary>
        /// if Airborne: 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment
        /// </summary>
        [EuphoriaDetail("if Airborne: 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment")]
        public float RbMomentAirborne
        {
            get { return rbMomentAirborne; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbMomentAirborne", value);
                rbMomentAirborne = value;
            }
        }

        private float rbMaxTwistMomentArmAirborne = 0.50f;
        /// <summary>
        /// if Airborne: Maximum twist arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("if Airborne: Maximum twist arm moment of bullet applied")]
        public float RbMaxTwistMomentArmAirborne
        {
            get { return rbMaxTwistMomentArmAirborne; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxTwistMomentArmAirborne", value);
                rbMaxTwistMomentArmAirborne = value;
            }
        }

        private float rbMaxBroomMomentArmAirborne = 1.00f;
        /// <summary>
        /// if Airborne: Maximum broom((everything but the twist) arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("if Airborne: Maximum broom((everything but the twist) arm moment of bullet applied")]
        public float RbMaxBroomMomentArmAirborne
        {
            get { return rbMaxBroomMomentArmAirborne; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxBroomMomentArmAirborne", value);
                rbMaxBroomMomentArmAirborne = value;
            }
        }

        private float rbRatioOneLeg = 0.000f;
        /// <summary>
        /// if only one leg in contact: 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody
        /// </summary>
        [EuphoriaDetail("if only one leg in contact: 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody")]
        public float RbRatioOneLeg
        {
            get { return rbRatioOneLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbRatioOneLeg", value);
                rbRatioOneLeg = value;
            }
        }

        private float rbMomentOneLeg = 1.000f;
        /// <summary>
        /// if only one leg in contact: 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment
        /// </summary>
        [EuphoriaDetail("if only one leg in contact: 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment")]
        public float RbMomentOneLeg
        {
            get { return rbMomentOneLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbMomentOneLeg", value);
                rbMomentOneLeg = value;
            }
        }

        private float rbMaxTwistMomentArmOneLeg = 0.50f;
        /// <summary>
        /// if only one leg in contact: Maximum twist arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("if only one leg in contact: Maximum twist arm moment of bullet applied")]
        public float RbMaxTwistMomentArmOneLeg
        {
            get { return rbMaxTwistMomentArmOneLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxTwistMomentArmOneLeg", value);
                rbMaxTwistMomentArmOneLeg = value;
            }
        }

        private float rbMaxBroomMomentArmOneLeg = 1.00f;
        /// <summary>
        /// if only one leg in contact: Maximum broom((everything but the twist) arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("if only one leg in contact: Maximum broom((everything but the twist) arm moment of bullet applied")]
        public float RbMaxBroomMomentArmOneLeg
        {
            get { return rbMaxBroomMomentArmOneLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxBroomMomentArmOneLeg", value);
                rbMaxBroomMomentArmOneLeg = value;
            }
        }

        private int rbTwistAxis = 0;
        /// <summary>
        /// Twist axis 0=World Up, 1=CharacterCOM up
        /// </summary>
        [EuphoriaDetail("Twist axis 0=World Up, 1=CharacterCOM up")]
        public int RbTwistAxis
        {
            get { return rbTwistAxis; }
            set
            {
                value = MathHelper.Clamp(value, 0, 1);
                SetArgument("rbTwistAxis", value);
                rbTwistAxis = value;
            }
        }

        private bool rbPivot = false;
        /// <summary>
        /// if false pivot around COM always, if true change pivot depending on foot contact:  to feet centre if both feet in contact, or foot position if 1 foot in contact or COM position if no feet in contact
        /// </summary>
        [EuphoriaDetail("if false pivot around COM always, if true change pivot depending on foot contact:  to feet centre if both feet in contact, or foot position if 1 foot in contact or COM position if no feet in contact")]
        public bool RbPivot
        {
            get { return rbPivot; }
            set
            {

                SetArgument("rbPivot", value);
                rbPivot = value;
            }
        }


        public EuphoriaMessageConfigureBullets(bool startNow) : base("configureBullets", startNow)
        { }

        public new void Reset()
        {
            impulseSpreadOverParts = false;
            impulseLeakageStrengthScaled = false;
            impulsePeriod = 0.10f;
            impulseTorqueScale = 1.00f;
            loosenessFix = false;
            impulseDelay = 0.00f;
            impulseReductionPerShot = 0.00f;
            impulseRecovery = 0.00f;
            impulseMinLeakage = 0.20f;
            torqueMode = 0;
            torqueSpinMode = 0;
            torqueFilterMode = 0;
            torqueAlwaysSpine3 = true;
            torqueDelay = 0.00f;
            torquePeriod = 0.120f;
            torqueGain = 4.00f;
            torqueCutoff = 0.00f;
            torqueReductionPerTick = 0.00f;
            liftGain = 0.00f;
            counterImpulseDelay = 0.033330f;
            counterImpulseMag = 0.50f;
            counterAfterMagReached = false;
            doCounterImpulse = false;
            counterImpulse2Hips = 1.00f;
            impulseNoBalMult = 1.00f;
            impulseBalStabStart = 3.00f;
            impulseBalStabEnd = 10.00f;
            impulseBalStabMult = 1.00f;
            impulseSpineAngStart = 0.70f;
            impulseSpineAngEnd = 0.20f;
            impulseSpineAngMult = 1.00f;
            impulseVelStart = 1.00f;
            impulseVelEnd = 4.00f;
            impulseVelMult = 1.00f;
            impulseAirMult = 1.00f;
            impulseAirMultStart = 100.0f;
            impulseAirMax = 100.0f;
            impulseAirApplyAbove = 399.0f;
            impulseAirOn = false;
            impulseOneLegMult = 1.00f;
            impulseOneLegMultStart = 100.0f;
            impulseOneLegMax = 100.0f;
            impulseOneLegApplyAbove = 399.0f;
            impulseOneLegOn = false;
            rbRatio = 0.000f;
            rbLowerShare = 0.50f;
            rbMoment = 1.000f;
            rbMaxTwistMomentArm = 0.50f;
            rbMaxBroomMomentArm = 1.00f;
            rbRatioAirborne = 0.000f;
            rbMomentAirborne = 1.000f;
            rbMaxTwistMomentArmAirborne = 0.50f;
            rbMaxBroomMomentArmAirborne = 1.00f;
            rbRatioOneLeg = 0.000f;
            rbMomentOneLeg = 1.000f;
            rbMaxTwistMomentArmOneLeg = 0.50f;
            rbMaxBroomMomentArmOneLeg = 1.00f;
            rbTwistAxis = 0;
            rbPivot = false;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageConfigureBulletsExtra : EuphoriaMessage
    {
        private bool impulseSpreadOverParts = false;
        /// <summary>
        /// spreads impulse across parts. currently only for spine parts, not limbs.
        /// </summary>
        [EuphoriaDetail("spreads impulse across parts. currently only for spine parts, not limbs.")]
        public bool ImpulseSpreadOverParts
        {
            get { return impulseSpreadOverParts; }
            set
            {

                SetArgument("impulseSpreadOverParts", value);
                impulseSpreadOverParts = value;
            }
        }

        private float impulsePeriod = 0.10f;
        /// <summary>
        /// duration that impulse is spread over (triangular shaped)
        /// </summary>
        [EuphoriaDetail("duration that impulse is spread over (triangular shaped)")]
        public float ImpulsePeriod
        {
            get { return impulsePeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulsePeriod", value);
                impulsePeriod = value;
            }
        }

        private float impulseTorqueScale = 1.00f;
        /// <summary>
        /// An impulse applied at a point on a body equivalent to an impulse at the centre of the body and a torque.  This parameter scales the torque component. (The torque component seems to be excite the rage looseness bug which sends the character in a sometimes wildly different direction to an applied impulse)
        /// </summary>
        [EuphoriaDetail("An impulse applied at a point on a body equivalent to an impulse at the centre of the body and a torque.  This parameter scales the torque component. (The torque component seems to be excite the rage looseness bug which sends the character in a sometimes wildly different direction to an applied impulse)")]
        public float ImpulseTorqueScale
        {
            get { return impulseTorqueScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseTorqueScale", value);
                impulseTorqueScale = value;
            }
        }

        private bool loosenessFix = false;
        /// <summary>
        /// Fix the rage looseness bug by applying only the impulse at the centre of the body unless it is a spine part then apply the twist component only of the torque as well.
        /// </summary>
        [EuphoriaDetail("Fix the rage looseness bug by applying only the impulse at the centre of the body unless it is a spine part then apply the twist component only of the torque as well.")]
        public bool LoosenessFix
        {
            get { return loosenessFix; }
            set
            {

                SetArgument("loosenessFix", value);
                loosenessFix = value;
            }
        }

        private float impulseDelay = 0.00f;
        /// <summary>
        /// time from hit before impulses are being applied
        /// </summary>
        [EuphoriaDetail("time from hit before impulses are being applied")]
        public float ImpulseDelay
        {
            get { return impulseDelay; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseDelay", value);
                impulseDelay = value;
            }
        }

        private int torqueMode = 0;
        /// <summary>
        /// 0: Disabled | 1: character strength proportional (can reduce impulse amount) | 2: Additive (no reduction of impulse and not proportional to character strength)
        /// </summary>
        [EuphoriaDetail("0: Disabled | 1: character strength proportional (can reduce impulse amount) | 2: Additive (no reduction of impulse and not proportional to character strength)")]
        public int TorqueMode
        {
            get { return torqueMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("torqueMode", value);
                torqueMode = value;
            }
        }

        private int torqueSpinMode = 0;
        /// <summary>
        /// 0: spin direction from impulse direction | 1: random direction | 2: direction flipped with each bullet (for burst effect)
        /// </summary>
        [EuphoriaDetail("0: spin direction from impulse direction | 1: random direction | 2: direction flipped with each bullet (for burst effect)")]
        public int TorqueSpinMode
        {
            get { return torqueSpinMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("torqueSpinMode", value);
                torqueSpinMode = value;
            }
        }

        private int torqueFilterMode = 0;
        /// <summary>
        /// 0: apply torque for every bullet | 1: only apply new torque if previous has finished | 2: Only apply new torque if its spin direction is different from previous torque
        /// </summary>
        [EuphoriaDetail("0: apply torque for every bullet | 1: only apply new torque if previous has finished | 2: Only apply new torque if its spin direction is different from previous torque")]
        public int TorqueFilterMode
        {
            get { return torqueFilterMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("torqueFilterMode", value);
                torqueFilterMode = value;
            }
        }

        private bool torqueAlwaysSpine3 = true;
        /// <summary>
        /// always apply torques to spine3 instead of actual part hit
        /// </summary>
        [EuphoriaDetail("always apply torques to spine3 instead of actual part hit")]
        public bool TorqueAlwaysSpine3
        {
            get { return torqueAlwaysSpine3; }
            set
            {

                SetArgument("torqueAlwaysSpine3", value);
                torqueAlwaysSpine3 = value;
            }
        }

        private float torqueDelay = 0.00f;
        /// <summary>
        /// time from hit before torques are being applied
        /// </summary>
        [EuphoriaDetail("time from hit before torques are being applied")]
        public float TorqueDelay
        {
            get { return torqueDelay; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torqueDelay", value);
                torqueDelay = value;
            }
        }

        private float torquePeriod = 0.120f;
        /// <summary>
        /// duration of torque
        /// </summary>
        [EuphoriaDetail("duration of torque")]
        public float TorquePeriod
        {
            get { return torquePeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torquePeriod", value);
                torquePeriod = value;
            }
        }

        private float torqueGain = 4.00f;
        /// <summary>
        /// multiplies impulse magnitude to arrive at torque that is applied
        /// </summary>
        [EuphoriaDetail("multiplies impulse magnitude to arrive at torque that is applied")]
        public float TorqueGain
        {
            get { return torqueGain; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("torqueGain", value);
                torqueGain = value;
            }
        }

        private float torqueCutoff = 0.00f;
        /// <summary>
        /// minimum ratio of impulse that remains after converting to torque (if in strength-proportional mode)
        /// </summary>
        [EuphoriaDetail("minimum ratio of impulse that remains after converting to torque (if in strength-proportional mode)")]
        public float TorqueCutoff
        {
            get { return torqueCutoff; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torqueCutoff", value);
                torqueCutoff = value;
            }
        }

        private float torqueReductionPerTick = 0.00f;
        /// <summary>
        /// ratio of torque for next tick (e.g. 1.0: not reducing over time, 0.9: each tick torque is reduced by 10%)
        /// </summary>
        [EuphoriaDetail("ratio of torque for next tick (e.g. 1.0: not reducing over time, 0.9: each tick torque is reduced by 10%)")]
        public float TorqueReductionPerTick
        {
            get { return torqueReductionPerTick; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("torqueReductionPerTick", value);
                torqueReductionPerTick = value;
            }
        }

        private float liftGain = 0.00f;
        /// <summary>
        /// amount of lift (directly multiplies torque axis to give lift force)
        /// </summary>
        [EuphoriaDetail("amount of lift (directly multiplies torque axis to give lift force)")]
        public float LiftGain
        {
            get { return liftGain; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("liftGain", value);
                liftGain = value;
            }
        }

        private float counterImpulseDelay = 0.033330f;
        /// <summary>
        /// time after impulse is applied that counter impulse is applied
        /// </summary>
        [EuphoriaDetail("time after impulse is applied that counter impulse is applied")]
        public float CounterImpulseDelay
        {
            get { return counterImpulseDelay; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("counterImpulseDelay", value);
                counterImpulseDelay = value;
            }
        }

        private float counterImpulseMag = 0.50f;
        /// <summary>
        /// amount of the original impulse that is countered
        /// </summary>
        [EuphoriaDetail("amount of the original impulse that is countered")]
        public float CounterImpulseMag
        {
            get { return counterImpulseMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("counterImpulseMag", value);
                counterImpulseMag = value;
            }
        }

        private bool counterAfterMagReached = false;
        /// <summary>
        /// applies the counter impulse counterImpulseDelay(secs) after counterImpulseMag of the Impulse has been applied
        /// </summary>
        [EuphoriaDetail("applies the counter impulse counterImpulseDelay(secs) after counterImpulseMag of the Impulse has been applied")]
        public bool CounterAfterMagReached
        {
            get { return counterAfterMagReached; }
            set
            {

                SetArgument("counterAfterMagReached", value);
                counterAfterMagReached = value;
            }
        }

        private bool doCounterImpulse = false;
        /// <summary>
        /// add a counter impulse to the pelvis
        /// </summary>
        [EuphoriaDetail("add a counter impulse to the pelvis")]
        public bool DoCounterImpulse
        {
            get { return doCounterImpulse; }
            set
            {

                SetArgument("doCounterImpulse", value);
                doCounterImpulse = value;
            }
        }

        private float counterImpulse2Hips = 1.00f;
        /// <summary>
        /// amount of the counter impulse applied to hips - the rest is applied to the part originally hit
        /// </summary>
        [EuphoriaDetail("amount of the counter impulse applied to hips - the rest is applied to the part originally hit")]
        public float CounterImpulse2Hips
        {
            get { return counterImpulse2Hips; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("counterImpulse2Hips", value);
                counterImpulse2Hips = value;
            }
        }

        private float impulseNoBalMult = 1.00f;
        /// <summary>
        /// amount to scale impulse by if the dynamicBalance is not OK.  1.0 means this functionality is not applied.
        /// </summary>
        [EuphoriaDetail("amount to scale impulse by if the dynamicBalance is not OK.  1.0 means this functionality is not applied.")]
        public float ImpulseNoBalMult
        {
            get { return impulseNoBalMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseNoBalMult", value);
                impulseNoBalMult = value;
            }
        }

        private float impulseBalStabStart = 3.00f;
        /// <summary>
        /// 100% LE Start to impulseBalStabMult*100% GT End. NB: Start LT End
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseBalStabMult*100% GT End. NB: Start LT End")]
        public float ImpulseBalStabStart
        {
            get { return impulseBalStabStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("impulseBalStabStart", value);
                impulseBalStabStart = value;
            }
        }

        private float impulseBalStabEnd = 10.00f;
        /// <summary>
        /// 100% LE Start to impulseBalStabMult*100% GT End. NB: Start LT End
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseBalStabMult*100% GT End. NB: Start LT End")]
        public float ImpulseBalStabEnd
        {
            get { return impulseBalStabEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("impulseBalStabEnd", value);
                impulseBalStabEnd = value;
            }
        }

        private float impulseBalStabMult = 1.00f;
        /// <summary>
        /// 100% LE Start to impulseBalStabMult*100% GT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseBalStabMult*100% GT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.")]
        public float ImpulseBalStabMult
        {
            get { return impulseBalStabMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseBalStabMult", value);
                impulseBalStabMult = value;
            }
        }

        private float impulseSpineAngStart = 0.70f;
        /// <summary>
        /// 100% GE Start to impulseSpineAngMult*100% LT End. NB: Start GT End.  This the dot of hip2Head with up.
        /// </summary>
        [EuphoriaDetail("100% GE Start to impulseSpineAngMult*100% LT End. NB: Start GT End.  This the dot of hip2Head with up.")]
        public float ImpulseSpineAngStart
        {
            get { return impulseSpineAngStart; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("impulseSpineAngStart", value);
                impulseSpineAngStart = value;
            }
        }

        private float impulseSpineAngEnd = 0.20f;
        /// <summary>
        /// 100% GE Start to impulseSpineAngMult*100% LT End. NB: Start GT End.  This the dot of hip2Head with up.
        /// </summary>
        [EuphoriaDetail("100% GE Start to impulseSpineAngMult*100% LT End. NB: Start GT End.  This the dot of hip2Head with up.")]
        public float ImpulseSpineAngEnd
        {
            get { return impulseSpineAngEnd; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("impulseSpineAngEnd", value);
                impulseSpineAngEnd = value;
            }
        }

        private float impulseSpineAngMult = 1.00f;
        /// <summary>
        /// 100% GE Start to impulseSpineAngMult*100% LT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.
        /// </summary>
        [EuphoriaDetail("100% GE Start to impulseSpineAngMult*100% LT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.")]
        public float ImpulseSpineAngMult
        {
            get { return impulseSpineAngMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseSpineAngMult", value);
                impulseSpineAngMult = value;
            }
        }

        private float impulseVelStart = 4.00f;
        /// <summary>
        /// 100% LE Start to impulseVelMult*100% GT End. NB: Start LT End
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseVelMult*100% GT End. NB: Start LT End")]
        public float ImpulseVelStart
        {
            get { return impulseVelStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("impulseVelStart", value);
                impulseVelStart = value;
            }
        }

        private float impulseVelEnd = 4.00f;
        /// <summary>
        /// 100% LE Start to impulseVelMult*100% GT End. NB: Start LT End
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseVelMult*100% GT End. NB: Start LT End")]
        public float ImpulseVelEnd
        {
            get { return impulseVelEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("impulseVelEnd", value);
                impulseVelEnd = value;
            }
        }

        private float impulseVelMult = 1.00f;
        /// <summary>
        /// 100% LE Start to impulseVelMult*100% GT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.
        /// </summary>
        [EuphoriaDetail("100% LE Start to impulseVelMult*100% GT End. NB: leaving this as 1.0 means this functionality is not applied and Start and End have no effect.")]
        public float ImpulseVelMult
        {
            get { return impulseVelMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseVelMult", value);
                impulseVelMult = value;
            }
        }

        private float impulseAirMult = 1.00f;
        /// <summary>
        /// amount to scale impulse by if the character is airborne and dynamicBalance is OK and impulse is above impulseAirMultStart
        /// </summary>
        [EuphoriaDetail("amount to scale impulse by if the character is airborne and dynamicBalance is OK and impulse is above impulseAirMultStart")]
        public float ImpulseAirMult
        {
            get { return impulseAirMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseAirMult", value);
                impulseAirMult = value;
            }
        }

        private float impulseAirMultStart = 100.0f;
        /// <summary>
        /// if impulse is above this value scale it by impulseAirMult
        /// </summary>
        [EuphoriaDetail("if impulse is above this value scale it by impulseAirMult")]
        public float ImpulseAirMultStart
        {
            get { return impulseAirMultStart; }
            set
            {

                SetArgument("impulseAirMultStart", value);
                impulseAirMultStart = value;
            }
        }

        private float impulseAirMax = 100.0f;
        /// <summary>
        /// amount to clamp impulse to if character is airborne  and dynamicBalance is OK
        /// </summary>
        [EuphoriaDetail("amount to clamp impulse to if character is airborne  and dynamicBalance is OK")]
        public float ImpulseAirMax
        {
            get { return impulseAirMax; }
            set
            {

                SetArgument("impulseAirMax", value);
                impulseAirMax = value;
            }
        }

        private float impulseAirApplyAbove = 399.0f;
        /// <summary>
        /// if impulse is above this amount then do not scale/clamp just let it through as is - it's a shotgun or cannon
        /// </summary>
        [EuphoriaDetail("if impulse is above this amount then do not scale/clamp just let it through as is - it's a shotgun or cannon")]
        public float ImpulseAirApplyAbove
        {
            get { return impulseAirApplyAbove; }
            set
            {

                SetArgument("impulseAirApplyAbove", value);
                impulseAirApplyAbove = value;
            }
        }

        private bool impulseAirOn = false;
        /// <summary>
        /// scale and/or clamp impulse if the character is airborne and dynamicBalance is OK
        /// </summary>
        [EuphoriaDetail("scale and/or clamp impulse if the character is airborne and dynamicBalance is OK")]
        public bool ImpulseAirOn
        {
            get { return impulseAirOn; }
            set
            {

                SetArgument("impulseAirOn", value);
                impulseAirOn = value;
            }
        }

        private float impulseOneLegMult = 1.00f;
        /// <summary>
        /// amount to scale impulse by if the character is contacting with one foot only and dynamicBalance is OK and impulse is above impulseAirMultStart
        /// </summary>
        [EuphoriaDetail("amount to scale impulse by if the character is contacting with one foot only and dynamicBalance is OK and impulse is above impulseAirMultStart")]
        public float ImpulseOneLegMult
        {
            get { return impulseOneLegMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impulseOneLegMult", value);
                impulseOneLegMult = value;
            }
        }

        private float impulseOneLegMultStart = 100.0f;
        /// <summary>
        /// if impulse is above this value scale it by impulseOneLegMult
        /// </summary>
        [EuphoriaDetail("if impulse is above this value scale it by impulseOneLegMult")]
        public float ImpulseOneLegMultStart
        {
            get { return impulseOneLegMultStart; }
            set
            {

                SetArgument("impulseOneLegMultStart", value);
                impulseOneLegMultStart = value;
            }
        }

        private float impulseOneLegMax = 100.0f;
        /// <summary>
        /// amount to clamp impulse to if character is contacting with one foot only  and dynamicBalance is OK
        /// </summary>
        [EuphoriaDetail("amount to clamp impulse to if character is contacting with one foot only  and dynamicBalance is OK")]
        public float ImpulseOneLegMax
        {
            get { return impulseOneLegMax; }
            set
            {

                SetArgument("impulseOneLegMax", value);
                impulseOneLegMax = value;
            }
        }

        private float impulseOneLegApplyAbove = 399.0f;
        /// <summary>
        /// if impulse is above this amount then do not scale/clamp just let it through as is - it's a shotgun or cannon
        /// </summary>
        [EuphoriaDetail("if impulse is above this amount then do not scale/clamp just let it through as is - it's a shotgun or cannon")]
        public float ImpulseOneLegApplyAbove
        {
            get { return impulseOneLegApplyAbove; }
            set
            {

                SetArgument("impulseOneLegApplyAbove", value);
                impulseOneLegApplyAbove = value;
            }
        }

        private bool impulseOneLegOn = false;
        /// <summary>
        /// scale and/or clamp impulse if the character is contacting with one leg only and dynamicBalance is OK
        /// </summary>
        [EuphoriaDetail("scale and/or clamp impulse if the character is contacting with one leg only and dynamicBalance is OK")]
        public bool ImpulseOneLegOn
        {
            get { return impulseOneLegOn; }
            set
            {

                SetArgument("impulseOneLegOn", value);
                impulseOneLegOn = value;
            }
        }

        private float rbRatio = 0.000f;
        /// <summary>
        /// 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody
        /// </summary>
        [EuphoriaDetail("0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody")]
        public float RbRatio
        {
            get { return rbRatio; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbRatio", value);
                rbRatio = value;
            }
        }

        private float rbLowerShare = 0.50f;
        /// <summary>
        /// rigid body response is shared between the upper and lower body (rbUpperShare = 1-rbLowerShare). rbLowerShare=0.5 gives upper and lower share scaled by mass.  i.e. if 70% ub mass and 30% lower mass then rbLowerShare=0.5 gives actualrbShare of 0.7ub and 0.3lb. rbLowerShare GT 0.5 scales the ub share down from 0.7 and the lb up from 0.3.
        /// </summary>
        [EuphoriaDetail("rigid body response is shared between the upper and lower body (rbUpperShare = 1-rbLowerShare). rbLowerShare=0.5 gives upper and lower share scaled by mass.  i.e. if 70% ub mass and 30% lower mass then rbLowerShare=0.5 gives actualrbShare of 0.7ub and 0.3lb. rbLowerShare GT 0.5 scales the ub share down from 0.7 and the lb up from 0.3.")]
        public float RbLowerShare
        {
            get { return rbLowerShare; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbLowerShare", value);
                rbLowerShare = value;
            }
        }

        private float rbMoment = 1.000f;
        /// <summary>
        /// 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment
        /// </summary>
        [EuphoriaDetail("0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment")]
        public float RbMoment
        {
            get { return rbMoment; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbMoment", value);
                rbMoment = value;
            }
        }

        private float rbMaxTwistMomentArm = 0.50f;
        /// <summary>
        /// Maximum twist arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("Maximum twist arm moment of bullet applied")]
        public float RbMaxTwistMomentArm
        {
            get { return rbMaxTwistMomentArm; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxTwistMomentArm", value);
                rbMaxTwistMomentArm = value;
            }
        }

        private float rbMaxBroomMomentArm = 1.00f;
        /// <summary>
        /// Maximum broom((everything but the twist) arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("Maximum broom((everything but the twist) arm moment of bullet applied")]
        public float RbMaxBroomMomentArm
        {
            get { return rbMaxBroomMomentArm; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxBroomMomentArm", value);
                rbMaxBroomMomentArm = value;
            }
        }

        private float rbRatioAirborne = 0.000f;
        /// <summary>
        /// if Airborne: 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody
        /// </summary>
        [EuphoriaDetail("if Airborne: 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody")]
        public float RbRatioAirborne
        {
            get { return rbRatioAirborne; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbRatioAirborne", value);
                rbRatioAirborne = value;
            }
        }

        private float rbMomentAirborne = 1.000f;
        /// <summary>
        /// if Airborne: 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment
        /// </summary>
        [EuphoriaDetail("if Airborne: 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment")]
        public float RbMomentAirborne
        {
            get { return rbMomentAirborne; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbMomentAirborne", value);
                rbMomentAirborne = value;
            }
        }

        private float rbMaxTwistMomentArmAirborne = 0.50f;
        /// <summary>
        /// if Airborne: Maximum twist arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("if Airborne: Maximum twist arm moment of bullet applied")]
        public float RbMaxTwistMomentArmAirborne
        {
            get { return rbMaxTwistMomentArmAirborne; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxTwistMomentArmAirborne", value);
                rbMaxTwistMomentArmAirborne = value;
            }
        }

        private float rbMaxBroomMomentArmAirborne = 1.00f;
        /// <summary>
        /// if Airborne: Maximum broom((everything but the twist) arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("if Airborne: Maximum broom((everything but the twist) arm moment of bullet applied")]
        public float RbMaxBroomMomentArmAirborne
        {
            get { return rbMaxBroomMomentArmAirborne; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxBroomMomentArmAirborne", value);
                rbMaxBroomMomentArmAirborne = value;
            }
        }

        private float rbRatioOneLeg = 0.000f;
        /// <summary>
        /// if only one leg in contact: 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody
        /// </summary>
        [EuphoriaDetail("if only one leg in contact: 0.0 no rigidBody response, 0.5 half partForce half rigidBody, 1.0 = no partForce full rigidBody")]
        public float RbRatioOneLeg
        {
            get { return rbRatioOneLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbRatioOneLeg", value);
                rbRatioOneLeg = value;
            }
        }

        private float rbMomentOneLeg = 1.000f;
        /// <summary>
        /// if only one leg in contact: 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment
        /// </summary>
        [EuphoriaDetail("if only one leg in contact: 0.0 only force, 0.5 = force and half the rigid body moment applied, 1.0 = force and full rigidBody moment")]
        public float RbMomentOneLeg
        {
            get { return rbMomentOneLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("rbMomentOneLeg", value);
                rbMomentOneLeg = value;
            }
        }

        private float rbMaxTwistMomentArmOneLeg = 0.50f;
        /// <summary>
        /// if only one leg in contact: Maximum twist arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("if only one leg in contact: Maximum twist arm moment of bullet applied")]
        public float RbMaxTwistMomentArmOneLeg
        {
            get { return rbMaxTwistMomentArmOneLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxTwistMomentArmOneLeg", value);
                rbMaxTwistMomentArmOneLeg = value;
            }
        }

        private float rbMaxBroomMomentArmOneLeg = 1.00f;
        /// <summary>
        /// if only one leg in contact: Maximum broom((everything but the twist) arm moment of bullet applied
        /// </summary>
        [EuphoriaDetail("if only one leg in contact: Maximum broom((everything but the twist) arm moment of bullet applied")]
        public float RbMaxBroomMomentArmOneLeg
        {
            get { return rbMaxBroomMomentArmOneLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rbMaxBroomMomentArmOneLeg", value);
                rbMaxBroomMomentArmOneLeg = value;
            }
        }

        private int rbTwistAxis = 0;
        /// <summary>
        /// Twist axis 0=World Up, 1=CharacterCOM up
        /// </summary>
        [EuphoriaDetail("Twist axis 0=World Up, 1=CharacterCOM up")]
        public int RbTwistAxis
        {
            get { return rbTwistAxis; }
            set
            {
                value = MathHelper.Clamp(value, 0, 1);
                SetArgument("rbTwistAxis", value);
                rbTwistAxis = value;
            }
        }

        private bool rbPivot = false;
        /// <summary>
        /// if false pivot around COM always, if true change pivot depending on foot contact:  to feet centre if both feet in contact, or foot position if 1 foot in contact or COM position if no feet in contact
        /// </summary>
        [EuphoriaDetail("if false pivot around COM always, if true change pivot depending on foot contact:  to feet centre if both feet in contact, or foot position if 1 foot in contact or COM position if no feet in contact")]
        public bool RbPivot
        {
            get { return rbPivot; }
            set
            {

                SetArgument("rbPivot", value);
                rbPivot = value;
            }
        }


        public EuphoriaMessageConfigureBulletsExtra(bool startNow) : base("configureBulletsExtra", startNow)
        { }

        public new void Reset()
        {
            impulseSpreadOverParts = false;
            impulsePeriod = 0.10f;
            impulseTorqueScale = 1.00f;
            loosenessFix = false;
            impulseDelay = 0.00f;
            torqueMode = 0;
            torqueSpinMode = 0;
            torqueFilterMode = 0;
            torqueAlwaysSpine3 = true;
            torqueDelay = 0.00f;
            torquePeriod = 0.120f;
            torqueGain = 4.00f;
            torqueCutoff = 0.00f;
            torqueReductionPerTick = 0.00f;
            liftGain = 0.00f;
            counterImpulseDelay = 0.033330f;
            counterImpulseMag = 0.50f;
            counterAfterMagReached = false;
            doCounterImpulse = false;
            counterImpulse2Hips = 1.00f;
            impulseNoBalMult = 1.00f;
            impulseBalStabStart = 3.00f;
            impulseBalStabEnd = 10.00f;
            impulseBalStabMult = 1.00f;
            impulseSpineAngStart = 0.70f;
            impulseSpineAngEnd = 0.20f;
            impulseSpineAngMult = 1.00f;
            impulseVelStart = 4.00f;
            impulseVelEnd = 4.00f;
            impulseVelMult = 1.00f;
            impulseAirMult = 1.00f;
            impulseAirMultStart = 100.0f;
            impulseAirMax = 100.0f;
            impulseAirApplyAbove = 399.0f;
            impulseAirOn = false;
            impulseOneLegMult = 1.00f;
            impulseOneLegMultStart = 100.0f;
            impulseOneLegMax = 100.0f;
            impulseOneLegApplyAbove = 399.0f;
            impulseOneLegOn = false;
            rbRatio = 0.000f;
            rbLowerShare = 0.50f;
            rbMoment = 1.000f;
            rbMaxTwistMomentArm = 0.50f;
            rbMaxBroomMomentArm = 1.00f;
            rbRatioAirborne = 0.000f;
            rbMomentAirborne = 1.000f;
            rbMaxTwistMomentArmAirborne = 0.50f;
            rbMaxBroomMomentArmAirborne = 1.00f;
            rbRatioOneLeg = 0.000f;
            rbMomentOneLeg = 1.000f;
            rbMaxTwistMomentArmOneLeg = 0.50f;
            rbMaxBroomMomentArmOneLeg = 1.00f;
            rbTwistAxis = 0;
            rbPivot = false;
            base.Reset();
        }
    }


    /// <summary>
    /// configureLimits:  Enable/disable/edit character limits in real time.  This adjusts limits in RAGE-native space and will *not* reorient the joint.
    /// </summary>
    [EuphoriaDetail("configureLimits:  Enable/disable/edit character limits in real time.  This adjusts limits in RAGE-native space and will *not* reorient the joint.")]
    internal class EuphoriaMessageConfigureLimits : EuphoriaMessage
    {
        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  for joint limits to configure. Ignored if index != -1.
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  for joint limits to configure. Ignored if index != -1.")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }

        private bool enable = true;
        /// <summary>
        /// If false, disable (set all to PI, -PI) limits.
        /// </summary>
        [EuphoriaDetail("If false, disable (set all to PI, -PI) limits.")]
        public bool Enable
        {
            get { return enable; }
            set
            {

                SetArgument("enable", value);
                enable = value;
            }
        }

        private bool toDesired = false;
        /// <summary>
        /// If true, set limits to accommodate current desired angles
        /// </summary>
        [EuphoriaDetail("If true, set limits to accommodate current desired angles")]
        public bool ToDesired
        {
            get { return toDesired; }
            set
            {

                SetArgument("toDesired", value);
                toDesired = value;
            }
        }

        private bool restore = false;
        /// <summary>
        /// Return to cached defaults?
        /// </summary>
        [EuphoriaDetail("Return to cached defaults?")]
        public bool Restore
        {
            get { return restore; }
            set
            {

                SetArgument("restore", value);
                restore = value;
            }
        }

        private bool toCurAnimation = false;
        /// <summary>
        /// If true, set limits to the current animated limits
        /// </summary>
        [EuphoriaDetail("If true, set limits to the current animated limits")]
        public bool ToCurAnimation
        {
            get { return toCurAnimation; }
            set
            {

                SetArgument("toCurAnimation", value);
                toCurAnimation = value;
            }
        }

        private int index = -1;
        /// <summary>
        /// Index of effector to configure.  Set to -1 to use mask.
        /// </summary>
        [EuphoriaDetail("Index of effector to configure.  Set to -1 to use mask.")]
        public int Index
        {
            get { return index; }
            set
            {

                SetArgument("index", value);
                index = value;
            }
        }

        private float lean1 = 1.570796f;
        /// <summary>
        /// Custom limit values to use if not setting limits to desired. Limits are RAGE-native, not NM-wrapper-native.
        /// </summary>
        [EuphoriaDetail("Custom limit values to use if not setting limits to desired. Limits are RAGE-native, not NM-wrapper-native.")]
        public float Lean1
        {
            get { return lean1; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.141593f);
                SetArgument("lean1", value);
                lean1 = value;
            }
        }

        private float lean2 = 1.570796f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float Lean2
        {
            get { return lean2; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.141593f);
                SetArgument("lean2", value);
                lean2 = value;
            }
        }

        private float twist = 1.570796f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float Twist
        {
            get { return twist; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.141593f);
                SetArgument("twist", value);
                twist = value;
            }
        }

        private float margin = 0.196350f;
        /// <summary>
        /// Joint limit margin to add to current animation limits when using those to set runtime limits.
        /// </summary>
        [EuphoriaDetail("Joint limit margin to add to current animation limits when using those to set runtime limits.")]
        public float Margin
        {
            get { return margin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.141593f);
                SetArgument("margin", value);
                margin = value;
            }
        }


        public EuphoriaMessageConfigureLimits(bool startNow) : base("configureLimits", startNow)
        { }

        public new void Reset()
        {
            mask = "fb";
            enable = true;
            toDesired = false;
            restore = false;
            toCurAnimation = false;
            index = -1;
            lean1 = 1.570796f;
            lean2 = 1.570796f;
            twist = 1.570796f;
            margin = 0.196350f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageConfigureSoftLimit : EuphoriaMessage
    {
        private int index = 0;
        /// <summary>
        /// Select limb that the soft limit is going to be applied to
        /// </summary>
        [EuphoriaDetail("Select limb that the soft limit is going to be applied to")]
        public int Index
        {
            get { return index; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("index", value);
                index = value;
            }
        }

        private float stiffness = 15.00f;
        /// <summary>
        /// Stiffness of the soft limit. Parameter is used to calculate spring term that contributes to the desired acceleration.
        /// </summary>
        [EuphoriaDetail("Stiffness of the soft limit. Parameter is used to calculate spring term that contributes to the desired acceleration.")]
        public float Stiffness
        {
            get { return stiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 30.00f);
                SetArgument("stiffness", value);
                stiffness = value;
            }
        }

        private float damping = 1.00f;
        /// <summary>
        /// Damping of the soft limit. Parameter is used to calculate damper term that contributes to the desired acceleration. To have the system critically dampened set it to 1.0.
        /// </summary>
        [EuphoriaDetail("Damping of the soft limit. Parameter is used to calculate damper term that contributes to the desired acceleration. To have the system critically dampened set it to 1.0.")]
        public float Damping
        {
            get { return damping; }
            set
            {
                value = MathHelper.Clamp(value, 0.90f, 1.10f);
                SetArgument("damping", value);
                damping = value;
            }
        }

        private float limitAngle = 0.40f;
        /// <summary>
        /// Soft limit angle. Positive angle in RAD, measured relatively either from hard limit maxAngle (approach direction = -1) or minAngle (approach direction = 1). This angle will be clamped if outside the joint hard limit range.
        /// </summary>
        [EuphoriaDetail("Soft limit angle. Positive angle in RAD, measured relatively either from hard limit maxAngle (approach direction = -1) or minAngle (approach direction = 1). This angle will be clamped if outside the joint hard limit range.")]
        public float LimitAngle
        {
            get { return limitAngle; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 6.283185f);
                SetArgument("limitAngle", value);
                limitAngle = value;
            }
        }

        private int approachDirection = 1;
        /// <summary>
        /// Limit angle can be measured relatively to joints hard limit minAngle or maxAngle. Set approachDirection to +1 to measure soft limit angle relatively to hard limit minAngle that corresponds to the maximum stretch of the elbow. Set it to -1 to measure soft limit angle relatively to hard limit maxAngle that corresponds to the maximum stretch of the knee.
        /// </summary>
        [EuphoriaDetail("Limit angle can be measured relatively to joints hard limit minAngle or maxAngle. Set approachDirection to +1 to measure soft limit angle relatively to hard limit minAngle that corresponds to the maximum stretch of the elbow. Set it to -1 to measure soft limit angle relatively to hard limit maxAngle that corresponds to the maximum stretch of the knee.")]
        public int ApproachDirection
        {
            get { return approachDirection; }
            set
            {
                value = MathHelper.Clamp(value, -1, 1);
                SetArgument("approachDirection", value);
                approachDirection = value;
            }
        }

        private bool velocityScaled = false;
        /// <summary>
        /// Scale stiffness based on character angular velocity.
        /// </summary>
        [EuphoriaDetail("Scale stiffness based on character angular velocity.")]
        public bool VelocityScaled
        {
            get { return velocityScaled; }
            set
            {

                SetArgument("velocityScaled", value);
                velocityScaled = value;
            }
        }


        public EuphoriaMessageConfigureSoftLimit(bool startNow) : base("configureSoftLimit", startNow)
        { }

        public new void Reset()
        {
            index = 0;
            stiffness = 15.00f;
            damping = 1.00f;
            limitAngle = 0.40f;
            approachDirection = 1;
            velocityScaled = false;
            base.Reset();
        }
    }


    /// <summary>
    /// configureShotInjuredArm:  This single message allows you to configure the injured arm reaction during shot
    /// </summary>
    [EuphoriaDetail("configureShotInjuredArm:  This single message allows you to configure the injured arm reaction during shot")]
    internal class EuphoriaMessageConfigureShotInjuredArm : EuphoriaMessage
    {
        private float injuredArmTime = 0.250f;
        /// <summary>
        /// length of the reaction
        /// </summary>
        [EuphoriaDetail("length of the reaction")]
        public float InjuredArmTime
        {
            get { return injuredArmTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("injuredArmTime", value);
                injuredArmTime = value;
            }
        }

        private float hipYaw = 0.80f;
        /// <summary>
        /// Amount of hip twist.  (Negative values twist into bullet direction - probably not what is wanted)
        /// </summary>
        [EuphoriaDetail("Amount of hip twist.  (Negative values twist into bullet direction - probably not what is wanted)")]
        public float HipYaw
        {
            get { return hipYaw; }
            set
            {
                value = MathHelper.Clamp(value, -2.00f, 2.00f);
                SetArgument("hipYaw", value);
                hipYaw = value;
            }
        }

        private float hipRoll = 0.00f;
        /// <summary>
        /// Amount of hip roll
        /// </summary>
        [EuphoriaDetail("Amount of hip roll")]
        public float HipRoll
        {
            get { return hipRoll; }
            set
            {
                value = MathHelper.Clamp(value, -2.00f, 2.00f);
                SetArgument("hipRoll", value);
                hipRoll = value;
            }
        }

        private float forceStepExtraHeight = 0.070f;
        /// <summary>
        /// Additional height added to stepping foot
        /// </summary>
        [EuphoriaDetail("Additional height added to stepping foot")]
        public float ForceStepExtraHeight
        {
            get { return forceStepExtraHeight; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 0.70f);
                SetArgument("forceStepExtraHeight", value);
                forceStepExtraHeight = value;
            }
        }

        private bool forceStep = true;
        /// <summary>
        /// force a step to be taken whether pushed out of balance or not
        /// </summary>
        [EuphoriaDetail("force a step to be taken whether pushed out of balance or not")]
        public bool ForceStep
        {
            get { return forceStep; }
            set
            {

                SetArgument("forceStep", value);
                forceStep = value;
            }
        }

        private bool stepTurn = true;
        /// <summary>
        /// turn the character using the balancer
        /// </summary>
        [EuphoriaDetail("turn the character using the balancer")]
        public bool StepTurn
        {
            get { return stepTurn; }
            set
            {

                SetArgument("stepTurn", value);
                stepTurn = value;
            }
        }

        private float velMultiplierStart = 1.0f;
        /// <summary>
        /// Start velocity where parameters begin to be ramped down to zero linearly
        /// </summary>
        [EuphoriaDetail("Start velocity where parameters begin to be ramped down to zero linearly")]
        public float VelMultiplierStart
        {
            get { return velMultiplierStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("velMultiplierStart", value);
                velMultiplierStart = value;
            }
        }

        private float velMultiplierEnd = 5.0f;
        /// <summary>
        /// End velocity of ramp where parameters are scaled to zero
        /// </summary>
        [EuphoriaDetail("End velocity of ramp where parameters are scaled to zero")]
        public float VelMultiplierEnd
        {
            get { return velMultiplierEnd; }
            set
            {
                value = MathHelper.Clamp(value, 1.00f, 40.00f);
                SetArgument("velMultiplierEnd", value);
                velMultiplierEnd = value;
            }
        }

        private float velForceStep = 0.80f;
        /// <summary>
        /// Velocity above which a step is not forced
        /// </summary>
        [EuphoriaDetail("Velocity above which a step is not forced")]
        public float VelForceStep
        {
            get { return velForceStep; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("velForceStep", value);
                velForceStep = value;
            }
        }

        private float velStepTurn = 0.80f;
        /// <summary>
        /// Velocity above which a stepTurn is not asked for
        /// </summary>
        [EuphoriaDetail("Velocity above which a stepTurn is not asked for")]
        public float VelStepTurn
        {
            get { return velStepTurn; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("velStepTurn", value);
                velStepTurn = value;
            }
        }

        private bool velScales = true;
        /// <summary>
        /// Use the velocity scaling parameters.  Tune for standing still then use velocity scaling to make sure a running character stays balanced (the turning tends to make the character fall over more at speed)
        /// </summary>
        [EuphoriaDetail("Use the velocity scaling parameters.  Tune for standing still then use velocity scaling to make sure a running character stays balanced (the turning tends to make the character fall over more at speed)")]
        public bool VelScales
        {
            get { return velScales; }
            set
            {

                SetArgument("velScales", value);
                velScales = value;
            }
        }


        public EuphoriaMessageConfigureShotInjuredArm(bool startNow) : base("configureShotInjuredArm", startNow)
        { }

        public new void Reset()
        {
            injuredArmTime = 0.250f;
            hipYaw = 0.80f;
            hipRoll = 0.00f;
            forceStepExtraHeight = 0.070f;
            forceStep = true;
            stepTurn = true;
            velMultiplierStart = 1.0f;
            velMultiplierEnd = 5.0f;
            velForceStep = 0.80f;
            velStepTurn = 0.80f;
            velScales = true;
            base.Reset();
        }
    }


    /// <summary>
    /// configureShotInjuredLeg:  This single message allows you to configure the injured leg reaction during shot
    /// </summary>
    [EuphoriaDetail("configureShotInjuredLeg:  This single message allows you to configure the injured leg reaction during shot")]
    internal class EuphoriaMessageConfigureShotInjuredLeg : EuphoriaMessage
    {
        private float timeBeforeCollapseWoundLeg = 0.30f;
        /// <summary>
        /// time before a wounded leg is set to be weak and cause the character to collapse
        /// </summary>
        [EuphoriaDetail("time before a wounded leg is set to be weak and cause the character to collapse")]
        public float TimeBeforeCollapseWoundLeg
        {
            get { return timeBeforeCollapseWoundLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("timeBeforeCollapseWoundLeg", value);
                timeBeforeCollapseWoundLeg = value;
            }
        }

        private float legInjuryTime = 0.40f;
        /// <summary>
        /// Leg inury duration (reaction to being shot in leg)
        /// </summary>
        [EuphoriaDetail("Leg inury duration (reaction to being shot in leg)")]
        public float LegInjuryTime
        {
            get { return legInjuryTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("legInjuryTime", value);
                legInjuryTime = value;
            }
        }

        private bool legForceStep = true;
        /// <summary>
        /// force a step to be taken whether pushed out of balance or not
        /// </summary>
        [EuphoriaDetail("force a step to be taken whether pushed out of balance or not")]
        public bool LegForceStep
        {
            get { return legForceStep; }
            set
            {

                SetArgument("legForceStep", value);
                legForceStep = value;
            }
        }

        private float legLimpBend = 0.00f;
        /// <summary>
        /// Bend the legs via the balancer by this amount if stepping on the injured leg. 0.2 seems a good default
        /// </summary>
        [EuphoriaDetail("Bend the legs via the balancer by this amount if stepping on the injured leg. 0.2 seems a good default")]
        public float LegLimpBend
        {
            get { return legLimpBend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("legLimpBend", value);
                legLimpBend = value;
            }
        }

        private float legLiftTime = 0.00f;
        /// <summary>
        /// Leg lift duration (reaction to being shot in leg) (lifting happens when not stepping with other leg)
        /// </summary>
        [EuphoriaDetail("Leg lift duration (reaction to being shot in leg) (lifting happens when not stepping with other leg)")]
        public float LegLiftTime
        {
            get { return legLiftTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("legLiftTime", value);
                legLiftTime = value;
            }
        }

        private float legInjury = 0.30f;
        /// <summary>
        /// Leg injury - leg strength is reduced
        /// </summary>
        [EuphoriaDetail("Leg injury - leg strength is reduced")]
        public float LegInjury
        {
            get { return legInjury; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("legInjury", value);
                legInjury = value;
            }
        }

        private float legInjuryHipPitch = 0.00f;
        /// <summary>
        /// Leg injury bend forwards amount when not lifting leg
        /// </summary>
        [EuphoriaDetail("Leg injury bend forwards amount when not lifting leg")]
        public float LegInjuryHipPitch
        {
            get { return legInjuryHipPitch; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("legInjuryHipPitch", value);
                legInjuryHipPitch = value;
            }
        }

        private float legInjuryLiftHipPitch = 0.00f;
        /// <summary>
        /// Leg injury bend forwards amount when lifting leg (lifting happens when not stepping with other leg)
        /// </summary>
        [EuphoriaDetail("Leg injury bend forwards amount when lifting leg (lifting happens when not stepping with other leg)")]
        public float LegInjuryLiftHipPitch
        {
            get { return legInjuryLiftHipPitch; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("legInjuryLiftHipPitch", value);
                legInjuryLiftHipPitch = value;
            }
        }

        private float legInjurySpineBend = 0.10f;
        /// <summary>
        /// Leg injury bend forwards amount when not lifting leg
        /// </summary>
        [EuphoriaDetail("Leg injury bend forwards amount when not lifting leg")]
        public float LegInjurySpineBend
        {
            get { return legInjurySpineBend; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("legInjurySpineBend", value);
                legInjurySpineBend = value;
            }
        }

        private float legInjuryLiftSpineBend = 0.20f;
        /// <summary>
        /// Leg injury bend forwards amount when lifting leg (lifting happens when not stepping with other leg)
        /// </summary>
        [EuphoriaDetail("Leg injury bend forwards amount when lifting leg (lifting happens when not stepping with other leg)")]
        public float LegInjuryLiftSpineBend
        {
            get { return legInjuryLiftSpineBend; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("legInjuryLiftSpineBend", value);
                legInjuryLiftSpineBend = value;
            }
        }


        public EuphoriaMessageConfigureShotInjuredLeg(bool startNow) : base("configureShotInjuredLeg", startNow)
        { }

        public new void Reset()
        {
            timeBeforeCollapseWoundLeg = 0.30f;
            legInjuryTime = 0.40f;
            legForceStep = true;
            legLimpBend = 0.00f;
            legLiftTime = 0.00f;
            legInjury = 0.30f;
            legInjuryHipPitch = 0.00f;
            legInjuryLiftHipPitch = 0.00f;
            legInjurySpineBend = 0.10f;
            legInjuryLiftSpineBend = 0.20f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageDefineAttachedObject : EuphoriaMessage
    {
        private int partIndex = -1;
        /// <summary>
        /// index of part to attach to
        /// </summary>
        [EuphoriaDetail("index of part to attach to")]
        public int PartIndex
        {
            get { return partIndex; }
            set
            {
                value = MathHelper.Clamp(value, -1, 21);
                SetArgument("partIndex", value);
                partIndex = value;
            }
        }

        private float objectMass = 0.000f;
        /// <summary>
        /// mass of the attached object
        /// </summary>
        [EuphoriaDetail("mass of the attached object")]
        public float ObjectMass
        {
            get { return objectMass; }
            set
            {

                SetArgument("objectMass", value);
                objectMass = value;
            }
        }

        private Vector3 worldPos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// world position of attached object's centre of mass. must be updated each frame.
        /// </summary>
        [EuphoriaDetail("world position of attached object's centre of mass. must be updated each frame.")]
        public Vector3 WorldPos
        {
            get { return worldPos; }
            set
            {

                SetArgument("worldPos", value);
                worldPos = value;
            }
        }


        public EuphoriaMessageDefineAttachedObject(bool startNow) : base("defineAttachedObject", startNow)
        { }

        public new void Reset()
        {
            partIndex = -1;
            objectMass = 0.000f;
            worldPos = new Vector3(0f, 0f, 0f);
            base.Reset();
        }
    }


    /// <summary>
    /// forceToBodyPart:  Apply an impulse to a named body part
    /// </summary>
    [EuphoriaDetail("forceToBodyPart:  Apply an impulse to a named body part")]
    internal class EuphoriaMessageForceToBodyPart : EuphoriaMessage
    {
        private int partIndex = 0;
        /// <summary>
        /// part or link or bound index
        /// </summary>
        [EuphoriaDetail("part or link or bound index")]
        public int PartIndex
        {
            get { return partIndex; }
            set
            {
                value = MathHelper.Clamp(value, 0, 28);
                SetArgument("partIndex", value);
                partIndex = value;
            }
        }

        private Vector3 force = new Vector3(0.00f, -50.00f, 0.00f);
        /// <summary>
        /// force to apply
        /// </summary>
        [EuphoriaDetail("force to apply")]
        public Vector3 Force
        {
            get { return force; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -100000.0f, 100000.0f);
                value.Y = MathHelper.Clamp(value.Y, -100000.0f, 100000.0f);
                value.Z = MathHelper.Clamp(value.Z, -100000.0f, 100000.0f);
                SetArgument("force", value);
                force = value;
            }
        }

        private bool forceDefinedInPartSpace = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool ForceDefinedInPartSpace
        {
            get { return forceDefinedInPartSpace; }
            set
            {

                SetArgument("forceDefinedInPartSpace", value);
                forceDefinedInPartSpace = value;
            }
        }


        public EuphoriaMessageForceToBodyPart(bool startNow) : base("forceToBodyPart", startNow)
        { }

        public new void Reset()
        {
            partIndex = 0;
            force = new Vector3(0.00f, -50.00f, 0.00f);
            forceDefinedInPartSpace = false;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageLeanInDirection : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 dir = new Vector3(0.00f, 0.00f, 1.00f);
        /// <summary>
        /// direction to lean in
        /// </summary>
        [EuphoriaDetail("direction to lean in")]
        public Vector3 Dir
        {
            get { return dir; }
            set
            {

                SetArgument("dir", value);
                dir = value;
            }
        }


        public EuphoriaMessageLeanInDirection(bool startNow) : base("leanInDirection", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            dir = new Vector3(0.00f, 0.00f, 1.00f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageLeanRandom : EuphoriaMessage
    {
        private float leanAmountMin = 0.200f;
        /// <summary>
        /// minimum amount of lean
        /// </summary>
        [EuphoriaDetail("minimum amount of lean")]
        public float LeanAmountMin
        {
            get { return leanAmountMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanAmountMin", value);
                leanAmountMin = value;
            }
        }

        private float leanAmountMax = 0.200f;
        /// <summary>
        /// maximum amount of lean
        /// </summary>
        [EuphoriaDetail("maximum amount of lean")]
        public float LeanAmountMax
        {
            get { return leanAmountMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanAmountMax", value);
                leanAmountMax = value;
            }
        }

        private float changeTimeMin = 0.50f;
        /// <summary>
        /// min time until changing direction
        /// </summary>
        [EuphoriaDetail("min time until changing direction")]
        public float ChangeTimeMin
        {
            get { return changeTimeMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("changeTimeMin", value);
                changeTimeMin = value;
            }
        }

        private float changeTimeMax = 1.00f;
        /// <summary>
        /// maximum time until changing direction
        /// </summary>
        [EuphoriaDetail("maximum time until changing direction")]
        public float ChangeTimeMax
        {
            get { return changeTimeMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("changeTimeMax", value);
                changeTimeMax = value;
            }
        }


        public EuphoriaMessageLeanRandom(bool startNow) : base("leanRandom", startNow)
        { }

        public new void Reset()
        {
            leanAmountMin = 0.200f;
            leanAmountMax = 0.200f;
            changeTimeMin = 0.50f;
            changeTimeMax = 1.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageLeanToPosition : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 0.50f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 pos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position to head towards
        /// </summary>
        [EuphoriaDetail("position to head towards")]
        public Vector3 Pos
        {
            get { return pos; }
            set
            {

                SetArgument("pos", value);
                pos = value;
            }
        }


        public EuphoriaMessageLeanToPosition(bool startNow) : base("leanToPosition", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            pos = new Vector3(0f, 0f, 0f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageLeanTowardsObject : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 0.50f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 offset = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// offset from instance position added when calculating position to lean to
        /// </summary>
        [EuphoriaDetail("offset from instance position added when calculating position to lean to")]
        public Vector3 Offset
        {
            get { return offset; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -100.0f, 100.0f);
                value.Y = MathHelper.Clamp(value.Y, -100.0f, 100.0f);
                value.Z = MathHelper.Clamp(value.Z, -100.0f, 100.0f);
                SetArgument("offset", value);
                offset = value;
            }
        }

        private int instanceIndex = -1;
        /// <summary>
        /// levelIndex of object to lean towards
        /// </summary>
        [EuphoriaDetail("levelIndex of object to lean towards")]
        public int InstanceIndex
        {
            get { return instanceIndex; }
            set
            {

                SetArgument("instanceIndex", value);
                instanceIndex = value;
            }
        }

        private int boundIndex = 0;
        /// <summary>
        /// boundIndex of object to lean towards (0 = just use instance coordinates)
        /// </summary>
        [EuphoriaDetail("boundIndex of object to lean towards (0 = just use instance coordinates)")]
        public int BoundIndex
        {
            get { return boundIndex; }
            set
            {

                SetArgument("boundIndex", value);
                boundIndex = value;
            }
        }


        public EuphoriaMessageLeanTowardsObject(bool startNow) : base("leanTowardsObject", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            offset = new Vector3(0f, 0f, 0f);
            instanceIndex = -1;
            boundIndex = 0;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageHipsLeanInDirection : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 dir = new Vector3(0.00f, 0.00f, 1.00f);
        /// <summary>
        /// direction to lean in
        /// </summary>
        [EuphoriaDetail("direction to lean in")]
        public Vector3 Dir
        {
            get { return dir; }
            set
            {

                SetArgument("dir", value);
                dir = value;
            }
        }


        public EuphoriaMessageHipsLeanInDirection(bool startNow) : base("hipsLeanInDirection", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            dir = new Vector3(0.00f, 0.00f, 1.00f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageHipsLeanRandom : EuphoriaMessage
    {
        private float leanAmountMin = 0.300f;
        /// <summary>
        /// minimum amount of lean
        /// </summary>
        [EuphoriaDetail("minimum amount of lean")]
        public float LeanAmountMin
        {
            get { return leanAmountMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanAmountMin", value);
                leanAmountMin = value;
            }
        }

        private float leanAmountMax = 0.400f;
        /// <summary>
        /// maximum amount of lean
        /// </summary>
        [EuphoriaDetail("maximum amount of lean")]
        public float LeanAmountMax
        {
            get { return leanAmountMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanAmountMax", value);
                leanAmountMax = value;
            }
        }

        private float changeTimeMin = 2.00f;
        /// <summary>
        /// min time until changing direction
        /// </summary>
        [EuphoriaDetail("min time until changing direction")]
        public float ChangeTimeMin
        {
            get { return changeTimeMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("changeTimeMin", value);
                changeTimeMin = value;
            }
        }

        private float changeTimeMax = 4.00f;
        /// <summary>
        /// maximum time until changing direction
        /// </summary>
        [EuphoriaDetail("maximum time until changing direction")]
        public float ChangeTimeMax
        {
            get { return changeTimeMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("changeTimeMax", value);
                changeTimeMax = value;
            }
        }


        public EuphoriaMessageHipsLeanRandom(bool startNow) : base("hipsLeanRandom", startNow)
        { }

        public new void Reset()
        {
            leanAmountMin = 0.300f;
            leanAmountMax = 0.400f;
            changeTimeMin = 2.00f;
            changeTimeMax = 4.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageHipsLeanToPosition : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 0.50f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 pos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position to head towards
        /// </summary>
        [EuphoriaDetail("position to head towards")]
        public Vector3 Pos
        {
            get { return pos; }
            set
            {

                SetArgument("pos", value);
                pos = value;
            }
        }


        public EuphoriaMessageHipsLeanToPosition(bool startNow) : base("hipsLeanToPosition", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            pos = new Vector3(0f, 0f, 0f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageHipsLeanTowardsObject : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 0.50f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 offset = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// offset from instance position added when calculating position to lean to
        /// </summary>
        [EuphoriaDetail("offset from instance position added when calculating position to lean to")]
        public Vector3 Offset
        {
            get { return offset; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -100.0f, 100.0f);
                value.Y = MathHelper.Clamp(value.Y, -100.0f, 100.0f);
                value.Z = MathHelper.Clamp(value.Z, -100.0f, 100.0f);
                SetArgument("offset", value);
                offset = value;
            }
        }

        private int instanceIndex = -1;
        /// <summary>
        /// levelIndex of object to lean hips towards
        /// </summary>
        [EuphoriaDetail("levelIndex of object to lean hips towards")]
        public int InstanceIndex
        {
            get { return instanceIndex; }
            set
            {

                SetArgument("instanceIndex", value);
                instanceIndex = value;
            }
        }

        private int boundIndex = 0;
        /// <summary>
        /// boundIndex of object to lean hips towards (0 = just use instance coordinates)
        /// </summary>
        [EuphoriaDetail("boundIndex of object to lean hips towards (0 = just use instance coordinates)")]
        public int BoundIndex
        {
            get { return boundIndex; }
            set
            {

                SetArgument("boundIndex", value);
                boundIndex = value;
            }
        }


        public EuphoriaMessageHipsLeanTowardsObject(bool startNow) : base("hipsLeanTowardsObject", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            offset = new Vector3(0f, 0f, 0f);
            instanceIndex = -1;
            boundIndex = 0;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageForceLeanInDirection : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 dir = new Vector3(0.00f, 0.00f, 1.00f);
        /// <summary>
        /// direction to lean in
        /// </summary>
        [EuphoriaDetail("direction to lean in")]
        public Vector3 Dir
        {
            get { return dir; }
            set
            {

                SetArgument("dir", value);
                dir = value;
            }
        }

        private int bodyPart = 0;
        /// <summary>
        /// body part that the force is applied to
        /// </summary>
        [EuphoriaDetail("body part that the force is applied to")]
        public int BodyPart
        {
            get { return bodyPart; }
            set
            {
                value = MathHelper.Clamp(value, 0, 21);
                SetArgument("bodyPart", value);
                bodyPart = value;
            }
        }


        public EuphoriaMessageForceLeanInDirection(bool startNow) : base("forceLeanInDirection", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            dir = new Vector3(0.00f, 0.00f, 1.00f);
            bodyPart = 0;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageForceLeanRandom : EuphoriaMessage
    {
        private float leanAmountMin = 0.300f;
        /// <summary>
        /// minimum amount of lean
        /// </summary>
        [EuphoriaDetail("minimum amount of lean")]
        public float LeanAmountMin
        {
            get { return leanAmountMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanAmountMin", value);
                leanAmountMin = value;
            }
        }

        private float leanAmountMax = 0.400f;
        /// <summary>
        /// maximum amount of lean
        /// </summary>
        [EuphoriaDetail("maximum amount of lean")]
        public float LeanAmountMax
        {
            get { return leanAmountMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanAmountMax", value);
                leanAmountMax = value;
            }
        }

        private float changeTimeMin = 2.00f;
        /// <summary>
        /// min time until changing direction
        /// </summary>
        [EuphoriaDetail("min time until changing direction")]
        public float ChangeTimeMin
        {
            get { return changeTimeMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("changeTimeMin", value);
                changeTimeMin = value;
            }
        }

        private float changeTimeMax = 4.00f;
        /// <summary>
        /// maximum time until changing direction
        /// </summary>
        [EuphoriaDetail("maximum time until changing direction")]
        public float ChangeTimeMax
        {
            get { return changeTimeMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("changeTimeMax", value);
                changeTimeMax = value;
            }
        }

        private int bodyPart = 0;
        /// <summary>
        /// body part that the force is applied to
        /// </summary>
        [EuphoriaDetail("body part that the force is applied to")]
        public int BodyPart
        {
            get { return bodyPart; }
            set
            {
                value = MathHelper.Clamp(value, 0, 21);
                SetArgument("bodyPart", value);
                bodyPart = value;
            }
        }


        public EuphoriaMessageForceLeanRandom(bool startNow) : base("forceLeanRandom", startNow)
        { }

        public new void Reset()
        {
            leanAmountMin = 0.300f;
            leanAmountMax = 0.400f;
            changeTimeMin = 2.00f;
            changeTimeMax = 4.00f;
            bodyPart = 0;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageForceLeanToPosition : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 0.50f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 pos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position to head towards
        /// </summary>
        [EuphoriaDetail("position to head towards")]
        public Vector3 Pos
        {
            get { return pos; }
            set
            {

                SetArgument("pos", value);
                pos = value;
            }
        }

        private int bodyPart = 0;
        /// <summary>
        /// body part that the force is applied to
        /// </summary>
        [EuphoriaDetail("body part that the force is applied to")]
        public int BodyPart
        {
            get { return bodyPart; }
            set
            {
                value = MathHelper.Clamp(value, 0, 21);
                SetArgument("bodyPart", value);
                bodyPart = value;
            }
        }


        public EuphoriaMessageForceLeanToPosition(bool startNow) : base("forceLeanToPosition", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            pos = new Vector3(0f, 0f, 0f);
            bodyPart = 0;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageForceLeanTowardsObject : EuphoriaMessage
    {
        private float leanAmount = 0.200f;
        /// <summary>
        /// amount of lean, 0 to about 0.5. -ve will move away from the target.
        /// </summary>
        [EuphoriaDetail("amount of lean, 0 to about 0.5. -ve will move away from the target.")]
        public float LeanAmount
        {
            get { return leanAmount; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 0.50f);
                SetArgument("leanAmount", value);
                leanAmount = value;
            }
        }

        private Vector3 offset = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// offset from instance position added when calculating position to lean to
        /// </summary>
        [EuphoriaDetail("offset from instance position added when calculating position to lean to")]
        public Vector3 Offset
        {
            get { return offset; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -100.0f, 100.0f);
                value.Y = MathHelper.Clamp(value.Y, -100.0f, 100.0f);
                value.Z = MathHelper.Clamp(value.Z, -100.0f, 100.0f);
                SetArgument("offset", value);
                offset = value;
            }
        }

        private int instanceIndex = -1;
        /// <summary>
        /// levelIndex of object to move towards
        /// </summary>
        [EuphoriaDetail("levelIndex of object to move towards")]
        public int InstanceIndex
        {
            get { return instanceIndex; }
            set
            {

                SetArgument("instanceIndex", value);
                instanceIndex = value;
            }
        }

        private int boundIndex = 0;
        /// <summary>
        /// boundIndex of object to move towards (0 = just use instance coordinates)
        /// </summary>
        [EuphoriaDetail("boundIndex of object to move towards (0 = just use instance coordinates)")]
        public int BoundIndex
        {
            get { return boundIndex; }
            set
            {

                SetArgument("boundIndex", value);
                boundIndex = value;
            }
        }

        private int bodyPart = 0;
        /// <summary>
        /// body part that the force is applied to
        /// </summary>
        [EuphoriaDetail("body part that the force is applied to")]
        public int BodyPart
        {
            get { return bodyPart; }
            set
            {
                value = MathHelper.Clamp(value, 0, 21);
                SetArgument("bodyPart", value);
                bodyPart = value;
            }
        }


        public EuphoriaMessageForceLeanTowardsObject(bool startNow) : base("forceLeanTowardsObject", startNow)
        { }

        public new void Reset()
        {
            leanAmount = 0.200f;
            offset = new Vector3(0f, 0f, 0f);
            instanceIndex = -1;
            boundIndex = 0;
            bodyPart = 0;
            base.Reset();
        }
    }

    [EuphoriaDetail("setStiffness:  Use this message to manually set the body stiffness values -before using Active Pose to drive to an animated pose, for example.")]
    /// <summary>
    /// setStiffness:  Use this message to manually set the body stiffness values -before using Active Pose to drive to an animated pose, for example.
    /// </summary>
    internal class EuphoriaMessageSetStiffness : EuphoriaMessage
    {
        private float bodyStiffness = 12.000f;
        /// <summary>
        /// stiffness of whole character
        /// </summary>
        [EuphoriaDetail("stiffness of whole character")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 2.0f, 20.0f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private float damping = 1.000f;
        /// <summary>
        /// damping amount, less is underdamped
        /// </summary>
        [EuphoriaDetail("damping amount, less is underdamped")]
        public float Damping
        {
            get { return damping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("damping", value);
                damping = value;
            }
        }

        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }


        public EuphoriaMessageSetStiffness(bool startNow) : base("setStiffness", startNow)
        { }

        public new void Reset()
        {
            bodyStiffness = 12.000f;
            damping = 1.000f;
            mask = "fb";
            base.Reset();
        }
    }


    /// <summary>
    /// setMuscleStiffness:  Use this message to manually set the muscle stiffness values -before using Active Pose to drive to an animated pose, for example.
    /// </summary>
    [EuphoriaDetail("setMuscleStiffness:  Use this message to manually set the muscle stiffness values -before using Active Pose to drive to an animated pose, for example.")]
    internal class EuphoriaMessageSetMuscleStiffness : EuphoriaMessage
    {
        private float muscleStiffness = 1.000f;
        /// <summary>
        /// muscle stiffness of joint/s
        /// </summary>
        [EuphoriaDetail("muscle stiffness of joint/s")]
        public float MuscleStiffness
        {
            get { return muscleStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("muscleStiffness", value);
                muscleStiffness = value;
            }
        }

        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }


        public EuphoriaMessageSetMuscleStiffness(bool startNow) : base("setMuscleStiffness", startNow)
        { }

        public new void Reset()
        {
            muscleStiffness = 1.000f;
            mask = "fb";
            base.Reset();
        }
    }


    /// <summary>
    /// setWeaponMode:  Use this message to set the character's weapon mode.  This is an alternativeto the setWeaponMode public function.
    /// </summary>
    [EuphoriaDetail("setWeaponMode:  Use this message to set the character's weapon mode.  This is an alternativeto the setWeaponMode public function.")]
    internal class EuphoriaMessageSetWeaponMode : EuphoriaMessage
    {
        private int weaponMode = 5;
        /// <summary>
        /// Weapon mode. kNone = -1, kPistol = 0, kDual = 1, kRifle = 2, kSidearm = 3, kPistolLeft = 4, kPistolRight = 5. See WeaponMode enum in NmRsUtils.h and -1 from that.
        /// </summary>
        [EuphoriaDetail("Weapon mode. kNone = -1, kPistol = 0, kDual = 1, kRifle = 2, kSidearm = 3, kPistolLeft = 4, kPistolRight = 5. See WeaponMode enum in NmRsUtils.h and -1 from that.")]
        public int WeaponMode
        {
            get { return weaponMode; }
            set
            {
                value = MathHelper.Clamp(value, -1, 6);
                SetArgument("weaponMode", value);
                weaponMode = value;
            }
        }


        public EuphoriaMessageSetWeaponMode(bool startNow) : base("setWeaponMode", startNow)
        { }

        public new void Reset()
        {
            weaponMode = 5;
            base.Reset();
        }
    }


    /// <summary>
    /// registerWeapon:  Use this message to register weapon.  This is an alternativeto the registerWeapon public function.
    /// </summary>
    [EuphoriaDetail("registerWeapon:  Use this message to register weapon.  This is an alternativeto the registerWeapon public function.")]
    internal class EuphoriaMessageRegisterWeapon : EuphoriaMessage
    {
        private int hand = 1;
        /// <summary>
        /// What hand the weapon is in. LeftHand = 0, RightHand = 1
        /// </summary>
        [EuphoriaDetail("What hand the weapon is in. LeftHand = 0, RightHand = 1")]
        public int Hand
        {
            get { return hand; }
            set
            {
                value = MathHelper.Clamp(value, 0, 1);
                SetArgument("hand", value);
                hand = value;
            }
        }

        private int levelIndex = -1;
        /// <summary>
        /// Level index of the weapon
        /// </summary>
        [EuphoriaDetail("Level index of the weapon")]
        public int LevelIndex
        {
            get { return levelIndex; }
            set
            {

                SetArgument("levelIndex", value);
                levelIndex = value;
            }
        }

        private int constraintHandle = -1;
        /// <summary>
        /// pointer to the hand-gun constraint handle
        /// </summary>
        [EuphoriaDetail("pointer to the hand-gun constraint handle")]
        public int ConstraintHandle
        {
            get { return constraintHandle; }
            set
            {

                SetArgument("constraintHandle", value);
                constraintHandle = value;
            }
        }

        private Vector3 gunToHandA = new Vector3(1.00f, 0.00f, 0.00f);
        /// <summary>
        /// A vector of the gunToHand matrix.  The gunToHandMatrix is the desired gunToHandMatrix in the aimingPose. (The gunToHandMatrix when pointGun starts can be different so will be blended to this desired one)
        /// </summary>
        [EuphoriaDetail("A vector of the gunToHand matrix.  The gunToHandMatrix is the desired gunToHandMatrix in the aimingPose. (The gunToHandMatrix when pointGun starts can be different so will be blended to this desired one)")]
        public Vector3 GunToHandA
        {
            get { return gunToHandA; }
            set
            {

                SetArgument("gunToHandA", value);
                gunToHandA = value;
            }
        }

        private Vector3 gunToHandB = new Vector3(0.00f, 1.00f, 0.00f);
        /// <summary>
        /// B vector of the gunToHand matrix
        /// </summary>
        [EuphoriaDetail("B vector of the gunToHand matrix")]
        public Vector3 GunToHandB
        {
            get { return gunToHandB; }
            set
            {

                SetArgument("gunToHandB", value);
                gunToHandB = value;
            }
        }

        private Vector3 gunToHandC = new Vector3(0.00f, 0.00f, 1.00f);
        /// <summary>
        /// C vector of the gunToHand matrix
        /// </summary>
        [EuphoriaDetail("C vector of the gunToHand matrix")]
        public Vector3 GunToHandC
        {
            get { return gunToHandC; }
            set
            {

                SetArgument("gunToHandC", value);
                gunToHandC = value;
            }
        }

        private Vector3 gunToHandD = new Vector3(0.00f, 0.00f, 0.00f);
        /// <summary>
        /// D vector of the gunToHand matrix
        /// </summary>
        [EuphoriaDetail("D vector of the gunToHand matrix")]
        public Vector3 GunToHandD
        {
            get { return gunToHandD; }
            set
            {

                SetArgument("gunToHandD", value);
                gunToHandD = value;
            }
        }

        private Vector3 gunToMuzzleInGun = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Gun centre to muzzle expressed in gun co-ordinates.  To get the line of sight/barrel of the gun. Assumption: the muzzle direction is always along the same primary axis of the gun.
        /// </summary>
        [EuphoriaDetail("Gun centre to muzzle expressed in gun co-ordinates.  To get the line of sight/barrel of the gun. Assumption: the muzzle direction is always along the same primary axis of the gun.")]
        public Vector3 GunToMuzzleInGun
        {
            get { return gunToMuzzleInGun; }
            set
            {

                SetArgument("gunToMuzzleInGun", value);
                gunToMuzzleInGun = value;
            }
        }

        private Vector3 gunToButtInGun = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Gun centre to butt expressed in gun co-ordinates.  The gun pivots around this point when aiming
        /// </summary>
        [EuphoriaDetail("Gun centre to butt expressed in gun co-ordinates.  The gun pivots around this point when aiming")]
        public Vector3 GunToButtInGun
        {
            get { return gunToButtInGun; }
            set
            {

                SetArgument("gunToButtInGun", value);
                gunToButtInGun = value;
            }
        }


        public EuphoriaMessageRegisterWeapon(bool startNow) : base("registerWeapon", startNow)
        { }

        public new void Reset()
        {
            hand = 1;
            levelIndex = -1;
            constraintHandle = -1;
            gunToHandA = new Vector3(1.00f, 0.00f, 0.00f);
            gunToHandB = new Vector3(0.00f, 1.00f, 0.00f);
            gunToHandC = new Vector3(0.00f, 0.00f, 1.00f);
            gunToHandD = new Vector3(0.00f, 0.00f, 0.00f);
            gunToMuzzleInGun = new Vector3(0f, 0f, 0f);
            gunToButtInGun = new Vector3(0f, 0f, 0f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageShotRelax : EuphoriaMessage
    {
        private float relaxPeriodUpper = 2.000f;
        /// <summary>
        /// time over which to relax to full relaxation for upper body
        /// </summary>
        [EuphoriaDetail("time over which to relax to full relaxation for upper body")]
        public float RelaxPeriodUpper
        {
            get { return relaxPeriodUpper; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 40.0f);
                SetArgument("relaxPeriodUpper", value);
                relaxPeriodUpper = value;
            }
        }

        private float relaxPeriodLower = 0.400f;
        /// <summary>
        /// time over which to relax to full relaxation for lower body
        /// </summary>
        [EuphoriaDetail("time over which to relax to full relaxation for lower body")]
        public float RelaxPeriodLower
        {
            get { return relaxPeriodLower; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 40.0f);
                SetArgument("relaxPeriodLower", value);
                relaxPeriodLower = value;
            }
        }


        public EuphoriaMessageShotRelax(bool startNow) : base("shotRelax", startNow)
        { }

        public new void Reset()
        {
            relaxPeriodUpper = 2.000f;
            relaxPeriodLower = 0.400f;
            base.Reset();
        }
    }


    /// <summary>
    /// fireWeapon:  One shot message apply a force to the hand as we fire the gun that should be in this hand
    /// </summary>
    [EuphoriaDetail("fireWeapon:  One shot message apply a force to the hand as we fire the gun that should be in this hand")]
    internal class EuphoriaMessageFireWeapon : EuphoriaMessage
    {
        private float firedWeaponStrength = 1000.0f;
        /// <summary>
        /// The force of the gun.
        /// </summary>
        [EuphoriaDetail("The force of the gun.")]
        public float FiredWeaponStrength
        {
            get { return firedWeaponStrength; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10000.0f);
                SetArgument("firedWeaponStrength", value);
                firedWeaponStrength = value;
            }
        }

        private int gunHandEnum = 0;
        /// <summary>
        /// Which hand in the gun in, 0 = left, 1 = right.
        /// </summary>
        [EuphoriaDetail("Which hand in the gun in, 0 = left, 1 = right.")]
        public int GunHandEnum
        {
            get { return gunHandEnum; }
            set
            {
                value = MathHelper.Clamp(value, 0, 1);
                SetArgument("gunHandEnum", value);
                gunHandEnum = value;
            }
        }

        private bool applyFireGunForceAtClavicle = false;
        /// <summary>
        /// Should we apply some of the force at the shoulder. Force double handed weapons (Ak47 etc).
        /// </summary>
        [EuphoriaDetail("Should we apply some of the force at the shoulder. Force double handed weapons (Ak47 etc).")]
        public bool ApplyFireGunForceAtClavicle
        {
            get { return applyFireGunForceAtClavicle; }
            set
            {

                SetArgument("applyFireGunForceAtClavicle", value);
                applyFireGunForceAtClavicle = value;
            }
        }

        private float inhibitTime = 0.40f;
        /// <summary>
        /// Minimum time before next fire impulse
        /// </summary>
        [EuphoriaDetail("Minimum time before next fire impulse")]
        public float InhibitTime
        {
            get { return inhibitTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("inhibitTime", value);
                inhibitTime = value;
            }
        }

        private Vector3 direction = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// direction of impulse in gun frame
        /// </summary>
        [EuphoriaDetail("direction of impulse in gun frame")]
        public Vector3 Direction
        {
            get { return direction; }
            set
            {

                SetArgument("direction", value);
                direction = value;
            }
        }

        private float split = 0.50f;
        /// <summary>
        /// Split force between hand and clavicle when applyFireGunForceAtClavicle is true. 1 = all hand, 0 = all clavicle.
        /// </summary>
        [EuphoriaDetail("Split force between hand and clavicle when applyFireGunForceAtClavicle is true. 1 = all hand, 0 = all clavicle.")]
        public float Split
        {
            get { return split; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("split", value);
                split = value;
            }
        }


        public EuphoriaMessageFireWeapon(bool startNow) : base("fireWeapon", startNow)
        { }

        public new void Reset()
        {
            firedWeaponStrength = 1000.0f;
            gunHandEnum = 0;
            applyFireGunForceAtClavicle = false;
            inhibitTime = 0.40f;
            direction = new Vector3(0f, 0f, 0f);
            split = 0.50f;
            base.Reset();
        }
    }


    /// <summary>
    /// configureConstraints:  One shot to give state of constraints on character and response to constraints
    /// </summary>
    [EuphoriaDetail("configureConstraints:  One shot to give state of constraints on character and response to constraints")]
    internal class EuphoriaMessageConfigureConstraints : EuphoriaMessage
    {
        private bool handCuffs = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool HandCuffs
        {
            get { return handCuffs; }
            set
            {

                SetArgument("handCuffs", value);
                handCuffs = value;
            }
        }

        private bool handCuffsBehindBack = false;
        /// <summary>
        /// not implemented
        /// </summary>
        [EuphoriaDetail("not implemented")]
        public bool HandCuffsBehindBack
        {
            get { return handCuffsBehindBack; }
            set
            {

                SetArgument("handCuffsBehindBack", value);
                handCuffsBehindBack = value;
            }
        }

        private bool legCuffs = false;
        /// <summary>
        /// not implemented
        /// </summary>
        [EuphoriaDetail("not implemented")]
        public bool LegCuffs
        {
            get { return legCuffs; }
            set
            {

                SetArgument("legCuffs", value);
                legCuffs = value;
            }
        }

        private bool rightDominant = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool RightDominant
        {
            get { return rightDominant; }
            set
            {

                SetArgument("rightDominant", value);
                rightDominant = value;
            }
        }

        private int passiveMode = 0;
        /// <summary>
        /// 0 setCurrent, 1= IK to dominant, (2=pointGunLikeIK //not implemented)
        /// </summary>
        [EuphoriaDetail("0 setCurrent, 1= IK to dominant, (2=pointGunLikeIK //not implemented)")]
        public int PassiveMode
        {
            get { return passiveMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 5);
                SetArgument("passiveMode", value);
                passiveMode = value;
            }
        }

        private bool bespokeBehaviour = false;
        /// <summary>
        /// not implemented
        /// </summary>
        [EuphoriaDetail("not implemented")]
        public bool BespokeBehaviour
        {
            get { return bespokeBehaviour; }
            set
            {

                SetArgument("bespokeBehaviour", value);
                bespokeBehaviour = value;
            }
        }

        private float blend2ZeroPose = 0f;
        /// <summary>
        /// Blend Arms to zero pose
        /// </summary>
        [EuphoriaDetail("Blend Arms to zero pose")]
        public float Blend2ZeroPose
        {
            get { return blend2ZeroPose; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("blend2ZeroPose", value);
                blend2ZeroPose = value;
            }
        }


        public EuphoriaMessageConfigureConstraints(bool startNow) : base("configureConstraints", startNow)
        { }

        public new void Reset()
        {
            handCuffs = false;
            handCuffsBehindBack = false;
            legCuffs = false;
            rightDominant = false;
            passiveMode = 0;
            bespokeBehaviour = false;
            blend2ZeroPose = 0f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageStayUpright : EuphoriaMessage
    {
        private bool useForces = false;
        /// <summary>
        /// enable force based constraint
        /// </summary>
        [EuphoriaDetail("enable force based constraint")]
        public bool UseForces
        {
            get { return useForces; }
            set
            {

                SetArgument("useForces", value);
                useForces = value;
            }
        }

        private bool useTorques = false;
        /// <summary>
        /// enable torque based constraint
        /// </summary>
        [EuphoriaDetail("enable torque based constraint")]
        public bool UseTorques
        {
            get { return useTorques; }
            set
            {

                SetArgument("useTorques", value);
                useTorques = value;
            }
        }

        private bool lastStandMode = false;
        /// <summary>
        /// Uses position/orientation control on the spine and drifts in the direction of bullets.  This ignores all other stayUpright settings.
        /// </summary>
        [EuphoriaDetail("Uses position/orientation control on the spine and drifts in the direction of bullets.  This ignores all other stayUpright settings.")]
        public bool LastStandMode
        {
            get { return lastStandMode; }
            set
            {

                SetArgument("lastStandMode", value);
                lastStandMode = value;
            }
        }

        private float lastStandSinkRate = 0.30f;
        /// <summary>
        /// The sink rate (higher for a faster drop).
        /// </summary>
        [EuphoriaDetail("The sink rate (higher for a faster drop).")]
        public float LastStandSinkRate
        {
            get { return lastStandSinkRate; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("lastStandSinkRate", value);
                lastStandSinkRate = value;
            }
        }

        private float lastStandHorizDamping = 0.40f;
        /// <summary>
        /// Higher values for more damping
        /// </summary>
        [EuphoriaDetail("Higher values for more damping")]
        public float LastStandHorizDamping
        {
            get { return lastStandHorizDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("lastStandHorizDamping", value);
                lastStandHorizDamping = value;
            }
        }

        private float lastStandMaxTime = 0.40f;
        /// <summary>
        /// Max time allowed in last stand mode
        /// </summary>
        [EuphoriaDetail("Max time allowed in last stand mode")]
        public float LastStandMaxTime
        {
            get { return lastStandMaxTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 5.0f);
                SetArgument("lastStandMaxTime", value);
                lastStandMaxTime = value;
            }
        }

        private bool turnTowardsBullets = false;
        /// <summary>
        /// Use cheat torques to face the direction of bullets if not facing too far away
        /// </summary>
        [EuphoriaDetail("Use cheat torques to face the direction of bullets if not facing too far away")]
        public bool TurnTowardsBullets
        {
            get { return turnTowardsBullets; }
            set
            {

                SetArgument("turnTowardsBullets", value);
                turnTowardsBullets = value;
            }
        }

        private bool velocityBased = false;
        /// <summary>
        /// make strength of constraint function of COM velocity.  Uses -1 for forceDamping if the damping is positive.
        /// </summary>
        [EuphoriaDetail("make strength of constraint function of COM velocity.  Uses -1 for forceDamping if the damping is positive.")]
        public bool VelocityBased
        {
            get { return velocityBased; }
            set
            {

                SetArgument("velocityBased", value);
                velocityBased = value;
            }
        }

        private bool torqueOnlyInAir = false;
        /// <summary>
        /// only apply torque based constraint when airBorne
        /// </summary>
        [EuphoriaDetail("only apply torque based constraint when airBorne")]
        public bool TorqueOnlyInAir
        {
            get { return torqueOnlyInAir; }
            set
            {

                SetArgument("torqueOnlyInAir", value);
                torqueOnlyInAir = value;
            }
        }

        private float forceStrength = 3.00f;
        /// <summary>
        /// strength of constraint
        /// </summary>
        [EuphoriaDetail("strength of constraint")]
        public float ForceStrength
        {
            get { return forceStrength; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("forceStrength", value);
                forceStrength = value;
            }
        }

        private float forceDamping = -1.00f;
        /// <summary>
        /// damping in constraint: -1 makes it scale automagically with forceStrength.  Other negative values will scale this automagic damping.
        /// </summary>
        [EuphoriaDetail("damping in constraint: -1 makes it scale automagically with forceStrength.  Other negative values will scale this automagic damping.")]
        public float ForceDamping
        {
            get { return forceDamping; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 50.0f);
                SetArgument("forceDamping", value);
                forceDamping = value;
            }
        }

        private float forceFeetMult = 1.00f;
        /// <summary>
        /// multiplier to the force applied to the feet
        /// </summary>
        [EuphoriaDetail("multiplier to the force applied to the feet")]
        public float ForceFeetMult
        {
            get { return forceFeetMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("forceFeetMult", value);
                forceFeetMult = value;
            }
        }

        private float forceSpine3Share = 0.30f;
        /// <summary>
        /// share of pelvis force applied to spine3
        /// </summary>
        [EuphoriaDetail("share of pelvis force applied to spine3")]
        public float ForceSpine3Share
        {
            get { return forceSpine3Share; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("forceSpine3Share", value);
                forceSpine3Share = value;
            }
        }

        private float forceLeanReduction = 1.00f;
        /// <summary>
        /// how much the character lean is taken into account when reducing the force.
        /// </summary>
        [EuphoriaDetail("how much the character lean is taken into account when reducing the force.")]
        public float ForceLeanReduction
        {
            get { return forceLeanReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("forceLeanReduction", value);
                forceLeanReduction = value;
            }
        }

        private float forceInAirShare = 0.50f;
        /// <summary>
        /// share of the feet force to the airborne foot
        /// </summary>
        [EuphoriaDetail("share of the feet force to the airborne foot")]
        public float ForceInAirShare
        {
            get { return forceInAirShare; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("forceInAirShare", value);
                forceInAirShare = value;
            }
        }

        private float forceMin = -1.00f;
        /// <summary>
        /// when min and max are greater than 0 the constraint strength is determined from character strength, scaled into the range given by min and max
        /// </summary>
        [EuphoriaDetail("when min and max are greater than 0 the constraint strength is determined from character strength, scaled into the range given by min and max")]
        public float ForceMin
        {
            get { return forceMin; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 16.0f);
                SetArgument("forceMin", value);
                forceMin = value;
            }
        }

        private float forceMax = -1.00f;
        /// <summary>
        /// see above
        /// </summary>
        [EuphoriaDetail("see above")]
        public float ForceMax
        {
            get { return forceMax; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 16.0f);
                SetArgument("forceMax", value);
                forceMax = value;
            }
        }

        private float forceSaturationVel = 4.00f;
        /// <summary>
        /// when in velocityBased mode, the COM velocity at which constraint reaches maximum strength (forceStrength)
        /// </summary>
        [EuphoriaDetail("when in velocityBased mode, the COM velocity at which constraint reaches maximum strength (forceStrength)")]
        public float ForceSaturationVel
        {
            get { return forceSaturationVel; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 10.0f);
                SetArgument("forceSaturationVel", value);
                forceSaturationVel = value;
            }
        }

        private float forceThresholdVel = 0.50f;
        /// <summary>
        /// when in velocityBased mode, the COM velocity above which constraint starts applying forces
        /// </summary>
        [EuphoriaDetail("when in velocityBased mode, the COM velocity above which constraint starts applying forces")]
        public float ForceThresholdVel
        {
            get { return forceThresholdVel; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("forceThresholdVel", value);
                forceThresholdVel = value;
            }
        }

        private float torqueStrength = 0.00f;
        /// <summary>
        /// strength of torque based constraint
        /// </summary>
        [EuphoriaDetail("strength of torque based constraint")]
        public float TorqueStrength
        {
            get { return torqueStrength; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 16.0f);
                SetArgument("torqueStrength", value);
                torqueStrength = value;
            }
        }

        private float torqueDamping = 0.50f;
        /// <summary>
        /// damping of torque based constraint
        /// </summary>
        [EuphoriaDetail("damping of torque based constraint")]
        public float TorqueDamping
        {
            get { return torqueDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 16.0f);
                SetArgument("torqueDamping", value);
                torqueDamping = value;
            }
        }

        private float torqueSaturationVel = 4.00f;
        /// <summary>
        /// when in velocityBased mode, the COM velocity at which constraint reaches maximum strength (torqueStrength)
        /// </summary>
        [EuphoriaDetail("when in velocityBased mode, the COM velocity at which constraint reaches maximum strength (torqueStrength)")]
        public float TorqueSaturationVel
        {
            get { return torqueSaturationVel; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 10.0f);
                SetArgument("torqueSaturationVel", value);
                torqueSaturationVel = value;
            }
        }

        private float torqueThresholdVel = 2.50f;
        /// <summary>
        /// when in velocityBased mode, the COM velocity above which constraint starts applying torques
        /// </summary>
        [EuphoriaDetail("when in velocityBased mode, the COM velocity above which constraint starts applying torques")]
        public float TorqueThresholdVel
        {
            get { return torqueThresholdVel; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("torqueThresholdVel", value);
                torqueThresholdVel = value;
            }
        }

        private float supportPosition = 2.00f;
        /// <summary>
        /// distance the foot is behind Com projection that is still considered able to generate the support for the upright constraint
        /// </summary>
        [EuphoriaDetail("distance the foot is behind Com projection that is still considered able to generate the support for the upright constraint")]
        public float SupportPosition
        {
            get { return supportPosition; }
            set
            {
                value = MathHelper.Clamp(value, -2.00f, 2.00f);
                SetArgument("supportPosition", value);
                supportPosition = value;
            }
        }

        private float noSupportForceMult = 1.00f;
        /// <summary>
        /// still apply this fraction of the upright constaint force if the foot is not in a position (defined by supportPosition) to generate the support for the upright constraint
        /// </summary>
        [EuphoriaDetail("still apply this fraction of the upright constaint force if the foot is not in a position (defined by supportPosition) to generate the support for the upright constraint")]
        public float NoSupportForceMult
        {
            get { return noSupportForceMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("noSupportForceMult", value);
                noSupportForceMult = value;
            }
        }

        private float stepUpHelp = 0.00f;
        /// <summary>
        /// strength of cheat force applied upwards to spine3 to help the character up steps/slopes
        /// </summary>
        [EuphoriaDetail("strength of cheat force applied upwards to spine3 to help the character up steps/slopes")]
        public float StepUpHelp
        {
            get { return stepUpHelp; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 16.0f);
                SetArgument("stepUpHelp", value);
                stepUpHelp = value;
            }
        }

        private float stayUpAcc = 0.70f;
        /// <summary>
        /// How much the cheat force takes into account the acceleration of moving platforms
        /// </summary>
        [EuphoriaDetail("How much the cheat force takes into account the acceleration of moving platforms")]
        public float StayUpAcc
        {
            get { return stayUpAcc; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("stayUpAcc", value);
                stayUpAcc = value;
            }
        }

        private float stayUpAccMax = 5.00f;
        /// <summary>
        /// The maximum floorAcceleration (of a moving platform) that the cheat force takes into account
        /// </summary>
        [EuphoriaDetail("The maximum floorAcceleration (of a moving platform) that the cheat force takes into account")]
        public float StayUpAccMax
        {
            get { return stayUpAccMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 15.0f);
                SetArgument("stayUpAccMax", value);
                stayUpAccMax = value;
            }
        }


        public EuphoriaMessageStayUpright(bool startNow) : base("stayUpright", startNow)
        { }

        public new void Reset()
        {
            useForces = false;
            useTorques = false;
            lastStandMode = false;
            lastStandSinkRate = 0.30f;
            lastStandHorizDamping = 0.40f;
            lastStandMaxTime = 0.40f;
            turnTowardsBullets = false;
            velocityBased = false;
            torqueOnlyInAir = false;
            forceStrength = 3.00f;
            forceDamping = -1.00f;
            forceFeetMult = 1.00f;
            forceSpine3Share = 0.30f;
            forceLeanReduction = 1.00f;
            forceInAirShare = 0.50f;
            forceMin = -1.00f;
            forceMax = -1.00f;
            forceSaturationVel = 4.00f;
            forceThresholdVel = 0.50f;
            torqueStrength = 0.00f;
            torqueDamping = 0.50f;
            torqueSaturationVel = 4.00f;
            torqueThresholdVel = 2.50f;
            supportPosition = 2.00f;
            noSupportForceMult = 1.00f;
            stepUpHelp = 0.00f;
            stayUpAcc = 0.70f;
            stayUpAccMax = 5.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// stopAllBehaviours:  Send this message to immediately stop all behaviours from executing.
    /// </summary>
    [EuphoriaDetail("stopAllBehaviours:  Send this message to immediately stop all behaviours from executing.")]
    internal class EuphoriaMessageStopAllBehaviours : EuphoriaMessage
    {

        public EuphoriaMessageStopAllBehaviours(bool startNow) : base("stopAllBehaviours", startNow)
        { }

        public new void Reset()
        {
            base.Reset();
        }
    }


    /// <summary>
    /// setCharacterStrength:  Sets character's strength on the dead-granny-to-healthy-terminator scale: [0..1]
    /// </summary>
    [EuphoriaDetail("setCharacterStrength:  Sets character's strength on the dead-granny-to-healthy-terminator scale: [0..1]")]
    internal class EuphoriaMessageSetCharacterStrength : EuphoriaMessage
    {
        private float characterStrength = 1.00f;
        /// <summary>
        /// strength of character
        /// </summary>
        [EuphoriaDetail("strength of character")]
        public float CharacterStrength
        {
            get { return characterStrength; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("characterStrength", value);
                characterStrength = value;
            }
        }


        public EuphoriaMessageSetCharacterStrength(bool startNow) : base("setCharacterStrength", startNow)
        { }

        public new void Reset()
        {
            characterStrength = 1.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// setCharacterHealth:  Sets character's health on the dead-to-alive scale: [0..1]
    /// </summary>
    [EuphoriaDetail("setCharacterHealth:  Sets character's health on the dead-to-alive scale: [0..1]")]
    internal class EuphoriaMessageSetCharacterHealth : EuphoriaMessage
    {
        private float characterHealth = 1.00f;
        /// <summary>
        /// health of character
        /// </summary>
        [EuphoriaDetail("health of character")]
        public float CharacterHealth
        {
            get { return characterHealth; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("characterHealth", value);
                characterHealth = value;
            }
        }


        public EuphoriaMessageSetCharacterHealth(bool startNow) : base("setCharacterHealth", startNow)
        { }

        public new void Reset()
        {
            characterHealth = 1.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// setFallingReaction:  Sets the type of reaction if catchFall is called
    /// </summary>
    [EuphoriaDetail("setFallingReaction:  Sets the type of reaction if catchFall is called")]
    internal class EuphoriaMessageSetFallingReaction : EuphoriaMessage
    {
        private bool handsAndKnees = false;
        /// <summary>
        /// set to true to get handsAndKnees catchFall if catchFall called. If true allows the dynBalancer to stay on during the catchfall and modifies the catch fall to give a more alive looking performance (hands and knees for front landing or sitting up for back landing)
        /// </summary>
        [EuphoriaDetail("set to true to get handsAndKnees catchFall if catchFall called. If true allows the dynBalancer to stay on during the catchfall and modifies the catch fall to give a more alive looking performance (hands and knees for front landing or sitting up for back landing)")]
        public bool HandsAndKnees
        {
            get { return handsAndKnees; }
            set
            {

                SetArgument("handsAndKnees", value);
                handsAndKnees = value;
            }
        }

        private bool callRDS = false;
        /// <summary>
        /// If true catchFall will call rollDownstairs if comVel GT comVelRDSThresh - prevents excessive sliding in catchFall.  Was previously only true for handsAndKnees
        /// </summary>
        [EuphoriaDetail("If true catchFall will call rollDownstairs if comVel GT comVelRDSThresh - prevents excessive sliding in catchFall.  Was previously only true for handsAndKnees")]
        public bool CallRDS
        {
            get { return callRDS; }
            set
            {

                SetArgument("callRDS", value);
                callRDS = value;
            }
        }

        private float comVelRDSThresh = 2.00f;
        /// <summary>
        /// comVel above which rollDownstairs will start - prevents excessive sliding in catchFall
        /// </summary>
        [EuphoriaDetail("comVel above which rollDownstairs will start - prevents excessive sliding in catchFall")]
        public float ComVelRDSThresh
        {
            get { return comVelRDSThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("comVelRDSThresh", value);
                comVelRDSThresh = value;
            }
        }

        private bool resistRolling = false;
        /// <summary>
        /// For rds catchFall only: True to resist rolling motion (rolling motion is set off by ub contact and a sliding velocity), false to allow more of a continuous rolling  (rolling motion is set off at a sliding velocity)
        /// </summary>
        [EuphoriaDetail("For rds catchFall only: True to resist rolling motion (rolling motion is set off by ub contact and a sliding velocity), false to allow more of a continuous rolling  (rolling motion is set off at a sliding velocity)")]
        public bool ResistRolling
        {
            get { return resistRolling; }
            set
            {

                SetArgument("resistRolling", value);
                resistRolling = value;
            }
        }

        private float armReduceSpeed = 2.50f;
        /// <summary>
        /// Strength is reduced in the catchFall when the arms contact the ground.  0.2 is good for handsAndKnees.  2.5 is good for normal catchFall, anything lower than 1.0 for normal catchFall may lead to bad catchFall poses.
        /// </summary>
        [EuphoriaDetail("Strength is reduced in the catchFall when the arms contact the ground.  0.2 is good for handsAndKnees.  2.5 is good for normal catchFall, anything lower than 1.0 for normal catchFall may lead to bad catchFall poses.")]
        public float ArmReduceSpeed
        {
            get { return armReduceSpeed; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("armReduceSpeed", value);
                armReduceSpeed = value;
            }
        }

        private float reachLengthMultiplier = 1.00f;
        /// <summary>
        /// Reach length multiplier that scales characters arm topological length, value in range from (0, 1 GT  where 1.0 means reach length is maximum.
        /// </summary>
        [EuphoriaDetail("Reach length multiplier that scales characters arm topological length, value in range from (0, 1 GT  where 1.0 means reach length is maximum.")]
        public float ReachLengthMultiplier
        {
            get { return reachLengthMultiplier; }
            set
            {
                value = MathHelper.Clamp(value, 0.30f, 1.00f);
                SetArgument("reachLengthMultiplier", value);
                reachLengthMultiplier = value;
            }
        }

        private float inhibitRollingTime = 0.20f;
        /// <summary>
        /// Time after hitting ground that the catchFall can call rds
        /// </summary>
        [EuphoriaDetail("Time after hitting ground that the catchFall can call rds")]
        public float InhibitRollingTime
        {
            get { return inhibitRollingTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("inhibitRollingTime", value);
                inhibitRollingTime = value;
            }
        }

        private float changeFrictionTime = 0.20f;
        /// <summary>
        /// Time after hitting ground that the catchFall can change the friction of parts to inhibit sliding
        /// </summary>
        [EuphoriaDetail("Time after hitting ground that the catchFall can change the friction of parts to inhibit sliding")]
        public float ChangeFrictionTime
        {
            get { return changeFrictionTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("changeFrictionTime", value);
                changeFrictionTime = value;
            }
        }

        private float groundFriction = 1.00f;
        /// <summary>
        /// 8.0 was used on yanked) Friction multiplier on bodyParts when on ground.  Character can look too slidy with groundFriction = 1.  Higher values give a more jerky reation but this seems timestep dependent especially for dragged by the feet.
        /// </summary>
        [EuphoriaDetail("8.0 was used on yanked) Friction multiplier on bodyParts when on ground.  Character can look too slidy with groundFriction = 1.  Higher values give a more jerky reation but this seems timestep dependent especially for dragged by the feet.")]
        public float GroundFriction
        {
            get { return groundFriction; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("groundFriction", value);
                groundFriction = value;
            }
        }

        private float frictionMin = 0.00f;
        /// <summary>
        /// Min Friction of an impact with a body part (not head, hands or feet) - to increase friction of slippy environment to get character to roll better.  Applied in catchFall and rollUp(rollDownStairs)
        /// </summary>
        [EuphoriaDetail("Min Friction of an impact with a body part (not head, hands or feet) - to increase friction of slippy environment to get character to roll better.  Applied in catchFall and rollUp(rollDownStairs)")]
        public float FrictionMin
        {
            get { return frictionMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("frictionMin", value);
                frictionMin = value;
            }
        }

        private float frictionMax = 9999.00f;
        /// <summary>
        /// Max Friction of an impact with a body part (not head, hands or feet) - to increase friction of slippy environment to get character to roll better.  Applied in catchFall and rollUp(rollDownStairs)
        /// </summary>
        [EuphoriaDetail("Max Friction of an impact with a body part (not head, hands or feet) - to increase friction of slippy environment to get character to roll better.  Applied in catchFall and rollUp(rollDownStairs)")]
        public float FrictionMax
        {
            get { return frictionMax; }
            set
            {

                SetArgument("frictionMax", value);
                frictionMax = value;
            }
        }

        private bool stopOnSlopes = false;
        /// <summary>
        /// Apply tactics to help stop on slopes.
        /// </summary>
        [EuphoriaDetail("Apply tactics to help stop on slopes.")]
        public bool StopOnSlopes
        {
            get { return stopOnSlopes; }
            set
            {

                SetArgument("stopOnSlopes", value);
                stopOnSlopes = value;
            }
        }

        private float stopManual = 0.00f;
        /// <summary>
        /// Override slope value to manually force stopping on flat ground.  Encourages character to come to rest face down or face up.
        /// </summary>
        [EuphoriaDetail("Override slope value to manually force stopping on flat ground.  Encourages character to come to rest face down or face up.")]
        public float StopManual
        {
            get { return stopManual; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("stopManual", value);
                stopManual = value;
            }
        }

        private float stoppedStrengthDecay = 5.00f;
        /// <summary>
        /// Speed at which strength reduces when stopped.
        /// </summary>
        [EuphoriaDetail("Speed at which strength reduces when stopped.")]
        public float StoppedStrengthDecay
        {
            get { return stoppedStrengthDecay; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("stoppedStrengthDecay", value);
                stoppedStrengthDecay = value;
            }
        }

        private float spineLean1Offset = 0.00f;
        /// <summary>
        /// Bias spine post towards hunched (away from arched).
        /// </summary>
        [EuphoriaDetail("Bias spine post towards hunched (away from arched).")]
        public float SpineLean1Offset
        {
            get { return spineLean1Offset; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("spineLean1Offset", value);
                spineLean1Offset = value;
            }
        }

        private bool riflePose = false;
        /// <summary>
        /// Hold rifle in a safe position to reduce complications with collision.  Only applied if holding a rifle
        /// </summary>
        [EuphoriaDetail("Hold rifle in a safe position to reduce complications with collision.  Only applied if holding a rifle")]
        public bool RiflePose
        {
            get { return riflePose; }
            set
            {

                SetArgument("riflePose", value);
                riflePose = value;
            }
        }

        private bool hkHeadAvoid = true;
        /// <summary>
        /// Enable head ground avoidance when handsAndKnees is true.
        /// </summary>
        [EuphoriaDetail("Enable head ground avoidance when handsAndKnees is true.")]
        public bool HkHeadAvoid
        {
            get { return hkHeadAvoid; }
            set
            {

                SetArgument("hkHeadAvoid", value);
                hkHeadAvoid = value;
            }
        }

        private bool antiPropClav = false;
        /// <summary>
        /// Discourage the character getting stuck propped up by elbows when falling backwards - by inhibiting backwards moving clavicles (keeps the arms slightly wider)
        /// </summary>
        [EuphoriaDetail("Discourage the character getting stuck propped up by elbows when falling backwards - by inhibiting backwards moving clavicles (keeps the arms slightly wider)")]
        public bool AntiPropClav
        {
            get { return antiPropClav; }
            set
            {

                SetArgument("antiPropClav", value);
                antiPropClav = value;
            }
        }

        private bool antiPropWeak = false;
        /// <summary>
        /// Discourage the character getting stuck propped up by elbows when falling backwards - by weakening the arms as soon they hit the floor.  (Also stops the hands lifting up when flat on back)
        /// </summary>
        [EuphoriaDetail("Discourage the character getting stuck propped up by elbows when falling backwards - by weakening the arms as soon they hit the floor.  (Also stops the hands lifting up when flat on back)")]
        public bool AntiPropWeak
        {
            get { return antiPropWeak; }
            set
            {

                SetArgument("antiPropWeak", value);
                antiPropWeak = value;
            }
        }

        private bool headAsWeakAsArms = true;
        /// <summary>
        /// Head weakens as arms weaken. If false and antiPropWeak when falls onto back doesn't loosen neck so early (matches bodyStrength instead)
        /// </summary>
        [EuphoriaDetail("Head weakens as arms weaken. If false and antiPropWeak when falls onto back doesn't loosen neck so early (matches bodyStrength instead)")]
        public bool HeadAsWeakAsArms
        {
            get { return headAsWeakAsArms; }
            set
            {

                SetArgument("headAsWeakAsArms", value);
                headAsWeakAsArms = value;
            }
        }

        private float successStrength = 1.00f;
        /// <summary>
        /// When bodyStrength is less than successStrength send a success feedback - DO NOT GO OUTSIDE MIN/MAX PARAMETER VALUES OTHERWISE NO SUCCESS FEEDBACK WILL BE SENT
        /// </summary>
        [EuphoriaDetail("When bodyStrength is less than successStrength send a success feedback - DO NOT GO OUTSIDE MIN/MAX PARAMETER VALUES OTHERWISE NO SUCCESS FEEDBACK WILL BE SENT")]
        public float SuccessStrength
        {
            get { return successStrength; }
            set
            {
                value = MathHelper.Clamp(value, 0.30f, 1.00f);
                SetArgument("successStrength", value);
                successStrength = value;
            }
        }


        public EuphoriaMessageSetFallingReaction(bool startNow) : base("setFallingReaction", startNow)
        { }

        public new void Reset()
        {
            handsAndKnees = false;
            callRDS = false;
            comVelRDSThresh = 2.00f;
            resistRolling = false;
            armReduceSpeed = 2.50f;
            reachLengthMultiplier = 1.00f;
            inhibitRollingTime = 0.20f;
            changeFrictionTime = 0.20f;
            groundFriction = 1.00f;
            frictionMin = 0.00f;
            frictionMax = 9999.00f;
            stopOnSlopes = false;
            stopManual = 0.00f;
            stoppedStrengthDecay = 5.00f;
            spineLean1Offset = 0.00f;
            riflePose = false;
            hkHeadAvoid = true;
            antiPropClav = false;
            antiPropWeak = false;
            headAsWeakAsArms = true;
            successStrength = 1.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// setCharacterUnderwater:  Sets viscosity applied to damping limbs
    /// </summary>
    [EuphoriaDetail("setCharacterUnderwater:  Sets viscosity applied to damping limbs")]
    internal class EuphoriaMessageSetCharacterUnderwater : EuphoriaMessage
    {
        private bool underwater = false;
        /// <summary>
        /// is character underwater?
        /// </summary>
        [EuphoriaDetail("is character underwater?")]
        public bool Underwater
        {
            get { return underwater; }
            set
            {

                SetArgument("underwater", value);
                underwater = value;
            }
        }

        private float viscosity = -1.00f;
        /// <summary>
        /// viscosity applied to character's parts
        /// </summary>
        [EuphoriaDetail("viscosity applied to character's parts")]
        public float Viscosity
        {
            get { return viscosity; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 100.00f);
                SetArgument("viscosity", value);
                viscosity = value;
            }
        }

        private float gravityFactor = 1.00f;
        /// <summary>
        /// gravity factor applied to character
        /// </summary>
        [EuphoriaDetail("gravity factor applied to character")]
        public float GravityFactor
        {
            get { return gravityFactor; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 10.00f);
                SetArgument("gravityFactor", value);
                gravityFactor = value;
            }
        }

        private float stroke = 0.00f;
        /// <summary>
        /// swimming force applied to character as a function of handVelocity and footVelocity
        /// </summary>
        [EuphoriaDetail("swimming force applied to character as a function of handVelocity and footVelocity")]
        public float Stroke
        {
            get { return stroke; }
            set
            {
                value = MathHelper.Clamp(value, -1000.00f, 1000.00f);
                SetArgument("stroke", value);
                stroke = value;
            }
        }

        private bool linearStroke = false;
        /// <summary>
        /// swimming force (linearStroke=true,False) = (f(v),f(v*v))
        /// </summary>
        [EuphoriaDetail("swimming force (linearStroke=true,False) = (f(v),f(v*v))")]
        public bool LinearStroke
        {
            get { return linearStroke; }
            set
            {

                SetArgument("linearStroke", value);
                linearStroke = value;
            }
        }


        public EuphoriaMessageSetCharacterUnderwater(bool startNow) : base("setCharacterUnderwater", startNow)
        { }

        public new void Reset()
        {
            underwater = false;
            viscosity = -1.00f;
            gravityFactor = 1.00f;
            stroke = 0.00f;
            linearStroke = false;
            base.Reset();
        }
    }


    /// <summary>
    /// setCharacterCollisions:
    /// </summary>
    [EuphoriaDetail("setCharacterCollisions:")]
    internal class EuphoriaMessageSetCharacterCollisions : EuphoriaMessage
    {
        private float spin = 0.00f;
        /// <summary>
        /// sliding friction turned into spin 80.0 (used in demo videos) good for rest of default params below.  If 0.0 then no collision enhancement
        /// </summary>
        [EuphoriaDetail("sliding friction turned into spin 80.0 (used in demo videos) good for rest of default params below.  If 0.0 then no collision enhancement")]
        public float Spin
        {
            get { return spin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("spin", value);
                spin = value;
            }
        }

        private float maxVelocity = 8.00f;
        /// <summary>
        /// torque = spin*(relative velocity) up to this maximum for relative velocity
        /// </summary>
        [EuphoriaDetail("torque = spin*(relative velocity) up to this maximum for relative velocity")]
        public float MaxVelocity
        {
            get { return maxVelocity; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("maxVelocity", value);
                maxVelocity = value;
            }
        }

        private bool applyToAll = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool ApplyToAll
        {
            get { return applyToAll; }
            set
            {

                SetArgument("applyToAll", value);
                applyToAll = value;
            }
        }

        private bool applyToSpine = true;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool ApplyToSpine
        {
            get { return applyToSpine; }
            set
            {

                SetArgument("applyToSpine", value);
                applyToSpine = value;
            }
        }

        private bool applyToThighs = true;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool ApplyToThighs
        {
            get { return applyToThighs; }
            set
            {

                SetArgument("applyToThighs", value);
                applyToThighs = value;
            }
        }

        private bool applyToClavicles = true;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool ApplyToClavicles
        {
            get { return applyToClavicles; }
            set
            {

                SetArgument("applyToClavicles", value);
                applyToClavicles = value;
            }
        }

        private bool applyToUpperArms = true;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool ApplyToUpperArms
        {
            get { return applyToUpperArms; }
            set
            {

                SetArgument("applyToUpperArms", value);
                applyToUpperArms = value;
            }
        }

        private bool footSlip = true;
        /// <summary>
        /// allow foot slipping if collided
        /// </summary>
        [EuphoriaDetail("allow foot slipping if collided")]
        public bool FootSlip
        {
            get { return footSlip; }
            set
            {

                SetArgument("footSlip", value);
                footSlip = value;
            }
        }

        private int vehicleClass = 15;
        /// <summary>
        /// ClassType of the object against which to enhance the collision.  All character vehicle interaction (e.g. braceForImpact glancing spins) relies on this value so EDIT WISELY. If it is used for things other than vehicles then NM should be informed.
        /// </summary>
        [EuphoriaDetail("ClassType of the object against which to enhance the collision.  All character vehicle interaction (e.g. braceForImpact glancing spins) relies on this value so EDIT WISELY. If it is used for things other than vehicles then NM should be informed.")]
        public int VehicleClass
        {
            get { return vehicleClass; }
            set
            {
                value = MathHelper.Clamp(value, 0, 100);
                SetArgument("vehicleClass", value);
                vehicleClass = value;
            }
        }


        public EuphoriaMessageSetCharacterCollisions(bool startNow) : base("setCharacterCollisions", startNow)
        { }

        public new void Reset()
        {
            spin = 0.00f;
            maxVelocity = 8.00f;
            applyToAll = false;
            applyToSpine = true;
            applyToThighs = true;
            applyToClavicles = true;
            applyToUpperArms = true;
            footSlip = true;
            vehicleClass = 15;
            base.Reset();
        }
    }


    /// <summary>
    /// setCharacterDamping:  Damp out cartwheeling and somersaulting above a certain threshold
    /// </summary>
    [EuphoriaDetail("setCharacterDamping:  Damp out cartwheeling and somersaulting above a certain threshold")]
    internal class EuphoriaMessageSetCharacterDamping : EuphoriaMessage
    {
        private float somersaultThresh = 34.00f;
        /// <summary>
        /// Somersault AngularMomentum measure above which we start damping - try 34.0.  Falling over straight backwards gives 54 on hitting ground.
        /// </summary>
        [EuphoriaDetail("Somersault AngularMomentum measure above which we start damping - try 34.0.  Falling over straight backwards gives 54 on hitting ground.")]
        public float SomersaultThresh
        {
            get { return somersaultThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 200.00f);
                SetArgument("somersaultThresh", value);
                somersaultThresh = value;
            }
        }

        private float somersaultDamp = 0.00f;
        /// <summary>
        /// Amount to damp somersaulting by (spinning around left/right axis) - try 0.45
        /// </summary>
        [EuphoriaDetail("Amount to damp somersaulting by (spinning around left/right axis) - try 0.45")]
        public float SomersaultDamp
        {
            get { return somersaultDamp; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("somersaultDamp", value);
                somersaultDamp = value;
            }
        }

        private float cartwheelThresh = 27.00f;
        /// <summary>
        /// Cartwheel AngularMomentum measure above which we start damping - try 27.0
        /// </summary>
        [EuphoriaDetail("Cartwheel AngularMomentum measure above which we start damping - try 27.0")]
        public float CartwheelThresh
        {
            get { return cartwheelThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 200.00f);
                SetArgument("cartwheelThresh", value);
                cartwheelThresh = value;
            }
        }

        private float cartwheelDamp = 0.00f;
        /// <summary>
        /// Amount to damp somersaulting by (spinning around front/back axis) - try 0.8
        /// </summary>
        [EuphoriaDetail("Amount to damp somersaulting by (spinning around front/back axis) - try 0.8")]
        public float CartwheelDamp
        {
            get { return cartwheelDamp; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("cartwheelDamp", value);
                cartwheelDamp = value;
            }
        }

        private float vehicleCollisionTime = 0.00f;
        /// <summary>
        /// Time after impact with a vehicle to apply characterDamping. -ve values mean always apply whether collided with vehicle or not. =0.0 never apply. =timestep apply for only that frame.  A typical roll from being hit by a car lasts about 4secs.
        /// </summary>
        [EuphoriaDetail("Time after impact with a vehicle to apply characterDamping. -ve values mean always apply whether collided with vehicle or not. =0.0 never apply. =timestep apply for only that frame.  A typical roll from being hit by a car lasts about 4secs.")]
        public float VehicleCollisionTime
        {
            get { return vehicleCollisionTime; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1000.00f);
                SetArgument("vehicleCollisionTime", value);
                vehicleCollisionTime = value;
            }
        }

        private bool v2 = false;
        /// <summary>
        /// If true damping is proportional to Angular momentum squared.  If false proportional to Angular momentum
        /// </summary>
        [EuphoriaDetail("If true damping is proportional to Angular momentum squared.  If false proportional to Angular momentum")]
        public bool V2
        {
            get { return v2; }
            set
            {

                SetArgument("v2", value);
                v2 = value;
            }
        }


        public EuphoriaMessageSetCharacterDamping(bool startNow) : base("setCharacterDamping", startNow)
        { }

        public new void Reset()
        {
            somersaultThresh = 34.00f;
            somersaultDamp = 0.00f;
            cartwheelThresh = 27.00f;
            cartwheelDamp = 0.00f;
            vehicleCollisionTime = 0.00f;
            v2 = false;
            base.Reset();
        }
    }


    /// <summary>
    /// setFrictionScale:
    /// </summary>
    [EuphoriaDetail("setFrictionScale:")]
    internal class EuphoriaMessageSetFrictionScale : EuphoriaMessage
    {
        private float scale = 1.00f;
        /// <summary>
        /// Friction scale to be applied to parts in mask.
        /// </summary>
        [EuphoriaDetail("Friction scale to be applied to parts in mask.")]
        public float Scale
        {
            get { return scale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("scale", value);
                scale = value;
            }
        }

        private float globalMin = 0.00f;
        /// <summary>
        /// Character-wide minimum impact friction. Affects all parts (not just those in mask).
        /// </summary>
        [EuphoriaDetail("Character-wide minimum impact friction. Affects all parts (not just those in mask).")]
        public float GlobalMin
        {
            get { return globalMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1000000.00f);
                SetArgument("globalMin", value);
                globalMin = value;
            }
        }

        private float globalMax = 999999.00f;
        /// <summary>
        /// Character-wide maximum impact friction. Affects all parts (not just those in mask).
        /// </summary>
        [EuphoriaDetail("Character-wide maximum impact friction. Affects all parts (not just those in mask).")]
        public float GlobalMax
        {
            get { return globalMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1000000.00f);
                SetArgument("globalMax", value);
                globalMax = value;
            }
        }

        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }


        public EuphoriaMessageSetFrictionScale(bool startNow) : base("setFrictionScale", startNow)
        { }

        public new void Reset()
        {
            scale = 1.00f;
            globalMin = 0.00f;
            globalMax = 999999.00f;
            mask = "fb";
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageAnimPose : EuphoriaMessage
    {
        private float muscleStiffness = -1.0f;
        /// <summary>
        /// muscleStiffness of masked joints. -values mean don't apply (just use defaults or ones applied by behaviours - safer if you are going to return to a behaviour)
        /// </summary>
        [EuphoriaDetail("muscleStiffness of masked joints. -values mean don't apply (just use defaults or ones applied by behaviours - safer if you are going to return to a behaviour)")]
        public float MuscleStiffness
        {
            get { return muscleStiffness; }
            set
            {
                value = MathHelper.Clamp(value, -1.10f, 10.00f);
                SetArgument("muscleStiffness", value);
                muscleStiffness = value;
            }
        }

        private float stiffness = -1.0f;
        /// <summary>
        /// stiffness of masked joints. -ve values mean don't apply stiffness or damping (just use defaults or ones applied by behaviours).  If you are using animpose fullbody on its own then this gives the opprtunity to use setStffness and setMuscleStiffness messages to set up the character's muscles. mmmmtodo get rid of this -ve
        /// </summary>
        [EuphoriaDetail("stiffness of masked joints. -ve values mean don't apply stiffness or damping (just use defaults or ones applied by behaviours).  If you are using animpose fullbody on its own then this gives the opprtunity to use setStffness and setMuscleStiffness messages to set up the character's muscles. mmmmtodo get rid of this -ve")]
        public float Stiffness
        {
            get { return stiffness; }
            set
            {
                value = MathHelper.Clamp(value, -1.10f, 16.00f);
                SetArgument("stiffness", value);
                stiffness = value;
            }
        }

        private float damping = 1.0f;
        /// <summary>
        /// damping of masked joints
        /// </summary>
        [EuphoriaDetail("damping of masked joints")]
        public float Damping
        {
            get { return damping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("damping", value);
                damping = value;
            }
        }

        private string effectorMask = "ub";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see notes for explanation)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see notes for explanation)")]
        public string EffectorMask
        {
            get { return effectorMask; }
            set
            {

                SetArgument("effectorMask", value);
                effectorMask = value;
            }
        }

        private bool overideHeadlook = false;
        /// <summary>
        /// overide Headlook behaviour (if animPose includes the head)
        /// </summary>
        [EuphoriaDetail("overide Headlook behaviour (if animPose includes the head)")]
        public bool OverideHeadlook
        {
            get { return overideHeadlook; }
            set
            {

                SetArgument("overideHeadlook", value);
                overideHeadlook = value;
            }
        }

        private bool overidePointArm = false;
        /// <summary>
        /// overide PointArm behaviour (if animPose includes the arm/arms)
        /// </summary>
        [EuphoriaDetail("overide PointArm behaviour (if animPose includes the arm/arms)")]
        public bool OveridePointArm
        {
            get { return overidePointArm; }
            set
            {

                SetArgument("overidePointArm", value);
                overidePointArm = value;
            }
        }

        private bool overidePointGun = false;
        /// <summary>
        /// overide PointGun behaviour (if animPose includes the arm/arms)//mmmmtodo not used at moment
        /// </summary>
        [EuphoriaDetail("overide PointGun behaviour (if animPose includes the arm/arms)//mmmmtodo not used at moment")]
        public bool OveridePointGun
        {
            get { return overidePointGun; }
            set
            {

                SetArgument("overidePointGun", value);
                overidePointGun = value;
            }
        }

        private bool useZMPGravityCompensation = true;
        /// <summary>
        /// If true then modify gravity compensation based on stance (can reduce gravity compensation to zero if cofm is outside of balance area)
        /// </summary>
        [EuphoriaDetail("If true then modify gravity compensation based on stance (can reduce gravity compensation to zero if cofm is outside of balance area)")]
        public bool UseZMPGravityCompensation
        {
            get { return useZMPGravityCompensation; }
            set
            {

                SetArgument("useZMPGravityCompensation", value);
                useZMPGravityCompensation = value;
            }
        }

        private float gravityCompensation = -1.0f;
        /// <summary>
        /// gravity compensation applied to joints in the effectorMask. If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("gravity compensation applied to joints in the effectorMask. If -ve then not applied (use current setting)")]
        public float GravityCompensation
        {
            get { return gravityCompensation; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 14.00f);
                SetArgument("gravityCompensation", value);
                gravityCompensation = value;
            }
        }

        private float muscleStiffnessLeftArm = -1.0f;
        /// <summary>
        /// muscle stiffness applied to left arm (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("muscle stiffness applied to left arm (applied after stiffness). If -ve then not applied (use current setting)")]
        public float MuscleStiffnessLeftArm
        {
            get { return muscleStiffnessLeftArm; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 10.00f);
                SetArgument("muscleStiffnessLeftArm", value);
                muscleStiffnessLeftArm = value;
            }
        }

        private float muscleStiffnessRightArm = -1.0f;
        /// <summary>
        /// muscle stiffness applied to right arm (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("muscle stiffness applied to right arm (applied after stiffness). If -ve then not applied (use current setting)")]
        public float MuscleStiffnessRightArm
        {
            get { return muscleStiffnessRightArm; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 10.00f);
                SetArgument("muscleStiffnessRightArm", value);
                muscleStiffnessRightArm = value;
            }
        }

        private float muscleStiffnessSpine = -1.0f;
        /// <summary>
        /// muscle stiffness applied to spine (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("muscle stiffness applied to spine (applied after stiffness). If -ve then not applied (use current setting)")]
        public float MuscleStiffnessSpine
        {
            get { return muscleStiffnessSpine; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 10.00f);
                SetArgument("muscleStiffnessSpine", value);
                muscleStiffnessSpine = value;
            }
        }

        private float muscleStiffnessLeftLeg = -1.0f;
        /// <summary>
        /// muscle stiffness applied to left leg (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("muscle stiffness applied to left leg (applied after stiffness). If -ve then not applied (use current setting)")]
        public float MuscleStiffnessLeftLeg
        {
            get { return muscleStiffnessLeftLeg; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 10.00f);
                SetArgument("muscleStiffnessLeftLeg", value);
                muscleStiffnessLeftLeg = value;
            }
        }

        private float muscleStiffnessRightLeg = -1.0f;
        /// <summary>
        /// muscle stiffness applied to right leg (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("muscle stiffness applied to right leg (applied after stiffness). If -ve then not applied (use current setting)")]
        public float MuscleStiffnessRightLeg
        {
            get { return muscleStiffnessRightLeg; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 10.00f);
                SetArgument("muscleStiffnessRightLeg", value);
                muscleStiffnessRightLeg = value;
            }
        }

        private float stiffnessLeftArm = -1.0f;
        /// <summary>
        /// stiffness  applied to left arm (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("stiffness  applied to left arm (applied after stiffness). If -ve then not applied (use current setting)")]
        public float StiffnessLeftArm
        {
            get { return stiffnessLeftArm; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 16.00f);
                SetArgument("stiffnessLeftArm", value);
                stiffnessLeftArm = value;
            }
        }

        private float stiffnessRightArm = -1.0f;
        /// <summary>
        /// stiffness applied to right arm (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("stiffness applied to right arm (applied after stiffness). If -ve then not applied (use current setting)")]
        public float StiffnessRightArm
        {
            get { return stiffnessRightArm; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 16.00f);
                SetArgument("stiffnessRightArm", value);
                stiffnessRightArm = value;
            }
        }

        private float stiffnessSpine = -1.0f;
        /// <summary>
        /// stiffness applied to spine (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("stiffness applied to spine (applied after stiffness). If -ve then not applied (use current setting)")]
        public float StiffnessSpine
        {
            get { return stiffnessSpine; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 16.00f);
                SetArgument("stiffnessSpine", value);
                stiffnessSpine = value;
            }
        }

        private float stiffnessLeftLeg = -1.0f;
        /// <summary>
        /// stiffness applied to left leg (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("stiffness applied to left leg (applied after stiffness). If -ve then not applied (use current setting)")]
        public float StiffnessLeftLeg
        {
            get { return stiffnessLeftLeg; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 16.00f);
                SetArgument("stiffnessLeftLeg", value);
                stiffnessLeftLeg = value;
            }
        }

        private float stiffnessRightLeg = -1.0f;
        /// <summary>
        /// stiffness applied to right leg (applied after stiffness). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("stiffness applied to right leg (applied after stiffness). If -ve then not applied (use current setting)")]
        public float StiffnessRightLeg
        {
            get { return stiffnessRightLeg; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 16.00f);
                SetArgument("stiffnessRightLeg", value);
                stiffnessRightLeg = value;
            }
        }

        private float dampingLeftArm = 1.0f;
        /// <summary>
        /// damping applied to left arm (applied after stiffness). If stiffness -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("damping applied to left arm (applied after stiffness). If stiffness -ve then not applied (use current setting)")]
        public float DampingLeftArm
        {
            get { return dampingLeftArm; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.00f);
                SetArgument("dampingLeftArm", value);
                dampingLeftArm = value;
            }
        }

        private float dampingRightArm = 1.0f;
        /// <summary>
        /// damping applied to right arm (applied after stiffness). If stiffness -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("damping applied to right arm (applied after stiffness). If stiffness -ve then not applied (use current setting)")]
        public float DampingRightArm
        {
            get { return dampingRightArm; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.00f);
                SetArgument("dampingRightArm", value);
                dampingRightArm = value;
            }
        }

        private float dampingSpine = 1.0f;
        /// <summary>
        /// damping applied to spine (applied after stiffness). If stiffness-ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("damping applied to spine (applied after stiffness). If stiffness-ve then not applied (use current setting)")]
        public float DampingSpine
        {
            get { return dampingSpine; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.00f);
                SetArgument("dampingSpine", value);
                dampingSpine = value;
            }
        }

        private float dampingLeftLeg = 1.0f;
        /// <summary>
        /// damping applied to left leg (applied after stiffness). If stiffness-ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("damping applied to left leg (applied after stiffness). If stiffness-ve then not applied (use current setting)")]
        public float DampingLeftLeg
        {
            get { return dampingLeftLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.00f);
                SetArgument("dampingLeftLeg", value);
                dampingLeftLeg = value;
            }
        }

        private float dampingRightLeg = 1.0f;
        /// <summary>
        /// damping applied to right leg (applied after stiffness). If stiffness -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("damping applied to right leg (applied after stiffness). If stiffness -ve then not applied (use current setting)")]
        public float DampingRightLeg
        {
            get { return dampingRightLeg; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.00f);
                SetArgument("dampingRightLeg", value);
                dampingRightLeg = value;
            }
        }

        private float gravCompLeftArm = -1.0f;
        /// <summary>
        /// gravity compensation applied to left arm (applied after gravityCompensation). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("gravity compensation applied to left arm (applied after gravityCompensation). If -ve then not applied (use current setting)")]
        public float GravCompLeftArm
        {
            get { return gravCompLeftArm; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 14.00f);
                SetArgument("gravCompLeftArm", value);
                gravCompLeftArm = value;
            }
        }

        private float gravCompRightArm = -1.0f;
        /// <summary>
        /// gravity compensation applied to right arm (applied after gravityCompensation). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("gravity compensation applied to right arm (applied after gravityCompensation). If -ve then not applied (use current setting)")]
        public float GravCompRightArm
        {
            get { return gravCompRightArm; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 14.00f);
                SetArgument("gravCompRightArm", value);
                gravCompRightArm = value;
            }
        }

        private float gravCompSpine = -1.0f;
        /// <summary>
        /// gravity compensation applied to spine (applied after gravityCompensation). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("gravity compensation applied to spine (applied after gravityCompensation). If -ve then not applied (use current setting)")]
        public float GravCompSpine
        {
            get { return gravCompSpine; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 14.00f);
                SetArgument("gravCompSpine", value);
                gravCompSpine = value;
            }
        }

        private float gravCompLeftLeg = -1.0f;
        /// <summary>
        /// gravity compensation applied to left leg (applied after gravityCompensation). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("gravity compensation applied to left leg (applied after gravityCompensation). If -ve then not applied (use current setting)")]
        public float GravCompLeftLeg
        {
            get { return gravCompLeftLeg; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 14.00f);
                SetArgument("gravCompLeftLeg", value);
                gravCompLeftLeg = value;
            }
        }

        private float gravCompRightLeg = -1.0f;
        /// <summary>
        /// gravity compensation applied to right leg (applied after gravityCompensation). If -ve then not applied (use current setting)
        /// </summary>
        [EuphoriaDetail("gravity compensation applied to right leg (applied after gravityCompensation). If -ve then not applied (use current setting)")]
        public float GravCompRightLeg
        {
            get { return gravCompRightLeg; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 14.00f);
                SetArgument("gravCompRightLeg", value);
                gravCompRightLeg = value;
            }
        }

        private int connectedLeftHand = 0;
        /// <summary>
        /// Is the left hand constrained to the world/ an object: -1=auto decide by impact info, 0=no, 1=part fully constrained (not implemented:, 2=part point constraint, 3=line constraint)
        /// </summary>
        [EuphoriaDetail("Is the left hand constrained to the world/ an object: -1=auto decide by impact info, 0=no, 1=part fully constrained (not implemented:, 2=part point constraint, 3=line constraint)")]
        public int ConnectedLeftHand
        {
            get { return connectedLeftHand; }
            set
            {
                value = MathHelper.Clamp(value, -1, 2);
                SetArgument("connectedLeftHand", value);
                connectedLeftHand = value;
            }
        }

        private int connectedRightHand = 0;
        /// <summary>
        /// Is the right hand constrained to the world/ an object: -1=auto decide by impact info, 0=no, 1=part fully constrained (not implemented:, 2=part point constraint, 3=line constraint)
        /// </summary>
        [EuphoriaDetail("Is the right hand constrained to the world/ an object: -1=auto decide by impact info, 0=no, 1=part fully constrained (not implemented:, 2=part point constraint, 3=line constraint)")]
        public int ConnectedRightHand
        {
            get { return connectedRightHand; }
            set
            {
                value = MathHelper.Clamp(value, -1, 2);
                SetArgument("connectedRightHand", value);
                connectedRightHand = value;
            }
        }

        private int connectedLeftFoot = -2;
        /// <summary>
        /// Is the left foot constrained to the world/ an object: -2=do not set in animpose (e.g. let the balancer decide), -1=auto decide by impact info, 0=no, 1=part fully constrained (not implemented:, 2=part point constraint, 3=line constraint)
        /// </summary>
        [EuphoriaDetail("Is the left foot constrained to the world/ an object: -2=do not set in animpose (e.g. let the balancer decide), -1=auto decide by impact info, 0=no, 1=part fully constrained (not implemented:, 2=part point constraint, 3=line constraint)")]
        public int ConnectedLeftFoot
        {
            get { return connectedLeftFoot; }
            set
            {
                value = MathHelper.Clamp(value, -2, 2);
                SetArgument("connectedLeftFoot", value);
                connectedLeftFoot = value;
            }
        }

        private int connectedRightFoot = -2;
        /// <summary>
        /// Is the right foot constrained to the world/ an object: -2=do not set in animpose (e.g. let the balancer decide),-1=auto decide by impact info, 0=no, 1=part fully constrained (not implemented:, 2=part point constraint, 3=line constraint)
        /// </summary>
        [EuphoriaDetail("Is the right foot constrained to the world/ an object: -2=do not set in animpose (e.g. let the balancer decide),-1=auto decide by impact info, 0=no, 1=part fully constrained (not implemented:, 2=part point constraint, 3=line constraint)")]
        public int ConnectedRightFoot
        {
            get { return connectedRightFoot; }
            set
            {
                value = MathHelper.Clamp(value, -2, 2);
                SetArgument("connectedRightFoot", value);
                connectedRightFoot = value;
            }
        }

        private int animSource;
        /// <summary>
        /// AnimSource 0 = CurrentItms, 1 = PreviousItms, 2 = AnimItms
        /// </summary>
        [EuphoriaDetail("AnimSource 0 = CurrentItms, 1 = PreviousItms, 2 = AnimItms")]
        public int AnimSource
        {
            get { return animSource; }
            set
            {

                SetArgument("animSource", value);
                animSource = value;
            }
        }

        private int dampenSideMotionInstanceIndex = -1;
        /// <summary>
        /// LevelIndex of object to dampen side motion relative to. -1 means not used.
        /// </summary>
        [EuphoriaDetail("LevelIndex of object to dampen side motion relative to. -1 means not used.")]
        public int DampenSideMotionInstanceIndex
        {
            get { return dampenSideMotionInstanceIndex; }
            set
            {

                SetArgument("dampenSideMotionInstanceIndex", value);
                dampenSideMotionInstanceIndex = value;
            }
        }


        public EuphoriaMessageAnimPose(bool startNow) : base("animPose", startNow)
        { }

        public new void Reset()
        {
            muscleStiffness = -1.0f;
            stiffness = -1.0f;
            damping = 1.0f;
            effectorMask = "ub";
            overideHeadlook = false;
            overidePointArm = false;
            overidePointGun = false;
            useZMPGravityCompensation = true;
            gravityCompensation = -1.0f;
            muscleStiffnessLeftArm = -1.0f;
            muscleStiffnessRightArm = -1.0f;
            muscleStiffnessSpine = -1.0f;
            muscleStiffnessLeftLeg = -1.0f;
            muscleStiffnessRightLeg = -1.0f;
            stiffnessLeftArm = -1.0f;
            stiffnessRightArm = -1.0f;
            stiffnessSpine = -1.0f;
            stiffnessLeftLeg = -1.0f;
            stiffnessRightLeg = -1.0f;
            dampingLeftArm = 1.0f;
            dampingRightArm = 1.0f;
            dampingSpine = 1.0f;
            dampingLeftLeg = 1.0f;
            dampingRightLeg = 1.0f;
            gravCompLeftArm = -1.0f;
            gravCompRightArm = -1.0f;
            gravCompSpine = -1.0f;
            gravCompLeftLeg = -1.0f;
            gravCompRightLeg = -1.0f;
            connectedLeftHand = 0;
            connectedRightHand = 0;
            connectedLeftFoot = -2;
            connectedRightFoot = -2;
            animSource = default(int);
            dampenSideMotionInstanceIndex = -1;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageArmsWindmill : EuphoriaMessage
    {
        private int leftPartID = 10;
        /// <summary>
        /// ID of part that the circle uses as local space for positioning
        /// </summary>
        [EuphoriaDetail("ID of part that the circle uses as local space for positioning")]
        public int LeftPartID
        {
            get { return leftPartID; }
            set
            {
                value = MathHelper.Clamp(value, 0, 21);
                SetArgument("leftPartID", value);
                leftPartID = value;
            }
        }

        private float leftRadius1 = 0.750f;
        /// <summary>
        /// radius for first axis of ellipse
        /// </summary>
        [EuphoriaDetail("radius for first axis of ellipse")]
        public float LeftRadius1
        {
            get { return leftRadius1; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("leftRadius1", value);
                leftRadius1 = value;
            }
        }

        private float leftRadius2 = 0.750f;
        /// <summary>
        /// radius for second axis of ellipse
        /// </summary>
        [EuphoriaDetail("radius for second axis of ellipse")]
        public float LeftRadius2
        {
            get { return leftRadius2; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("leftRadius2", value);
                leftRadius2 = value;
            }
        }

        private float leftSpeed = 1.00f;
        /// <summary>
        /// speed of target around the circle
        /// </summary>
        [EuphoriaDetail("speed of target around the circle")]
        public float LeftSpeed
        {
            get { return leftSpeed; }
            set
            {
                value = MathHelper.Clamp(value, -2.00f, 2.00f);
                SetArgument("leftSpeed", value);
                leftSpeed = value;
            }
        }

        private Vector3 leftNormal = new Vector3(0.00f, 0.20f, 0.20f);
        /// <summary>
        /// Euler Angles orientation of circle in space of part with part ID
        /// </summary>
        [EuphoriaDetail("Euler Angles orientation of circle in space of part with part ID")]
        public Vector3 LeftNormal
        {
            get { return leftNormal; }
            set
            {

                SetArgument("leftNormal", value);
                leftNormal = value;
            }
        }

        private Vector3 leftCentre = new Vector3(0.00f, 0.50f, -0.10f);
        /// <summary>
        /// centre of circle in the space of partID
        /// </summary>
        [EuphoriaDetail("centre of circle in the space of partID")]
        public Vector3 LeftCentre
        {
            get { return leftCentre; }
            set
            {

                SetArgument("leftCentre", value);
                leftCentre = value;
            }
        }

        private int rightPartID = 10;
        /// <summary>
        /// ID of part that the circle uses as local space for positioning
        /// </summary>
        [EuphoriaDetail("ID of part that the circle uses as local space for positioning")]
        public int RightPartID
        {
            get { return rightPartID; }
            set
            {
                value = MathHelper.Clamp(value, 0, 21);
                SetArgument("rightPartID", value);
                rightPartID = value;
            }
        }

        private float rightRadius1 = 0.750f;
        /// <summary>
        /// radius for first axis of ellipse
        /// </summary>
        [EuphoriaDetail("radius for first axis of ellipse")]
        public float RightRadius1
        {
            get { return rightRadius1; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("rightRadius1", value);
                rightRadius1 = value;
            }
        }

        private float rightRadius2 = 0.750f;
        /// <summary>
        /// radius for second axis of ellipse
        /// </summary>
        [EuphoriaDetail("radius for second axis of ellipse")]
        public float RightRadius2
        {
            get { return rightRadius2; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("rightRadius2", value);
                rightRadius2 = value;
            }
        }

        private float rightSpeed = 1.00f;
        /// <summary>
        /// speed of target around the circle
        /// </summary>
        [EuphoriaDetail("speed of target around the circle")]
        public float RightSpeed
        {
            get { return rightSpeed; }
            set
            {
                value = MathHelper.Clamp(value, -2.00f, 2.00f);
                SetArgument("rightSpeed", value);
                rightSpeed = value;
            }
        }

        private Vector3 rightNormal = new Vector3(0.00f, -0.20f, -0.20f);
        /// <summary>
        /// Euler Angles orientation of circle in space of part with part ID
        /// </summary>
        [EuphoriaDetail("Euler Angles orientation of circle in space of part with part ID")]
        public Vector3 RightNormal
        {
            get { return rightNormal; }
            set
            {

                SetArgument("rightNormal", value);
                rightNormal = value;
            }
        }

        private Vector3 rightCentre = new Vector3(0.00f, -0.50f, -0.10f);
        /// <summary>
        /// centre of circle in the space of partID
        /// </summary>
        [EuphoriaDetail("centre of circle in the space of partID")]
        public Vector3 RightCentre
        {
            get { return rightCentre; }
            set
            {

                SetArgument("rightCentre", value);
                rightCentre = value;
            }
        }

        private float shoulderStiffness = 12.00f;
        /// <summary>
        /// Stiffness applied to the shoulders
        /// </summary>
        [EuphoriaDetail("Stiffness applied to the shoulders")]
        public float ShoulderStiffness
        {
            get { return shoulderStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 1.00f, 16.00f);
                SetArgument("shoulderStiffness", value);
                shoulderStiffness = value;
            }
        }

        private float shoulderDamping = 1.00f;
        /// <summary>
        /// Damping applied to the shoulders
        /// </summary>
        [EuphoriaDetail("Damping applied to the shoulders")]
        public float ShoulderDamping
        {
            get { return shoulderDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("shoulderDamping", value);
                shoulderDamping = value;
            }
        }

        private float elbowStiffness = 12.00f;
        /// <summary>
        /// Stiffness applied to the elbows
        /// </summary>
        [EuphoriaDetail("Stiffness applied to the elbows")]
        public float ElbowStiffness
        {
            get { return elbowStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 1.00f, 16.00f);
                SetArgument("elbowStiffness", value);
                elbowStiffness = value;
            }
        }

        private float elbowDamping = 1.00f;
        /// <summary>
        /// Damping applied to the elbows
        /// </summary>
        [EuphoriaDetail("Damping applied to the elbows")]
        public float ElbowDamping
        {
            get { return elbowDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("elbowDamping", value);
                elbowDamping = value;
            }
        }

        private float leftElbowMin = 0.50f;
        /// <summary>
        /// Minimum left elbow bend
        /// </summary>
        [EuphoriaDetail("Minimum left elbow bend")]
        public float LeftElbowMin
        {
            get { return leftElbowMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.70f);
                SetArgument("leftElbowMin", value);
                leftElbowMin = value;
            }
        }

        private float rightElbowMin = 0.50f;
        /// <summary>
        /// Minimum right elbow bend
        /// </summary>
        [EuphoriaDetail("Minimum right elbow bend")]
        public float RightElbowMin
        {
            get { return rightElbowMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.70f);
                SetArgument("rightElbowMin", value);
                rightElbowMin = value;
            }
        }

        private float phaseOffset = 0.00f;
        /// <summary>
        /// phase offset(degrees) when phase synchronization is turned on.
        /// </summary>
        [EuphoriaDetail("phase offset(degrees) when phase synchronization is turned on.")]
        public float PhaseOffset
        {
            get { return phaseOffset; }
            set
            {
                value = MathHelper.Clamp(value, -360.00f, 360.00f);
                SetArgument("phaseOffset", value);
                phaseOffset = value;
            }
        }

        private float dragReduction = 0.20f;
        /// <summary>
        /// how much to compensate for movement of character/target
        /// </summary>
        [EuphoriaDetail("how much to compensate for movement of character/target")]
        public float DragReduction
        {
            get { return dragReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("dragReduction", value);
                dragReduction = value;
            }
        }

        private float iKtwist = 0.00f;
        /// <summary>
        /// angle of elbow around twist axis ?
        /// </summary>
        [EuphoriaDetail("angle of elbow around twist axis ?")]
        public float IKtwist
        {
            get { return iKtwist; }
            set
            {
                value = MathHelper.Clamp(value, -3.141593f, 3.141593f);
                SetArgument("IKtwist", value);
                IKtwist = value;
            }
        }

        private float angVelThreshold = 0.10f;
        /// <summary>
        /// value of character angular speed above which adaptive arm motion starts
        /// </summary>
        [EuphoriaDetail("value of character angular speed above which adaptive arm motion starts")]
        public float AngVelThreshold
        {
            get { return angVelThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("angVelThreshold", value);
                angVelThreshold = value;
            }
        }

        private float angVelGain = 1.00f;
        /// <summary>
        /// multiplies angular speed of character to get speed of arms
        /// </summary>
        [EuphoriaDetail("multiplies angular speed of character to get speed of arms")]
        public float AngVelGain
        {
            get { return angVelGain; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("angVelGain", value);
                angVelGain = value;
            }
        }

        private int mirrorMode = 1;
        /// <summary>
        /// 0: circle orientations are independent, 1: they mirror each other, 2: they're parallel (leftArm parmeters are used)
        /// </summary>
        [EuphoriaDetail("0: circle orientations are independent, 1: they mirror each other, 2: they're parallel (leftArm parmeters are used)")]
        public int MirrorMode
        {
            get { return mirrorMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("mirrorMode", value);
                mirrorMode = value;
            }
        }

        private int adaptiveMode = 0;
        /// <summary>
        /// 0:not adaptive, 1:only direction, 2: dir and speed, 3: dir, speed and strength
        /// </summary>
        [EuphoriaDetail("0:not adaptive, 1:only direction, 2: dir and speed, 3: dir, speed and strength")]
        public int AdaptiveMode
        {
            get { return adaptiveMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("adaptiveMode", value);
                adaptiveMode = value;
            }
        }

        private bool forceSync = true;
        /// <summary>
        /// toggles phase synchronization
        /// </summary>
        [EuphoriaDetail("toggles phase synchronization")]
        public bool ForceSync
        {
            get { return forceSync; }
            set
            {

                SetArgument("forceSync", value);
                forceSync = value;
            }
        }

        private bool useLeft = true;
        /// <summary>
        /// Use the left arm
        /// </summary>
        [EuphoriaDetail("Use the left arm")]
        public bool UseLeft
        {
            get { return useLeft; }
            set
            {

                SetArgument("useLeft", value);
                useLeft = value;
            }
        }

        private bool useRight = true;
        /// <summary>
        /// Use the right arm
        /// </summary>
        [EuphoriaDetail("Use the right arm")]
        public bool UseRight
        {
            get { return useRight; }
            set
            {

                SetArgument("useRight", value);
                useRight = value;
            }
        }

        private bool disableOnImpact = true;
        /// <summary>
        /// If true, each arm will stop windmilling if it hits the ground
        /// </summary>
        [EuphoriaDetail("If true, each arm will stop windmilling if it hits the ground")]
        public bool DisableOnImpact
        {
            get { return disableOnImpact; }
            set
            {

                SetArgument("disableOnImpact", value);
                disableOnImpact = value;
            }
        }


        public EuphoriaMessageArmsWindmill(bool startNow) : base("armsWindmill", startNow)
        { }

        public new void Reset()
        {
            leftPartID = 10;
            leftRadius1 = 0.750f;
            leftRadius2 = 0.750f;
            leftSpeed = 1.00f;
            leftNormal = new Vector3(0.00f, 0.20f, 0.20f);
            leftCentre = new Vector3(0.00f, 0.50f, -0.10f);
            rightPartID = 10;
            rightRadius1 = 0.750f;
            rightRadius2 = 0.750f;
            rightSpeed = 1.00f;
            rightNormal = new Vector3(0.00f, -0.20f, -0.20f);
            rightCentre = new Vector3(0.00f, -0.50f, -0.10f);
            shoulderStiffness = 12.00f;
            shoulderDamping = 1.00f;
            elbowStiffness = 12.00f;
            elbowDamping = 1.00f;
            leftElbowMin = 0.50f;
            rightElbowMin = 0.50f;
            phaseOffset = 0.00f;
            dragReduction = 0.20f;
            iKtwist = 0.00f;
            angVelThreshold = 0.10f;
            angVelGain = 1.00f;
            mirrorMode = 1;
            adaptiveMode = 0;
            forceSync = true;
            useLeft = true;
            useRight = true;
            disableOnImpact = true;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageArmsWindmillAdaptive : EuphoriaMessage
    {
        private float angSpeed = 6.280f;
        /// <summary>
        /// Controls the speed of the windmilling
        /// </summary>
        [EuphoriaDetail("Controls the speed of the windmilling")]
        public float AngSpeed
        {
            get { return angSpeed; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 10.0f);
                SetArgument("angSpeed", value);
                angSpeed = value;
            }
        }

        private float bodyStiffness = 11.000f;
        /// <summary>
        /// Controls how stiff the rest of the body is
        /// </summary>
        [EuphoriaDetail("Controls how stiff the rest of the body is")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private float amplitude = 0.600f;
        /// <summary>
        /// Controls how large the motion is, higher values means the character waves his arms in a massive arc
        /// </summary>
        [EuphoriaDetail("Controls how large the motion is, higher values means the character waves his arms in a massive arc")]
        public float Amplitude
        {
            get { return amplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("amplitude", value);
                amplitude = value;
            }
        }

        private float phase = 0.000f;
        /// <summary>
        /// Set to a non-zero value to desynchronise the left and right arms motion.
        /// </summary>
        [EuphoriaDetail("Set to a non-zero value to desynchronise the left and right arms motion.")]
        public float Phase
        {
            get { return phase; }
            set
            {
                value = MathHelper.Clamp(value, -4.0f, 8.0f);
                SetArgument("phase", value);
                phase = value;
            }
        }

        private float armStiffness = 14.140f;
        /// <summary>
        /// How stiff the arms are controls how pronounced the windmilling motion appears
        /// </summary>
        [EuphoriaDetail("How stiff the arms are controls how pronounced the windmilling motion appears")]
        public float ArmStiffness
        {
            get { return armStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("armStiffness", value);
                armStiffness = value;
            }
        }

        private float leftElbowAngle = -1.0f;
        /// <summary>
        /// If not negative then left arm will blend to this angle
        /// </summary>
        [EuphoriaDetail("If not negative then left arm will blend to this angle")]
        public float LeftElbowAngle
        {
            get { return leftElbowAngle; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 6.0f);
                SetArgument("leftElbowAngle", value);
                leftElbowAngle = value;
            }
        }

        private float rightElbowAngle = -1.0f;
        /// <summary>
        /// If not negative then right arm will blend to this angle
        /// </summary>
        [EuphoriaDetail("If not negative then right arm will blend to this angle")]
        public float RightElbowAngle
        {
            get { return rightElbowAngle; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 6.0f);
                SetArgument("rightElbowAngle", value);
                rightElbowAngle = value;
            }
        }

        private float lean1mult = 1.0f;
        /// <summary>
        /// 0 arms go up and down at the side. 1 circles. 0..1 elipse
        /// </summary>
        [EuphoriaDetail("0 arms go up and down at the side. 1 circles. 0..1 elipse")]
        public float Lean1mult
        {
            get { return lean1mult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("lean1mult", value);
                lean1mult = value;
            }
        }

        private float lean1offset = 0.0f;
        /// <summary>
        /// 0.f centre of circle at side.
        /// </summary>
        [EuphoriaDetail("0.f centre of circle at side.")]
        public float Lean1offset
        {
            get { return lean1offset; }
            set
            {
                value = MathHelper.Clamp(value, -6.0f, 6.0f);
                SetArgument("lean1offset", value);
                lean1offset = value;
            }
        }

        private float elbowRate = 1.0f;
        /// <summary>
        /// rate at which elbow tries to match *ElbowAngle
        /// </summary>
        [EuphoriaDetail("rate at which elbow tries to match *ElbowAngle")]
        public float ElbowRate
        {
            get { return elbowRate; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 6.0f);
                SetArgument("elbowRate", value);
                elbowRate = value;
            }
        }

        private int armDirection = 0;
        /// <summary>
        /// Arm circling direction.  -1 = Backwards, 0 = Adaptive, 1 = Forwards
        /// </summary>
        [EuphoriaDetail("Arm circling direction.  -1 = Backwards, 0 = Adaptive, 1 = Forwards")]
        public int ArmDirection
        {
            get { return armDirection; }
            set
            {
                value = MathHelper.Clamp(value, -1, 1);
                SetArgument("armDirection", value);
                armDirection = value;
            }
        }

        private bool disableOnImpact = true;
        /// <summary>
        /// If true, each arm will stop windmilling if it hits the ground
        /// </summary>
        [EuphoriaDetail("If true, each arm will stop windmilling if it hits the ground")]
        public bool DisableOnImpact
        {
            get { return disableOnImpact; }
            set
            {

                SetArgument("disableOnImpact", value);
                disableOnImpact = value;
            }
        }

        private bool setBackAngles = true;
        /// <summary>
        /// If true, back angles will be set to compliment arms windmill
        /// </summary>
        [EuphoriaDetail("If true, back angles will be set to compliment arms windmill")]
        public bool SetBackAngles
        {
            get { return setBackAngles; }
            set
            {

                SetArgument("setBackAngles", value);
                setBackAngles = value;
            }
        }

        private bool useAngMom = false;
        /// <summary>
        /// If true, use angular momentum about com to choose arm circling direction. Otherwise use com angular velocity
        /// </summary>
        [EuphoriaDetail("If true, use angular momentum about com to choose arm circling direction. Otherwise use com angular velocity")]
        public bool UseAngMom
        {
            get { return useAngMom; }
            set
            {

                SetArgument("useAngMom", value);
                useAngMom = value;
            }
        }

        private bool bendLeftElbow = false;
        /// <summary>
        /// If true, bend the left elbow to give a stuntman type scramble look
        /// </summary>
        [EuphoriaDetail("If true, bend the left elbow to give a stuntman type scramble look")]
        public bool BendLeftElbow
        {
            get { return bendLeftElbow; }
            set
            {

                SetArgument("bendLeftElbow", value);
                bendLeftElbow = value;
            }
        }

        private bool bendRightElbow = false;
        /// <summary>
        /// If true, bend the right elbow to give a stuntman type scramble look
        /// </summary>
        [EuphoriaDetail("If true, bend the right elbow to give a stuntman type scramble look")]
        public bool BendRightElbow
        {
            get { return bendRightElbow; }
            set
            {

                SetArgument("bendRightElbow", value);
                bendRightElbow = value;
            }
        }

        private string mask = "ub";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }


        public EuphoriaMessageArmsWindmillAdaptive(bool startNow) : base("armsWindmillAdaptive", startNow)
        { }

        public new void Reset()
        {
            angSpeed = 6.280f;
            bodyStiffness = 11.000f;
            amplitude = 0.600f;
            phase = 0.000f;
            armStiffness = 14.140f;
            leftElbowAngle = -1.0f;
            rightElbowAngle = -1.0f;
            lean1mult = 1.0f;
            lean1offset = 0.0f;
            elbowRate = 1.0f;
            armDirection = 0;
            disableOnImpact = true;
            setBackAngles = true;
            useAngMom = false;
            bendLeftElbow = false;
            bendRightElbow = false;
            mask = "ub";
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageBalancerCollisionsReaction : EuphoriaMessage
    {
        private int numStepsTillSlump = 4;
        /// <summary>
        /// Begin slump and stop stepping after this many steps
        /// </summary>
        [EuphoriaDetail("Begin slump and stop stepping after this many steps")]
        public int NumStepsTillSlump
        {
            get { return numStepsTillSlump; }
            set
            {

                SetArgument("numStepsTillSlump", value);
                numStepsTillSlump = value;
            }
        }

        private float stable2SlumpTime = 0.0f;
        /// <summary>
        /// Time after becoming stable leaning against a wall that slump starts
        /// </summary>
        [EuphoriaDetail("Time after becoming stable leaning against a wall that slump starts")]
        public float Stable2SlumpTime
        {
            get { return stable2SlumpTime; }
            set
            {

                SetArgument("stable2SlumpTime", value);
                stable2SlumpTime = value;
            }
        }

        private float exclusionZone = 0.2f;
        /// <summary>
        /// Steps are ihibited to not go closer to the wall than this (after impact).
        /// </summary>
        [EuphoriaDetail("Steps are ihibited to not go closer to the wall than this (after impact).")]
        public float ExclusionZone
        {
            get { return exclusionZone; }
            set
            {

                SetArgument("exclusionZone", value);
                exclusionZone = value;
            }
        }

        private float footFrictionMultStart = 1.0f;
        /// <summary>
        /// Friction multiplier applied to feet when slump starts
        /// </summary>
        [EuphoriaDetail("Friction multiplier applied to feet when slump starts")]
        public float FootFrictionMultStart
        {
            get { return footFrictionMultStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("footFrictionMultStart", value);
                footFrictionMultStart = value;
            }
        }

        private float footFrictionMultRate = 2.0f;
        /// <summary>
        /// Friction multiplier reduced by this amount every second after slump starts (only if character is not slumping)
        /// </summary>
        [EuphoriaDetail("Friction multiplier reduced by this amount every second after slump starts (only if character is not slumping)")]
        public float FootFrictionMultRate
        {
            get { return footFrictionMultRate; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 50.0f);
                SetArgument("footFrictionMultRate", value);
                footFrictionMultRate = value;
            }
        }

        private float backFrictionMultStart = 1.0f;
        /// <summary>
        /// Friction multiplier applied to back when slump starts
        /// </summary>
        [EuphoriaDetail("Friction multiplier applied to back when slump starts")]
        public float BackFrictionMultStart
        {
            get { return backFrictionMultStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("backFrictionMultStart", value);
                backFrictionMultStart = value;
            }
        }

        private float backFrictionMultRate = 2.0f;
        /// <summary>
        /// Friction multiplier reduced by this amount every second after slump starts (only if character is not slumping)
        /// </summary>
        [EuphoriaDetail("Friction multiplier reduced by this amount every second after slump starts (only if character is not slumping)")]
        public float BackFrictionMultRate
        {
            get { return backFrictionMultRate; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 50.0f);
                SetArgument("backFrictionMultRate", value);
                backFrictionMultRate = value;
            }
        }

        private float impactLegStiffReduction = 3.0f;
        /// <summary>
        /// Reduce the stiffness of the legs by this much as soon as an impact is detected
        /// </summary>
        [EuphoriaDetail("Reduce the stiffness of the legs by this much as soon as an impact is detected")]
        public float ImpactLegStiffReduction
        {
            get { return impactLegStiffReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("impactLegStiffReduction", value);
                impactLegStiffReduction = value;
            }
        }

        private float slumpLegStiffReduction = 1.0f;
        /// <summary>
        /// Reduce the stiffness of the legs by this much as soon as slump starts
        /// </summary>
        [EuphoriaDetail("Reduce the stiffness of the legs by this much as soon as slump starts")]
        public float SlumpLegStiffReduction
        {
            get { return slumpLegStiffReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("slumpLegStiffReduction", value);
                slumpLegStiffReduction = value;
            }
        }

        private float slumpLegStiffRate = 8.0f;
        /// <summary>
        /// Rate at which the stiffness of the legs is reduced during slump
        /// </summary>
        [EuphoriaDetail("Rate at which the stiffness of the legs is reduced during slump")]
        public float SlumpLegStiffRate
        {
            get { return slumpLegStiffRate; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 50.0f);
                SetArgument("slumpLegStiffRate", value);
                slumpLegStiffRate = value;
            }
        }

        private float reactTime = 0.3f;
        /// <summary>
        /// Time that the character reacts to the impact with ub flinch and writhe
        /// </summary>
        [EuphoriaDetail("Time that the character reacts to the impact with ub flinch and writhe")]
        public float ReactTime
        {
            get { return reactTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("reactTime", value);
                reactTime = value;
            }
        }

        private float impactExagTime = 0.3f;
        /// <summary>
        /// Time that the character exaggerates impact with spine
        /// </summary>
        [EuphoriaDetail("Time that the character exaggerates impact with spine")]
        public float ImpactExagTime
        {
            get { return impactExagTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("impactExagTime", value);
                impactExagTime = value;
            }
        }

        private float glanceSpinTime = 0.5f;
        /// <summary>
        /// Duration that the glance torque is applied for
        /// </summary>
        [EuphoriaDetail("Duration that the glance torque is applied for")]
        public float GlanceSpinTime
        {
            get { return glanceSpinTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("glanceSpinTime", value);
                glanceSpinTime = value;
            }
        }

        private float glanceSpinMag = 50.0f;
        /// <summary>
        /// Magnitude of the glance torque
        /// </summary>
        [EuphoriaDetail("Magnitude of the glance torque")]
        public float GlanceSpinMag
        {
            get { return glanceSpinMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1000.0f);
                SetArgument("glanceSpinMag", value);
                glanceSpinMag = value;
            }
        }

        private float glanceSpinDecayMult = 0.3f;
        /// <summary>
        /// multiplier used when decaying torque spin over time
        /// </summary>
        [EuphoriaDetail("multiplier used when decaying torque spin over time")]
        public float GlanceSpinDecayMult
        {
            get { return glanceSpinDecayMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("glanceSpinDecayMult", value);
                glanceSpinDecayMult = value;
            }
        }

        private int ignoreColWithIndex = -2;
        /// <summary>
        /// used so impact with the character that is pushing you over doesn't set off the behaviour
        /// </summary>
        [EuphoriaDetail("used so impact with the character that is pushing you over doesn't set off the behaviour")]
        public int IgnoreColWithIndex
        {
            get { return ignoreColWithIndex; }
            set
            {

                SetArgument("ignoreColWithIndex", value);
                ignoreColWithIndex = value;
            }
        }

        private int slumpMode = 1;
        /// <summary>
        /// 0=Normal slump(less movement then slump and movement LT small), 1=fast slump, 2=less movement then slump
        /// </summary>
        [EuphoriaDetail("0=Normal slump(less movement then slump and movement LT small), 1=fast slump, 2=less movement then slump")]
        public int SlumpMode
        {
            get { return slumpMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("slumpMode", value);
                slumpMode = value;
            }
        }

        private int reboundMode = 0;
        /// <summary>
        /// 0=fall2knees/slump if shot not running, 1=stumble, 2=slump, 3=restart
        /// </summary>
        [EuphoriaDetail("0=fall2knees/slump if shot not running, 1=stumble, 2=slump, 3=restart")]
        public int ReboundMode
        {
            get { return reboundMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("reboundMode", value);
                reboundMode = value;
            }
        }

        private float ignoreColMassBelow = 20.0f;
        /// <summary>
        /// collisions with non-fixed objects with mass below this will not set this behaviour off (e.g. ignore guns)
        /// </summary>
        [EuphoriaDetail("collisions with non-fixed objects with mass below this will not set this behaviour off (e.g. ignore guns)")]
        public float IgnoreColMassBelow
        {
            get { return ignoreColMassBelow; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1000.0f);
                SetArgument("ignoreColMassBelow", value);
                ignoreColMassBelow = value;
            }
        }

        private int forwardMode = 0;
        /// <summary>
        /// 0=slump, 1=fallToKnees if shot is running, otherwise slump
        /// </summary>
        [EuphoriaDetail("0=slump, 1=fallToKnees if shot is running, otherwise slump")]
        public int ForwardMode
        {
            get { return forwardMode; }
            set
            {
                value = MathHelper.Clamp(value, 0, 1);
                SetArgument("forwardMode", value);
                forwardMode = value;
            }
        }

        private float timeToForward = 0.50f;
        /// <summary>
        /// time after a forwards impact before forwardMode is called (leave sometime for a rebound or brace - the min of 0.1 is to ensure fallOverWall can start although it probably needs only 1or2 frames for the probes to return)
        /// </summary>
        [EuphoriaDetail("time after a forwards impact before forwardMode is called (leave sometime for a rebound or brace - the min of 0.1 is to ensure fallOverWall can start although it probably needs only 1or2 frames for the probes to return)")]
        public float TimeToForward
        {
            get { return timeToForward; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 2.00f);
                SetArgument("timeToForward", value);
                timeToForward = value;
            }
        }

        private float reboundForce = 0.00f;
        /// <summary>
        /// if forwards impact only: cheat force to try to get the character away from the wall.  3 is a good value.
        /// </summary>
        [EuphoriaDetail("if forwards impact only: cheat force to try to get the character away from the wall.  3 is a good value.")]
        public float ReboundForce
        {
            get { return reboundForce; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("reboundForce", value);
                reboundForce = value;
            }
        }

        private bool braceWall = true;
        /// <summary>
        /// Brace against wall if forwards impact(at the moment only if bodyBalance is running/in charge of arms)
        /// </summary>
        [EuphoriaDetail("Brace against wall if forwards impact(at the moment only if bodyBalance is running/in charge of arms)")]
        public bool BraceWall
        {
            get { return braceWall; }
            set
            {

                SetArgument("braceWall", value);
                braceWall = value;
            }
        }

        private float ignoreColVolumeBelow = 0.1f;
        /// <summary>
        /// collisions with non-fixed objects with volume below this will not set this behaviour off
        /// </summary>
        [EuphoriaDetail("collisions with non-fixed objects with volume below this will not set this behaviour off")]
        public float IgnoreColVolumeBelow
        {
            get { return ignoreColVolumeBelow; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1000.0f);
                SetArgument("ignoreColVolumeBelow", value);
                ignoreColVolumeBelow = value;
            }
        }

        private bool fallOverWallDrape = true;
        /// <summary>
        /// use fallOverWall as the main drape reaction
        /// </summary>
        [EuphoriaDetail("use fallOverWall as the main drape reaction")]
        public bool FallOverWallDrape
        {
            get { return fallOverWallDrape; }
            set
            {

                SetArgument("fallOverWallDrape", value);
                fallOverWallDrape = value;
            }
        }

        private bool fallOverHighWalls = false;
        /// <summary>
        /// trigger fall over wall if hit up to spine2 else only if hit up to spine1
        /// </summary>
        [EuphoriaDetail("trigger fall over wall if hit up to spine2 else only if hit up to spine1")]
        public bool FallOverHighWalls
        {
            get { return fallOverHighWalls; }
            set
            {

                SetArgument("fallOverHighWalls", value);
                fallOverHighWalls = value;
            }
        }

        private bool snap = false;
        /// <summary>
        /// Add a Snap to when you hit a wall to emphasize the hit.
        /// </summary>
        [EuphoriaDetail("Add a Snap to when you hit a wall to emphasize the hit.")]
        public bool Snap
        {
            get { return snap; }
            set
            {

                SetArgument("snap", value);
                snap = value;
            }
        }

        private float snapMag = -0.60f;
        /// <summary>
        /// The magnitude of the snap reaction
        /// </summary>
        [EuphoriaDetail("The magnitude of the snap reaction")]
        public float SnapMag
        {
            get { return snapMag; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 10.0f);
                SetArgument("snapMag", value);
                snapMag = value;
            }
        }

        private float snapDirectionRandomness = 0.30f;
        /// <summary>
        /// The character snaps in a prescribed way (decided by bullet direction) - Higher the value the more random this direction is.
        /// </summary>
        [EuphoriaDetail("The character snaps in a prescribed way (decided by bullet direction) - Higher the value the more random this direction is.")]
        public float SnapDirectionRandomness
        {
            get { return snapDirectionRandomness; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("snapDirectionRandomness", value);
                snapDirectionRandomness = value;
            }
        }

        private bool snapLeftArm = false;
        /// <summary>
        /// snap the leftArm.
        /// </summary>
        [EuphoriaDetail("snap the leftArm.")]
        public bool SnapLeftArm
        {
            get { return snapLeftArm; }
            set
            {

                SetArgument("snapLeftArm", value);
                snapLeftArm = value;
            }
        }

        private bool snapRightArm = false;
        /// <summary>
        /// snap the rightArm.
        /// </summary>
        [EuphoriaDetail("snap the rightArm.")]
        public bool SnapRightArm
        {
            get { return snapRightArm; }
            set
            {

                SetArgument("snapRightArm", value);
                snapRightArm = value;
            }
        }

        private bool snapLeftLeg = false;
        /// <summary>
        /// snap the leftLeg.
        /// </summary>
        [EuphoriaDetail("snap the leftLeg.")]
        public bool SnapLeftLeg
        {
            get { return snapLeftLeg; }
            set
            {

                SetArgument("snapLeftLeg", value);
                snapLeftLeg = value;
            }
        }

        private bool snapRightLeg = false;
        /// <summary>
        /// snap the rightLeg.
        /// </summary>
        [EuphoriaDetail("snap the rightLeg.")]
        public bool SnapRightLeg
        {
            get { return snapRightLeg; }
            set
            {

                SetArgument("snapRightLeg", value);
                snapRightLeg = value;
            }
        }

        private bool snapSpine = true;
        /// <summary>
        /// snap the spine.
        /// </summary>
        [EuphoriaDetail("snap the spine.")]
        public bool SnapSpine
        {
            get { return snapSpine; }
            set
            {

                SetArgument("snapSpine", value);
                snapSpine = value;
            }
        }

        private bool snapNeck = true;
        /// <summary>
        /// snap the neck.
        /// </summary>
        [EuphoriaDetail("snap the neck.")]
        public bool SnapNeck
        {
            get { return snapNeck; }
            set
            {

                SetArgument("snapNeck", value);
                snapNeck = value;
            }
        }

        private bool snapPhasedLegs = true;
        /// <summary>
        /// Legs are either in phase with each other or not
        /// </summary>
        [EuphoriaDetail("Legs are either in phase with each other or not")]
        public bool SnapPhasedLegs
        {
            get { return snapPhasedLegs; }
            set
            {

                SetArgument("snapPhasedLegs", value);
                snapPhasedLegs = value;
            }
        }

        private int snapHipType = 0;
        /// <summary>
        /// type of hip reaction 0=none, 1=side2side 2=steplike
        /// </summary>
        [EuphoriaDetail("type of hip reaction 0=none, 1=side2side 2=steplike")]
        public int SnapHipType
        {
            get { return snapHipType; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("snapHipType", value);
                snapHipType = value;
            }
        }

        private float unSnapInterval = 0.010f;
        /// <summary>
        /// Interval before applying reverse snap
        /// </summary>
        [EuphoriaDetail("Interval before applying reverse snap")]
        public float UnSnapInterval
        {
            get { return unSnapInterval; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.0f);
                SetArgument("unSnapInterval", value);
                unSnapInterval = value;
            }
        }

        private float unSnapRatio = 0.70f;
        /// <summary>
        /// The magnitude of the reverse snap
        /// </summary>
        [EuphoriaDetail("The magnitude of the reverse snap")]
        public float UnSnapRatio
        {
            get { return unSnapRatio; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.0f);
                SetArgument("unSnapRatio", value);
                unSnapRatio = value;
            }
        }

        private bool snapUseTorques = true;
        /// <summary>
        /// use torques to make the snap otherwise use a change in the parts angular velocity
        /// </summary>
        [EuphoriaDetail("use torques to make the snap otherwise use a change in the parts angular velocity")]
        public bool SnapUseTorques
        {
            get { return snapUseTorques; }
            set
            {

                SetArgument("snapUseTorques", value);
                snapUseTorques = value;
            }
        }

        private float impactWeaknessZeroDuration = 0.20f;
        /// <summary>
        /// duration for which the character's upper body stays at minimum stiffness (not quite zero)
        /// </summary>
        [EuphoriaDetail("duration for which the character's upper body stays at minimum stiffness (not quite zero)")]
        public float ImpactWeaknessZeroDuration
        {
            get { return impactWeaknessZeroDuration; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("impactWeaknessZeroDuration", value);
                impactWeaknessZeroDuration = value;
            }
        }

        private float impactWeaknessRampDuration = 0.010f;
        /// <summary>
        /// duration of the ramp to bring the character's upper body stiffness back to normal levels
        /// </summary>
        [EuphoriaDetail("duration of the ramp to bring the character's upper body stiffness back to normal levels")]
        public float ImpactWeaknessRampDuration
        {
            get { return impactWeaknessRampDuration; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 10.00f);
                SetArgument("impactWeaknessRampDuration", value);
                impactWeaknessRampDuration = value;
            }
        }

        private float impactLoosenessAmount = 1.00f;
        /// <summary>
        /// how loose the character is on impact. between 0 and 1
        /// </summary>
        [EuphoriaDetail("how loose the character is on impact. between 0 and 1")]
        public float ImpactLoosenessAmount
        {
            get { return impactLoosenessAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("impactLoosenessAmount", value);
                impactLoosenessAmount = value;
            }
        }

        private bool objectBehindVictim = false;
        /// <summary>
        /// detected an object behind a shot victim in the direction of a bullet?
        /// </summary>
        [EuphoriaDetail("detected an object behind a shot victim in the direction of a bullet?")]
        public bool ObjectBehindVictim
        {
            get { return objectBehindVictim; }
            set
            {

                SetArgument("objectBehindVictim", value);
                objectBehindVictim = value;
            }
        }

        private Vector3 objectBehindVictimPos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// the intersection pos of a detected object behind a shot victim in the direction of a bullet
        /// </summary>
        [EuphoriaDetail("the intersection pos of a detected object behind a shot victim in the direction of a bullet")]
        public Vector3 ObjectBehindVictimPos
        {
            get { return objectBehindVictimPos; }
            set
            {

                SetArgument("objectBehindVictimPos", value);
                objectBehindVictimPos = value;
            }
        }

        private Vector3 objectBehindVictimNormal = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// the normal of a detected object behind a shot victim in the direction of a bullet
        /// </summary>
        [EuphoriaDetail("the normal of a detected object behind a shot victim in the direction of a bullet")]
        public Vector3 ObjectBehindVictimNormal
        {
            get { return objectBehindVictimNormal; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -1.00f, 1.00f);
                value.Y = MathHelper.Clamp(value.Y, -1.00f, 1.00f);
                value.Z = MathHelper.Clamp(value.Z, -1.00f, 1.00f);
                SetArgument("objectBehindVictimNormal", value);
                objectBehindVictimNormal = value;
            }
        }


        public EuphoriaMessageBalancerCollisionsReaction(bool startNow) : base("balancerCollisionsReaction", startNow)
        { }

        public new void Reset()
        {
            numStepsTillSlump = 4;
            stable2SlumpTime = 0.0f;
            exclusionZone = 0.2f;
            footFrictionMultStart = 1.0f;
            footFrictionMultRate = 2.0f;
            backFrictionMultStart = 1.0f;
            backFrictionMultRate = 2.0f;
            impactLegStiffReduction = 3.0f;
            slumpLegStiffReduction = 1.0f;
            slumpLegStiffRate = 8.0f;
            reactTime = 0.3f;
            impactExagTime = 0.3f;
            glanceSpinTime = 0.5f;
            glanceSpinMag = 50.0f;
            glanceSpinDecayMult = 0.3f;
            ignoreColWithIndex = -2;
            slumpMode = 1;
            reboundMode = 0;
            ignoreColMassBelow = 20.0f;
            forwardMode = 0;
            timeToForward = 0.50f;
            reboundForce = 0.00f;
            braceWall = true;
            ignoreColVolumeBelow = 0.1f;
            fallOverWallDrape = true;
            fallOverHighWalls = false;
            snap = false;
            snapMag = -0.60f;
            snapDirectionRandomness = 0.30f;
            snapLeftArm = false;
            snapRightArm = false;
            snapLeftLeg = false;
            snapRightLeg = false;
            snapSpine = true;
            snapNeck = true;
            snapPhasedLegs = true;
            snapHipType = 0;
            unSnapInterval = 0.010f;
            unSnapRatio = 0.70f;
            snapUseTorques = true;
            impactWeaknessZeroDuration = 0.20f;
            impactWeaknessRampDuration = 0.010f;
            impactLoosenessAmount = 1.00f;
            objectBehindVictim = false;
            objectBehindVictimPos = new Vector3(0f, 0f, 0f);
            objectBehindVictimNormal = new Vector3(0f, 0f, 0f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageBodyBalance : EuphoriaMessage
    {
        private float armStiffness = 9.0f;
        /// <summary>
        /// NB. WAS m_bodyStiffness ClaviclesStiffness=9.0f
        /// </summary>
        [EuphoriaDetail("NB. WAS m_bodyStiffness ClaviclesStiffness=9.0f")]
        public float ArmStiffness
        {
            get { return armStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("armStiffness", value);
                armStiffness = value;
            }
        }

        private float elbow = 0.9f;
        /// <summary>
        /// How much the elbow swings based on the leg movement
        /// </summary>
        [EuphoriaDetail("How much the elbow swings based on the leg movement")]
        public float Elbow
        {
            get { return elbow; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("elbow", value);
                elbow = value;
            }
        }

        private float shoulder = 1.00f;
        /// <summary>
        /// How much the shoulder(lean1) swings based on the leg movement
        /// </summary>
        [EuphoriaDetail("How much the shoulder(lean1) swings based on the leg movement")]
        public float Shoulder
        {
            get { return shoulder; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("shoulder", value);
                shoulder = value;
            }
        }

        private float armDamping = 0.7f;
        /// <summary>
        /// NB. WAS m_damping NeckDamping=1 ClaviclesDamping=1
        /// </summary>
        [EuphoriaDetail("NB. WAS m_damping NeckDamping=1 ClaviclesDamping=1")]
        public float ArmDamping
        {
            get { return armDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armDamping", value);
                armDamping = value;
            }
        }

        private bool useHeadLook = false;
        /// <summary>
        /// enable and provide a look-at target to make the character's head turn to face it while balancing
        /// </summary>
        [EuphoriaDetail("enable and provide a look-at target to make the character's head turn to face it while balancing")]
        public bool UseHeadLook
        {
            get { return useHeadLook; }
            set
            {

                SetArgument("useHeadLook", value);
                useHeadLook = value;
            }
        }

        private Vector3 headLookPos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position of thing to look at
        /// </summary>
        [EuphoriaDetail("position of thing to look at")]
        public Vector3 HeadLookPos
        {
            get { return headLookPos; }
            set
            {

                SetArgument("headLookPos", value);
                headLookPos = value;
            }
        }

        private int headLookInstanceIndex = -1;
        /// <summary>
        /// level index of thing to look at
        /// </summary>
        [EuphoriaDetail("level index of thing to look at")]
        public int HeadLookInstanceIndex
        {
            get { return headLookInstanceIndex; }
            set
            {

                SetArgument("headLookInstanceIndex", value);
                headLookInstanceIndex = value;
            }
        }

        private float spineStiffness = 10.0f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float SpineStiffness
        {
            get { return spineStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("spineStiffness", value);
                spineStiffness = value;
            }
        }

        private float somersaultAngle = 1.0f;
        /// <summary>
        /// multiplier of the somersault 'angle' (lean forward/back) for arms out (lean2)
        /// </summary>
        [EuphoriaDetail("multiplier of the somersault 'angle' (lean forward/back) for arms out (lean2)")]
        public float SomersaultAngle
        {
            get { return somersaultAngle; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("somersaultAngle", value);
                somersaultAngle = value;
            }
        }

        private float somersaultAngleThreshold = 0.25f;
        /// <summary>
        /// Amount of somersault 'angle' before m_somersaultAngle is used for ArmsOut. Unless drunk - DO NOT EXCEED 0.8
        /// </summary>
        [EuphoriaDetail("Amount of somersault 'angle' before m_somersaultAngle is used for ArmsOut. Unless drunk - DO NOT EXCEED 0.8")]
        public float SomersaultAngleThreshold
        {
            get { return somersaultAngleThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("somersaultAngleThreshold", value);
                somersaultAngleThreshold = value;
            }
        }

        private float sideSomersaultAngle = 1.0f;
        /// <summary>
        /// Amount of side somersault 'angle' before sideSomersault is used for ArmsOut. Unless drunk - DO NOT EXCEED 0.8
        /// </summary>
        [EuphoriaDetail("Amount of side somersault 'angle' before sideSomersault is used for ArmsOut. Unless drunk - DO NOT EXCEED 0.8")]
        public float SideSomersaultAngle
        {
            get { return sideSomersaultAngle; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("sideSomersaultAngle", value);
                sideSomersaultAngle = value;
            }
        }

        private float sideSomersaultAngleThreshold = 0.25f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float SideSomersaultAngleThreshold
        {
            get { return sideSomersaultAngleThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("sideSomersaultAngleThreshold", value);
                sideSomersaultAngleThreshold = value;
            }
        }

        private bool backwardsAutoTurn = false;
        /// <summary>
        /// Automatically turn around if moving backwards
        /// </summary>
        [EuphoriaDetail("Automatically turn around if moving backwards")]
        public bool BackwardsAutoTurn
        {
            get { return backwardsAutoTurn; }
            set
            {

                SetArgument("backwardsAutoTurn", value);
                backwardsAutoTurn = value;
            }
        }

        private float turnWithBumpRadius = -1.00f;
        /// <summary>
        /// 0.9 is a sensible value.  If pusher within this distance then turn to get out of the way of the pusher
        /// </summary>
        [EuphoriaDetail("0.9 is a sensible value.  If pusher within this distance then turn to get out of the way of the pusher")]
        public float TurnWithBumpRadius
        {
            get { return turnWithBumpRadius; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 10.00f);
                SetArgument("turnWithBumpRadius", value);
                turnWithBumpRadius = value;
            }
        }

        private bool backwardsArms = false;
        /// <summary>
        /// Bend elbows, relax shoulders and inhibit spine twist when moving backwards
        /// </summary>
        [EuphoriaDetail("Bend elbows, relax shoulders and inhibit spine twist when moving backwards")]
        public bool BackwardsArms
        {
            get { return backwardsArms; }
            set
            {

                SetArgument("backwardsArms", value);
                backwardsArms = value;
            }
        }

        private bool blendToZeroPose = false;
        /// <summary>
        /// Blend upper body to zero pose as the character comes to rest. If false blend to a stored pose
        /// </summary>
        [EuphoriaDetail("Blend upper body to zero pose as the character comes to rest. If false blend to a stored pose")]
        public bool BlendToZeroPose
        {
            get { return blendToZeroPose; }
            set
            {

                SetArgument("blendToZeroPose", value);
                blendToZeroPose = value;
            }
        }

        private bool armsOutOnPush = true;
        /// <summary>
        /// Put arms out based on lean2 of legs, or angular velocity (lean or twist), or lean (front/back or side/side)
        /// </summary>
        [EuphoriaDetail("Put arms out based on lean2 of legs, or angular velocity (lean or twist), or lean (front/back or side/side)")]
        public bool ArmsOutOnPush
        {
            get { return armsOutOnPush; }
            set
            {

                SetArgument("armsOutOnPush", value);
                armsOutOnPush = value;
            }
        }

        private float armsOutOnPushMultiplier = 1.0f;
        /// <summary>
        /// Arms out based on lean2 of the legs to simulate being pushed
        /// </summary>
        [EuphoriaDetail("Arms out based on lean2 of the legs to simulate being pushed")]
        public float ArmsOutOnPushMultiplier
        {
            get { return armsOutOnPushMultiplier; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armsOutOnPushMultiplier", value);
                armsOutOnPushMultiplier = value;
            }
        }

        private float armsOutOnPushTimeout = 1.1f;
        /// <summary>
        /// number of seconds before turning off the armsOutOnPush response only for Arms out based on lean2 of the legs (NOT for the angle or angular velocity)
        /// </summary>
        [EuphoriaDetail("number of seconds before turning off the armsOutOnPush response only for Arms out based on lean2 of the legs (NOT for the angle or angular velocity)")]
        public float ArmsOutOnPushTimeout
        {
            get { return armsOutOnPushTimeout; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armsOutOnPushTimeout", value);
                armsOutOnPushTimeout = value;
            }
        }

        private float returningToBalanceArmsOut = 0.0f;
        /// <summary>
        /// range 0:1 0 = don't raise arms if returning to upright position, 0.x = 0.x*raise arms based on angvel and 'angle' settings, 1 = raise arms based on angvel and 'angle' settings
        /// </summary>
        [EuphoriaDetail("range 0:1 0 = don't raise arms if returning to upright position, 0.x = 0.x*raise arms based on angvel and 'angle' settings, 1 = raise arms based on angvel and 'angle' settings")]
        public float ReturningToBalanceArmsOut
        {
            get { return returningToBalanceArmsOut; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("returningToBalanceArmsOut", value);
                returningToBalanceArmsOut = value;
            }
        }

        private float armsOutStraightenElbows = 0.0f;
        /// <summary>
        /// multiplier for straightening the elbows based on the amount of arms out(lean2) 0 = dont straighten elbows. Otherwise straighten elbows proportionately to armsOut
        /// </summary>
        [EuphoriaDetail("multiplier for straightening the elbows based on the amount of arms out(lean2) 0 = dont straighten elbows. Otherwise straighten elbows proportionately to armsOut")]
        public float ArmsOutStraightenElbows
        {
            get { return armsOutStraightenElbows; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("armsOutStraightenElbows", value);
                armsOutStraightenElbows = value;
            }
        }

        private float armsOutMinLean2 = -9.9f;
        /// <summary>
        /// Minimum desiredLean2 applied to shoulder (to stop arms going above shoulder height or not)
        /// </summary>
        [EuphoriaDetail("Minimum desiredLean2 applied to shoulder (to stop arms going above shoulder height or not)")]
        public float ArmsOutMinLean2
        {
            get { return armsOutMinLean2; }
            set
            {
                value = MathHelper.Clamp(value, -10.0f, 0.0f);
                SetArgument("armsOutMinLean2", value);
                armsOutMinLean2 = value;
            }
        }

        private float spineDamping = 1.0f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float SpineDamping
        {
            get { return spineDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("spineDamping", value);
                spineDamping = value;
            }
        }

        private bool useBodyTurn = true;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool UseBodyTurn
        {
            get { return useBodyTurn; }
            set
            {

                SetArgument("useBodyTurn", value);
                useBodyTurn = value;
            }
        }

        private float elbowAngleOnContact = 1.9f;
        /// <summary>
        /// on contact with upperbody the desired elbow angle is set to at least this value
        /// </summary>
        [EuphoriaDetail("on contact with upperbody the desired elbow angle is set to at least this value")]
        public float ElbowAngleOnContact
        {
            get { return elbowAngleOnContact; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("elbowAngleOnContact", value);
                elbowAngleOnContact = value;
            }
        }

        private float bendElbowsTime = 0.3f;
        /// <summary>
        /// Time after contact (with Upper body) that the min m_elbowAngleOnContact is applied
        /// </summary>
        [EuphoriaDetail("Time after contact (with Upper body) that the min m_elbowAngleOnContact is applied")]
        public float BendElbowsTime
        {
            get { return bendElbowsTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("bendElbowsTime", value);
                bendElbowsTime = value;
            }
        }

        private float bendElbowsGait = 0.7f;
        /// <summary>
        /// Minimum desired angle of elbow during non contact arm swing
        /// </summary>
        [EuphoriaDetail("Minimum desired angle of elbow during non contact arm swing")]
        public float BendElbowsGait
        {
            get { return bendElbowsGait; }
            set
            {
                value = MathHelper.Clamp(value, -3.0f, 3.0f);
                SetArgument("bendElbowsGait", value);
                bendElbowsGait = value;
            }
        }

        private float hipL2ArmL2 = 0.3f;
        /// <summary>
        /// mmmmdrunk = 0.2 multiplier of hip lean2 (star jump) to give shoulder lean2 (flapping)
        /// </summary>
        [EuphoriaDetail("mmmmdrunk = 0.2 multiplier of hip lean2 (star jump) to give shoulder lean2 (flapping)")]
        public float HipL2ArmL2
        {
            get { return hipL2ArmL2; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("hipL2ArmL2", value);
                hipL2ArmL2 = value;
            }
        }

        private float shoulderL2 = 0.5f;
        /// <summary>
        /// mmmmdrunk = 0.7 shoulder lean2 offset
        /// </summary>
        [EuphoriaDetail("mmmmdrunk = 0.7 shoulder lean2 offset")]
        public float ShoulderL2
        {
            get { return shoulderL2; }
            set
            {
                value = MathHelper.Clamp(value, -3.0f, 3.0f);
                SetArgument("shoulderL2", value);
                shoulderL2 = value;
            }
        }

        private float shoulderL1 = 0.0f;
        /// <summary>
        /// mmmmdrunk 1.1 shoulder lean1 offset (+ve frankenstein)
        /// </summary>
        [EuphoriaDetail("mmmmdrunk 1.1 shoulder lean1 offset (+ve frankenstein)")]
        public float ShoulderL1
        {
            get { return shoulderL1; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 2.0f);
                SetArgument("shoulderL1", value);
                shoulderL1 = value;
            }
        }

        private float shoulderTwist = -0.35f;
        /// <summary>
        /// mmmmdrunk = 0.0 shoulder twist
        /// </summary>
        [EuphoriaDetail("mmmmdrunk = 0.0 shoulder twist")]
        public float ShoulderTwist
        {
            get { return shoulderTwist; }
            set
            {
                value = MathHelper.Clamp(value, -3.0f, 3.0f);
                SetArgument("shoulderTwist", value);
                shoulderTwist = value;
            }
        }

        private float headLookAtVelProb = -1.0f;
        /// <summary>
        /// Probability [0-1] that headLook will be looking in the direction of velocity when stepping
        /// </summary>
        [EuphoriaDetail("Probability [0-1] that headLook will be looking in the direction of velocity when stepping")]
        public float HeadLookAtVelProb
        {
            get { return headLookAtVelProb; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("headLookAtVelProb", value);
                headLookAtVelProb = value;
            }
        }

        private float turnOffProb = 0.1f;
        /// <summary>
        /// Weighted Probability that turn will be off. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability that turn will be off. This is one of six turn type weights.")]
        public float TurnOffProb
        {
            get { return turnOffProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turnOffProb", value);
                turnOffProb = value;
            }
        }

        private float turn2VelProb = 0.3f;
        /// <summary>
        /// Weighted Probability of turning towards velocity. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning towards velocity. This is one of six turn type weights.")]
        public float Turn2VelProb
        {
            get { return turn2VelProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turn2VelProb", value);
                turn2VelProb = value;
            }
        }

        private float turnAwayProb = 0.15f;
        /// <summary>
        /// Weighted Probability of turning away from headLook target. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning away from headLook target. This is one of six turn type weights.")]
        public float TurnAwayProb
        {
            get { return turnAwayProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turnAwayProb", value);
                turnAwayProb = value;
            }
        }

        private float turnLeftProb = 0.125f;
        /// <summary>
        /// Weighted Probability of turning left. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning left. This is one of six turn type weights.")]
        public float TurnLeftProb
        {
            get { return turnLeftProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turnLeftProb", value);
                turnLeftProb = value;
            }
        }

        private float turnRightProb = 0.125f;
        /// <summary>
        /// Weighted Probability of turning right. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning right. This is one of six turn type weights.")]
        public float TurnRightProb
        {
            get { return turnRightProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turnRightProb", value);
                turnRightProb = value;
            }
        }

        private float turn2TargetProb = 0.2f;
        /// <summary>
        /// Weighted Probability of turning towards headLook target. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning towards headLook target. This is one of six turn type weights.")]
        public float Turn2TargetProb
        {
            get { return turn2TargetProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turn2TargetProb", value);
                turn2TargetProb = value;
            }
        }

        private Vector3 angVelMultiplier = new Vector3(4.00f, 1.00f, 4.00f);
        /// <summary>
        /// somersault, twist, sideSomersault) multiplier of the angular velocity  for arms out (lean2) (somersault, twist, sideSomersault)
        /// </summary>
        [EuphoriaDetail("somersault, twist, sideSomersault) multiplier of the angular velocity  for arms out (lean2) (somersault, twist, sideSomersault)")]
        public Vector3 AngVelMultiplier
        {
            get { return angVelMultiplier; }
            set
            {
                value.X = MathHelper.Clamp(value.X, 0.0f, 20.0f);
                value.Y = MathHelper.Clamp(value.Y, 0.0f, 20.0f);
                value.Z = MathHelper.Clamp(value.Z, 0.0f, 20.0f);
                SetArgument("angVelMultiplier", value);
                angVelMultiplier = value;
            }
        }

        private Vector3 angVelThreshold = new Vector3(1.20f, 3.00f, 1.20f);
        /// <summary>
        /// somersault, twist, sideSomersault) threshold above which angVel is used for arms out (lean2) Unless drunk - DO NOT EXCEED 7.0 for each component
        /// </summary>
        [EuphoriaDetail("somersault, twist, sideSomersault) threshold above which angVel is used for arms out (lean2) Unless drunk - DO NOT EXCEED 7.0 for each component")]
        public Vector3 AngVelThreshold
        {
            get { return angVelThreshold; }
            set
            {
                value.X = MathHelper.Clamp(value.X, 0.0f, 40.0f);
                value.Y = MathHelper.Clamp(value.Y, 0.0f, 40.0f);
                value.Z = MathHelper.Clamp(value.Z, 0.0f, 40.0f);
                SetArgument("angVelThreshold", value);
                angVelThreshold = value;
            }
        }

        private float braceDistance = -1.00f;
        /// <summary>
        /// if -ve then do not brace.  distance from object at which to raise hands to brace 0.5 good if newBrace=true - otherwise 0.65
        /// </summary>
        [EuphoriaDetail("if -ve then do not brace.  distance from object at which to raise hands to brace 0.5 good if newBrace=true - otherwise 0.65")]
        public float BraceDistance
        {
            get { return braceDistance; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("braceDistance", value);
                braceDistance = value;
            }
        }

        private float targetPredictionTime = 0.450f;
        /// <summary>
        /// time expected to get arms up from idle
        /// </summary>
        [EuphoriaDetail("time expected to get arms up from idle")]
        public float TargetPredictionTime
        {
            get { return targetPredictionTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("targetPredictionTime", value);
                targetPredictionTime = value;
            }
        }

        private float reachAbsorbtionTime = 0.150f;
        /// <summary>
        /// larger values and he absorbs the impact more
        /// </summary>
        [EuphoriaDetail("larger values and he absorbs the impact more")]
        public float ReachAbsorbtionTime
        {
            get { return reachAbsorbtionTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("reachAbsorbtionTime", value);
                reachAbsorbtionTime = value;
            }
        }

        private float braceStiffness = 12.00f;
        /// <summary>
        /// stiffness of character. catch_fall stiffness scales with this too, with its defaults at this values default
        /// </summary>
        [EuphoriaDetail("stiffness of character. catch_fall stiffness scales with this too, with its defaults at this values default")]
        public float BraceStiffness
        {
            get { return braceStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("braceStiffness", value);
                braceStiffness = value;
            }
        }

        private float minBraceTime = 0.30f;
        /// <summary>
        /// minimum bracing time so the character doesn't look twitchy
        /// </summary>
        [EuphoriaDetail("minimum bracing time so the character doesn't look twitchy")]
        public float MinBraceTime
        {
            get { return minBraceTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("minBraceTime", value);
                minBraceTime = value;
            }
        }

        private float timeToBackwardsBrace = 0.50f;
        /// <summary>
        /// time before arm brace kicks in when hit from behind
        /// </summary>
        [EuphoriaDetail("time before arm brace kicks in when hit from behind")]
        public float TimeToBackwardsBrace
        {
            get { return timeToBackwardsBrace; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("timeToBackwardsBrace", value);
                timeToBackwardsBrace = value;
            }
        }

        private float handsDelayMin = 0.30f;
        /// <summary>
        /// If bracing with 2 hands delay one hand by at least this amount of time to introduce some asymmetry.
        /// </summary>
        [EuphoriaDetail("If bracing with 2 hands delay one hand by at least this amount of time to introduce some asymmetry.")]
        public float HandsDelayMin
        {
            get { return handsDelayMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("handsDelayMin", value);
                handsDelayMin = value;
            }
        }

        private float handsDelayMax = 0.70f;
        /// <summary>
        /// If bracing with 2 hands delay one hand by at most this amount of time to introduce some asymmetry.
        /// </summary>
        [EuphoriaDetail("If bracing with 2 hands delay one hand by at most this amount of time to introduce some asymmetry.")]
        public float HandsDelayMax
        {
            get { return handsDelayMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("handsDelayMax", value);
                handsDelayMax = value;
            }
        }

        private float braceOffset = 0.00f;
        /// <summary>
        /// braceTarget is global headLookPos plus braceOffset m in the up direction
        /// </summary>
        [EuphoriaDetail("braceTarget is global headLookPos plus braceOffset m in the up direction")]
        public float BraceOffset
        {
            get { return braceOffset; }
            set
            {
                value = MathHelper.Clamp(value, -2.00f, 2.00f);
                SetArgument("braceOffset", value);
                braceOffset = value;
            }
        }

        private float moveRadius = -1.00f;
        /// <summary>
        /// if -ve don't move away from pusher unless moveWhenBracing is true and braceDistance  GT  0.0f.  if the pusher is closer than moveRadius then move away from it.
        /// </summary>
        [EuphoriaDetail("if -ve don't move away from pusher unless moveWhenBracing is true and braceDistance  GT  0.0f.  if the pusher is closer than moveRadius then move away from it.")]
        public float MoveRadius
        {
            get { return moveRadius; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 2.00f);
                SetArgument("moveRadius", value);
                moveRadius = value;
            }
        }

        private float moveAmount = 0.30f;
        /// <summary>
        /// amount of leanForce applied away from pusher
        /// </summary>
        [EuphoriaDetail("amount of leanForce applied away from pusher")]
        public float MoveAmount
        {
            get { return moveAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("moveAmount", value);
                moveAmount = value;
            }
        }

        private bool moveWhenBracing = false;
        /// <summary>
        /// Only move away from pusher when bracing against pusher
        /// </summary>
        [EuphoriaDetail("Only move away from pusher when bracing against pusher")]
        public bool MoveWhenBracing
        {
            get { return moveWhenBracing; }
            set
            {

                SetArgument("moveWhenBracing", value);
                moveWhenBracing = value;
            }
        }


        public EuphoriaMessageBodyBalance(bool startNow) : base("bodyBalance", startNow)
        { }

        public new void Reset()
        {
            armStiffness = 9.0f;
            elbow = 0.9f;
            shoulder = 1.00f;
            armDamping = 0.7f;
            useHeadLook = false;
            headLookPos = new Vector3(0f, 0f, 0f);
            headLookInstanceIndex = -1;
            spineStiffness = 10.0f;
            somersaultAngle = 1.0f;
            somersaultAngleThreshold = 0.25f;
            sideSomersaultAngle = 1.0f;
            sideSomersaultAngleThreshold = 0.25f;
            backwardsAutoTurn = false;
            turnWithBumpRadius = -1.00f;
            backwardsArms = false;
            blendToZeroPose = false;
            armsOutOnPush = true;
            armsOutOnPushMultiplier = 1.0f;
            armsOutOnPushTimeout = 1.1f;
            returningToBalanceArmsOut = 0.0f;
            armsOutStraightenElbows = 0.0f;
            armsOutMinLean2 = -9.9f;
            spineDamping = 1.0f;
            useBodyTurn = true;
            elbowAngleOnContact = 1.9f;
            bendElbowsTime = 0.3f;
            bendElbowsGait = 0.7f;
            hipL2ArmL2 = 0.3f;
            shoulderL2 = 0.5f;
            shoulderL1 = 0.0f;
            shoulderTwist = -0.35f;
            headLookAtVelProb = -1.0f;
            turnOffProb = 0.1f;
            turn2VelProb = 0.3f;
            turnAwayProb = 0.15f;
            turnLeftProb = 0.125f;
            turnRightProb = 0.125f;
            turn2TargetProb = 0.2f;
            angVelMultiplier = new Vector3(4.00f, 1.00f, 4.00f);
            angVelThreshold = new Vector3(1.20f, 3.00f, 1.20f);
            braceDistance = -1.00f;
            targetPredictionTime = 0.450f;
            reachAbsorbtionTime = 0.150f;
            braceStiffness = 12.00f;
            minBraceTime = 0.30f;
            timeToBackwardsBrace = 0.50f;
            handsDelayMin = 0.30f;
            handsDelayMax = 0.70f;
            braceOffset = 0.00f;
            moveRadius = -1.00f;
            moveAmount = 0.30f;
            moveWhenBracing = false;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageBodyFoetal : EuphoriaMessage
    {
        private float stiffness = 9.000f;
        /// <summary>
        /// The stiffness of the body determines how fast the character moves into the position, and how well that they hold it.
        /// </summary>
        [EuphoriaDetail("The stiffness of the body determines how fast the character moves into the position, and how well that they hold it.")]
        public float Stiffness
        {
            get { return stiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("stiffness", value);
                stiffness = value;
            }
        }

        private float dampingFactor = 1.400f;
        /// <summary>
        /// Sets damping value for the character joints
        /// </summary>
        [EuphoriaDetail("Sets damping value for the character joints")]
        public float DampingFactor
        {
            get { return dampingFactor; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("dampingFactor", value);
                dampingFactor = value;
            }
        }

        private float asymmetry = 0.000f;
        /// <summary>
        /// A value between 0-1 that controls how asymmetric the results are by varying stiffness across the body
        /// </summary>
        [EuphoriaDetail("A value between 0-1 that controls how asymmetric the results are by varying stiffness across the body")]
        public float Asymmetry
        {
            get { return asymmetry; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("asymmetry", value);
                asymmetry = value;
            }
        }

        private int randomSeed = 100;
        /// <summary>
        /// Random seed used to generate asymmetry values
        /// </summary>
        [EuphoriaDetail("Random seed used to generate asymmetry values")]
        public int RandomSeed
        {
            get { return randomSeed; }
            set
            {

                SetArgument("randomSeed", value);
                randomSeed = value;
            }
        }

        private float backTwist = 0.000f;
        /// <summary>
        /// Amount of random back twist to add
        /// </summary>
        [EuphoriaDetail("Amount of random back twist to add")]
        public float BackTwist
        {
            get { return backTwist; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("backTwist", value);
                backTwist = value;
            }
        }

        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }


        public EuphoriaMessageBodyFoetal(bool startNow) : base("bodyFoetal", startNow)
        { }

        public new void Reset()
        {
            stiffness = 9.000f;
            dampingFactor = 1.400f;
            asymmetry = 0.000f;
            randomSeed = 100;
            backTwist = 0.000f;
            mask = "fb";
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageBodyRollUp : EuphoriaMessage
    {
        private float stiffness = 10.000f;
        /// <summary>
        /// stiffness of whole body
        /// </summary>
        [EuphoriaDetail("stiffness of whole body")]
        public float Stiffness
        {
            get { return stiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("stiffness", value);
                stiffness = value;
            }
        }

        private float useArmToSlowDown = 1.300f;
        /// <summary>
        /// the degree to which the character will try to stop a barrel roll with his arms
        /// </summary>
        [EuphoriaDetail("the degree to which the character will try to stop a barrel roll with his arms")]
        public float UseArmToSlowDown
        {
            get { return useArmToSlowDown; }
            set
            {
                value = MathHelper.Clamp(value, -2.0f, 3.0f);
                SetArgument("useArmToSlowDown", value);
                useArmToSlowDown = value;
            }
        }

        private float armReachAmount = 1.400f;
        /// <summary>
        /// the likeliness of the character reaching for the ground with its arms
        /// </summary>
        [EuphoriaDetail("the likeliness of the character reaching for the ground with its arms")]
        public float ArmReachAmount
        {
            get { return armReachAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("armReachAmount", value);
                armReachAmount = value;
            }
        }

        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }

        private float legPush = 0.000f;
        /// <summary>
        /// used to keep rolling down slope, 1 is full (kicks legs out when pointing upwards)
        /// </summary>
        [EuphoriaDetail("used to keep rolling down slope, 1 is full (kicks legs out when pointing upwards)")]
        public float LegPush
        {
            get { return legPush; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 2.0f);
                SetArgument("legPush", value);
                legPush = value;
            }
        }

        private float asymmetricalLegs = 0.000f;
        /// <summary>
        /// 0 is no leg asymmetry in 'foetal' position.  greater than 0 a asymmetricalLegs-rand(30%), added/minus each joint of the legs in radians.  Random number changes about once every roll.  0.4 gives a lot of asymmetry
        /// </summary>
        [EuphoriaDetail("0 is no leg asymmetry in 'foetal' position.  greater than 0 a asymmetricalLegs-rand(30%), added/minus each joint of the legs in radians.  Random number changes about once every roll.  0.4 gives a lot of asymmetry")]
        public float AsymmetricalLegs
        {
            get { return asymmetricalLegs; }
            set
            {
                value = MathHelper.Clamp(value, -2.0f, 2.0f);
                SetArgument("asymmetricalLegs", value);
                asymmetricalLegs = value;
            }
        }

        private float noRollTimeBeforeSuccess = 0.50f;
        /// <summary>
        /// time that roll velocity has to be lower than rollVelForSuccess, before success message is sent
        /// </summary>
        [EuphoriaDetail("time that roll velocity has to be lower than rollVelForSuccess, before success message is sent")]
        public float NoRollTimeBeforeSuccess
        {
            get { return noRollTimeBeforeSuccess; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("noRollTimeBeforeSuccess", value);
                noRollTimeBeforeSuccess = value;
            }
        }

        private float rollVelForSuccess = 0.20f;
        /// <summary>
        /// lower threshold for roll velocity at which success message can be sent
        /// </summary>
        [EuphoriaDetail("lower threshold for roll velocity at which success message can be sent")]
        public float RollVelForSuccess
        {
            get { return rollVelForSuccess; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("rollVelForSuccess", value);
                rollVelForSuccess = value;
            }
        }

        private float rollVelLinearContribution = 1.00f;
        /// <summary>
        /// contribution of linear COM velocity to roll Velocity (if 0, roll velocity equal to COM angular velocity)
        /// </summary>
        [EuphoriaDetail("contribution of linear COM velocity to roll Velocity (if 0, roll velocity equal to COM angular velocity)")]
        public float RollVelLinearContribution
        {
            get { return rollVelLinearContribution; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("rollVelLinearContribution", value);
                rollVelLinearContribution = value;
            }
        }

        private float velocityScale = 0.20f;
        /// <summary>
        /// Scales perceived body velocity.  The higher this value gets, the more quickly the velocity measure saturates, resulting in a tighter roll at slower speeds. (NB: Set to 1 to match earlier behaviour)
        /// </summary>
        [EuphoriaDetail("Scales perceived body velocity.  The higher this value gets, the more quickly the velocity measure saturates, resulting in a tighter roll at slower speeds. (NB: Set to 1 to match earlier behaviour)")]
        public float VelocityScale
        {
            get { return velocityScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("velocityScale", value);
                velocityScale = value;
            }
        }

        private float velocityOffset = 2.00f;
        /// <summary>
        /// Offsets perceived body velocity.  Increase to create larger "dead zone" around zero velocity where character will be less rolled. (NB: Reset to 0 to match earlier behaviour)
        /// </summary>
        [EuphoriaDetail("Offsets perceived body velocity.  Increase to create larger \"dead zone\" around zero velocity where character will be less rolled. (NB: Reset to 0 to match earlier behaviour)")]
        public float VelocityOffset
        {
            get { return velocityOffset; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("velocityOffset", value);
                velocityOffset = value;
            }
        }

        private bool applyMinMaxFriction = true;
        /// <summary>
        /// Controls whether or not behaviour enforces min/max friction
        /// </summary>
        [EuphoriaDetail("Controls whether or not behaviour enforces min/max friction")]
        public bool ApplyMinMaxFriction
        {
            get { return applyMinMaxFriction; }
            set
            {

                SetArgument("applyMinMaxFriction", value);
                applyMinMaxFriction = value;
            }
        }


        public EuphoriaMessageBodyRollUp(bool startNow) : base("bodyRollUp", startNow)
        { }

        public new void Reset()
        {
            stiffness = 10.000f;
            useArmToSlowDown = 1.300f;
            armReachAmount = 1.400f;
            mask = "fb";
            legPush = 0.000f;
            asymmetricalLegs = 0.000f;
            noRollTimeBeforeSuccess = 0.50f;
            rollVelForSuccess = 0.20f;
            rollVelLinearContribution = 1.00f;
            velocityScale = 0.20f;
            velocityOffset = 2.00f;
            applyMinMaxFriction = true;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageBodyWrithe : EuphoriaMessage
    {
        private float armStiffness = 13.000f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float ArmStiffness
        {
            get { return armStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("armStiffness", value);
                armStiffness = value;
            }
        }

        private float backStiffness = 13.000f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float BackStiffness
        {
            get { return backStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("backStiffness", value);
                backStiffness = value;
            }
        }

        private float legStiffness = 13.000f;
        /// <summary>
        /// The stiffness of the character will determine how 'determined' a writhe this is - high values will make him thrash about wildly
        /// </summary>
        [EuphoriaDetail("The stiffness of the character will determine how 'determined' a writhe this is - high values will make him thrash about wildly")]
        public float LegStiffness
        {
            get { return legStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("legStiffness", value);
                legStiffness = value;
            }
        }

        private float armDamping = 0.500f;
        /// <summary>
        /// damping amount, less is underdamped
        /// </summary>
        [EuphoriaDetail("damping amount, less is underdamped")]
        public float ArmDamping
        {
            get { return armDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("armDamping", value);
                armDamping = value;
            }
        }

        private float backDamping = 0.500f;
        /// <summary>
        /// damping amount, less is underdamped
        /// </summary>
        [EuphoriaDetail("damping amount, less is underdamped")]
        public float BackDamping
        {
            get { return backDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("backDamping", value);
                backDamping = value;
            }
        }

        private float legDamping = 0.500f;
        /// <summary>
        /// damping amount, less is underdamped
        /// </summary>
        [EuphoriaDetail("damping amount, less is underdamped")]
        public float LegDamping
        {
            get { return legDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("legDamping", value);
                legDamping = value;
            }
        }

        private float armPeriod = 1.000f;
        /// <summary>
        /// Controls how fast the writhe is executed, smaller values make faster motions
        /// </summary>
        [EuphoriaDetail("Controls how fast the writhe is executed, smaller values make faster motions")]
        public float ArmPeriod
        {
            get { return armPeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 4.0f);
                SetArgument("armPeriod", value);
                armPeriod = value;
            }
        }

        private float backPeriod = 1.000f;
        /// <summary>
        /// Controls how fast the writhe is executed, smaller values make faster motions
        /// </summary>
        [EuphoriaDetail("Controls how fast the writhe is executed, smaller values make faster motions")]
        public float BackPeriod
        {
            get { return backPeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 4.0f);
                SetArgument("backPeriod", value);
                backPeriod = value;
            }
        }

        private float legPeriod = 1.000f;
        /// <summary>
        /// Controls how fast the writhe is executed, smaller values make faster motions
        /// </summary>
        [EuphoriaDetail("Controls how fast the writhe is executed, smaller values make faster motions")]
        public float LegPeriod
        {
            get { return legPeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 4.0f);
                SetArgument("legPeriod", value);
                legPeriod = value;
            }
        }

        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }

        private float armAmplitude = 1.000f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float ArmAmplitude
        {
            get { return armAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("armAmplitude", value);
                armAmplitude = value;
            }
        }

        private float backAmplitude = 1.000f;
        /// <summary>
        /// scales the amount of writhe. 0 = no writhe
        /// </summary>
        [EuphoriaDetail("scales the amount of writhe. 0 = no writhe")]
        public float BackAmplitude
        {
            get { return backAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("backAmplitude", value);
                backAmplitude = value;
            }
        }

        private float legAmplitude = 1.000f;
        /// <summary>
        /// scales the amount of writhe. 0 = no writhe
        /// </summary>
        [EuphoriaDetail("scales the amount of writhe. 0 = no writhe")]
        public float LegAmplitude
        {
            get { return legAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("legAmplitude", value);
                legAmplitude = value;
            }
        }

        private float elbowAmplitude = 1.000f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float ElbowAmplitude
        {
            get { return elbowAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("elbowAmplitude", value);
                elbowAmplitude = value;
            }
        }

        private float kneeAmplitude = 1.000f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float KneeAmplitude
        {
            get { return kneeAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("kneeAmplitude", value);
                kneeAmplitude = value;
            }
        }

        private bool rollOverFlag = false;
        /// <summary>
        /// Flag to set trying to rollOver
        /// </summary>
        [EuphoriaDetail("Flag to set trying to rollOver")]
        public bool RollOverFlag
        {
            get { return rollOverFlag; }
            set
            {

                SetArgument("rollOverFlag", value);
                rollOverFlag = value;
            }
        }

        private float blendArms = 1.0f;
        /// <summary>
        /// Blend the writhe arms with the current desired arms (0=don't apply any writhe, 1=only writhe)
        /// </summary>
        [EuphoriaDetail("Blend the writhe arms with the current desired arms (0=don't apply any writhe, 1=only writhe)")]
        public float BlendArms
        {
            get { return blendArms; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("blendArms", value);
                blendArms = value;
            }
        }

        private float blendBack = 1.0f;
        /// <summary>
        /// Blend the writhe spine and neck with the current desired (0=don't apply any writhe, 1=only writhe)
        /// </summary>
        [EuphoriaDetail("Blend the writhe spine and neck with the current desired (0=don't apply any writhe, 1=only writhe)")]
        public float BlendBack
        {
            get { return blendBack; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("blendBack", value);
                blendBack = value;
            }
        }

        private float blendLegs = 1.0f;
        /// <summary>
        /// Blend the writhe legs with the current desired legs (0=don't apply any writhe, 1=only writhe)
        /// </summary>
        [EuphoriaDetail("Blend the writhe legs with the current desired legs (0=don't apply any writhe, 1=only writhe)")]
        public float BlendLegs
        {
            get { return blendLegs; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("blendLegs", value);
                blendLegs = value;
            }
        }

        private bool applyStiffness = true;
        /// <summary>
        /// Use writhe stiffnesses if true. If false don't set any stiffnesses
        /// </summary>
        [EuphoriaDetail("Use writhe stiffnesses if true. If false don't set any stiffnesses")]
        public bool ApplyStiffness
        {
            get { return applyStiffness; }
            set
            {

                SetArgument("applyStiffness", value);
                applyStiffness = value;
            }
        }

        private bool onFire = false;
        /// <summary>
        /// Extra shoulderBlend. Rolling:one way only, maxRollOverTime, rollOverRadius, doesn't reduce arm stiffness to help rolling. No shoulder twist
        /// </summary>
        [EuphoriaDetail("Extra shoulderBlend. Rolling:one way only, maxRollOverTime, rollOverRadius, doesn't reduce arm stiffness to help rolling. No shoulder twist")]
        public bool OnFire
        {
            get { return onFire; }
            set
            {

                SetArgument("onFire", value);
                onFire = value;
            }
        }

        private float shoulderLean1 = 0.70f;
        /// <summary>
        /// Blend writhe shoulder desired lean1 with this angle in RAD. Note that onFire has to be set to true for this parameter to take any effect.
        /// </summary>
        [EuphoriaDetail("Blend writhe shoulder desired lean1 with this angle in RAD. Note that onFire has to be set to true for this parameter to take any effect.")]
        public float ShoulderLean1
        {
            get { return shoulderLean1; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 6.283185f);
                SetArgument("shoulderLean1", value);
                shoulderLean1 = value;
            }
        }

        private float shoulderLean2 = 0.40f;
        /// <summary>
        /// Blend writhe shoulder desired lean2 with this angle in RAD. Note that onFire has to be set to true for this parameter to take any effect.
        /// </summary>
        [EuphoriaDetail("Blend writhe shoulder desired lean2 with this angle in RAD. Note that onFire has to be set to true for this parameter to take any effect.")]
        public float ShoulderLean2
        {
            get { return shoulderLean2; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 6.283185f);
                SetArgument("shoulderLean2", value);
                shoulderLean2 = value;
            }
        }

        private float lean1BlendFactor = 0.00f;
        /// <summary>
        /// Shoulder desired lean1 with shoulderLean1 angle blend factor. Set it to 0 to use original shoulder withe desired lean1 angle for shoulders. Note that onFire has to be set to true for this parameter to take any effect.
        /// </summary>
        [EuphoriaDetail("Shoulder desired lean1 with shoulderLean1 angle blend factor. Set it to 0 to use original shoulder withe desired lean1 angle for shoulders. Note that onFire has to be set to true for this parameter to take any effect.")]
        public float Lean1BlendFactor
        {
            get { return lean1BlendFactor; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("lean1BlendFactor", value);
                lean1BlendFactor = value;
            }
        }

        private float lean2BlendFactor = 0.00f;
        /// <summary>
        /// Shoulder desired lean2 with shoulderLean2 angle blend factor. Set it to 0 to use original shoulder withe desired lean2 angle for shoulders. Note that onFire has to be set to true for this parameter to take any effect.
        /// </summary>
        [EuphoriaDetail("Shoulder desired lean2 with shoulderLean2 angle blend factor. Set it to 0 to use original shoulder withe desired lean2 angle for shoulders. Note that onFire has to be set to true for this parameter to take any effect.")]
        public float Lean2BlendFactor
        {
            get { return lean2BlendFactor; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("lean2BlendFactor", value);
                lean2BlendFactor = value;
            }
        }

        private float rollTorqueScale = 150.00f;
        /// <summary>
        /// Scale rolling torque that is applied to character spine.
        /// </summary>
        [EuphoriaDetail("Scale rolling torque that is applied to character spine.")]
        public float RollTorqueScale
        {
            get { return rollTorqueScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 300.00f);
                SetArgument("rollTorqueScale", value);
                rollTorqueScale = value;
            }
        }

        private float maxRollOverTime = 8.00f;
        /// <summary>
        /// Rolling torque is ramped down over time. At this time in seconds torque value converges to zero. Use this parameter to restrict time the character is rolling. Note that onFire has to be set to true for this parameter to take any effect.
        /// </summary>
        [EuphoriaDetail("Rolling torque is ramped down over time. At this time in seconds torque value converges to zero. Use this parameter to restrict time the character is rolling. Note that onFire has to be set to true for this parameter to take any effect.")]
        public float MaxRollOverTime
        {
            get { return maxRollOverTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 60.00f);
                SetArgument("maxRollOverTime", value);
                maxRollOverTime = value;
            }
        }

        private float rollOverRadius = 2.00f;
        /// <summary>
        /// Rolling torque is ramped down with distance measured from position where character hit the ground and started rolling. At this distance in meters torque value converges to zero. Use this parameter to restrict distance the character travels due to rolling. Note that onFire has to be set to true for this parameter to take any effect.
        /// </summary>
        [EuphoriaDetail("Rolling torque is ramped down with distance measured from position where character hit the ground and started rolling. At this distance in meters torque value converges to zero. Use this parameter to restrict distance the character travels due to rolling. Note that onFire has to be set to true for this parameter to take any effect.")]
        public float RollOverRadius
        {
            get { return rollOverRadius; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("rollOverRadius", value);
                rollOverRadius = value;
            }
        }


        public EuphoriaMessageBodyWrithe(bool startNow) : base("bodyWrithe", startNow)
        { }

        public new void Reset()
        {
            armStiffness = 13.000f;
            backStiffness = 13.000f;
            legStiffness = 13.000f;
            armDamping = 0.500f;
            backDamping = 0.500f;
            legDamping = 0.500f;
            armPeriod = 1.000f;
            backPeriod = 1.000f;
            legPeriod = 1.000f;
            mask = "fb";
            armAmplitude = 1.000f;
            backAmplitude = 1.000f;
            legAmplitude = 1.000f;
            elbowAmplitude = 1.000f;
            kneeAmplitude = 1.000f;
            rollOverFlag = false;
            blendArms = 1.0f;
            blendBack = 1.0f;
            blendLegs = 1.0f;
            applyStiffness = true;
            onFire = false;
            shoulderLean1 = 0.70f;
            shoulderLean2 = 0.40f;
            lean1BlendFactor = 0.00f;
            lean2BlendFactor = 0.00f;
            rollTorqueScale = 150.00f;
            maxRollOverTime = 8.00f;
            rollOverRadius = 2.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageBraceForImpact : EuphoriaMessage
    {
        private float braceDistance = 0.50f;
        /// <summary>
        /// distance from object at which to raise hands to brace 0.5 good if newBrace=true - otherwise 0.65
        /// </summary>
        [EuphoriaDetail("distance from object at which to raise hands to brace 0.5 good if newBrace=true - otherwise 0.65")]
        public float BraceDistance
        {
            get { return braceDistance; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("braceDistance", value);
                braceDistance = value;
            }
        }

        private float targetPredictionTime = 0.450f;
        /// <summary>
        /// time epected to get arms up from idle
        /// </summary>
        [EuphoriaDetail("time epected to get arms up from idle")]
        public float TargetPredictionTime
        {
            get { return targetPredictionTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("targetPredictionTime", value);
                targetPredictionTime = value;
            }
        }

        private float reachAbsorbtionTime = 0.150f;
        /// <summary>
        /// larger values and he absorbs the impact more
        /// </summary>
        [EuphoriaDetail("larger values and he absorbs the impact more")]
        public float ReachAbsorbtionTime
        {
            get { return reachAbsorbtionTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("reachAbsorbtionTime", value);
                reachAbsorbtionTime = value;
            }
        }

        private int instanceIndex = -1;
        /// <summary>
        /// levelIndex of object to brace
        /// </summary>
        [EuphoriaDetail("levelIndex of object to brace")]
        public int InstanceIndex
        {
            get { return instanceIndex; }
            set
            {

                SetArgument("instanceIndex", value);
                instanceIndex = value;
            }
        }

        private float bodyStiffness = 12.00f;
        /// <summary>
        /// stiffness of character. catch_fall stiffness scales with this too, with its defaults at this values default
        /// </summary>
        [EuphoriaDetail("stiffness of character. catch_fall stiffness scales with this too, with its defaults at this values default")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private bool grabDontLetGo = false;
        /// <summary>
        /// Once a constraint is made, keep reaching with whatever hand is allowed
        /// </summary>
        [EuphoriaDetail("Once a constraint is made, keep reaching with whatever hand is allowed")]
        public bool GrabDontLetGo
        {
            get { return grabDontLetGo; }
            set
            {

                SetArgument("grabDontLetGo", value);
                grabDontLetGo = value;
            }
        }

        private float grabStrength = 40.00f;
        /// <summary>
        /// strength in hands for grabbing (kg m/s), -1 to ignore/disable
        /// </summary>
        [EuphoriaDetail("strength in hands for grabbing (kg m/s), -1 to ignore/disable")]
        public float GrabStrength
        {
            get { return grabStrength; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1000.00f);
                SetArgument("grabStrength", value);
                grabStrength = value;
            }
        }

        private float grabDistance = 2.00f;
        /// <summary>
        /// Relative distance at which the grab starts.
        /// </summary>
        [EuphoriaDetail("Relative distance at which the grab starts.")]
        public float GrabDistance
        {
            get { return grabDistance; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 4.00f);
                SetArgument("grabDistance", value);
                grabDistance = value;
            }
        }

        private float grabReachAngle = 1.50f;
        /// <summary>
        /// Angle from front at which the grab activates. If the point is outside this angle from front will not try to grab.
        /// </summary>
        [EuphoriaDetail("Angle from front at which the grab activates. If the point is outside this angle from front will not try to grab.")]
        public float GrabReachAngle
        {
            get { return grabReachAngle; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.160f);
                SetArgument("grabReachAngle", value);
                grabReachAngle = value;
            }
        }

        private float grabHoldTimer = 2.50f;
        /// <summary>
        /// amount of time, in seconds, before grab automatically bails
        /// </summary>
        [EuphoriaDetail("amount of time, in seconds, before grab automatically bails")]
        public float GrabHoldTimer
        {
            get { return grabHoldTimer; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("grabHoldTimer", value);
                grabHoldTimer = value;
            }
        }

        private float maxGrabCarVelocity = 95.00f;
        /// <summary>
        /// Don't try to grab a car moving above this speed mmmmtodo make this the relative velocity of car to character?
        /// </summary>
        [EuphoriaDetail("Don't try to grab a car moving above this speed mmmmtodo make this the relative velocity of car to character?")]
        public float MaxGrabCarVelocity
        {
            get { return maxGrabCarVelocity; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1000.00f);
                SetArgument("maxGrabCarVelocity", value);
                maxGrabCarVelocity = value;
            }
        }

        private float legStiffness = 12.00f;
        /// <summary>
        /// Balancer leg stiffness mmmmtodo remove this parameter and use configureBalance?
        /// </summary>
        [EuphoriaDetail("Balancer leg stiffness mmmmtodo remove this parameter and use configureBalance?")]
        public float LegStiffness
        {
            get { return legStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("legStiffness", value);
                legStiffness = value;
            }
        }

        private float timeToBackwardsBrace = 1.00f;
        /// <summary>
        /// time before arm brace kicks in when hit from behind
        /// </summary>
        [EuphoriaDetail("time before arm brace kicks in when hit from behind")]
        public float TimeToBackwardsBrace
        {
            get { return timeToBackwardsBrace; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("timeToBackwardsBrace", value);
                timeToBackwardsBrace = value;
            }
        }

        private Vector3 look = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position to look at, e.g. the driver
        /// </summary>
        [EuphoriaDetail("position to look at, e.g. the driver")]
        public Vector3 Look
        {
            get { return look; }
            set
            {

                SetArgument("look", value);
                look = value;
            }
        }

        private Vector3 pos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// location of the front part of the object to brace against. This should be the centre of where his hands should meet the object
        /// </summary>
        [EuphoriaDetail("location of the front part of the object to brace against. This should be the centre of where his hands should meet the object")]
        public Vector3 Pos
        {
            get { return pos; }
            set
            {

                SetArgument("pos", value);
                pos = value;
            }
        }

        private float minBraceTime = 0.30f;
        /// <summary>
        /// minimum bracing time so the character doesn't look twitchy
        /// </summary>
        [EuphoriaDetail("minimum bracing time so the character doesn't look twitchy")]
        public float MinBraceTime
        {
            get { return minBraceTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("minBraceTime", value);
                minBraceTime = value;
            }
        }

        private float handsDelayMin = 0.10f;
        /// <summary>
        /// If bracing with 2 hands delay one hand by at least this amount of time to introduce some asymmetry.
        /// </summary>
        [EuphoriaDetail("If bracing with 2 hands delay one hand by at least this amount of time to introduce some asymmetry.")]
        public float HandsDelayMin
        {
            get { return handsDelayMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("handsDelayMin", value);
                handsDelayMin = value;
            }
        }

        private float handsDelayMax = 0.30f;
        /// <summary>
        /// If bracing with 2 hands delay one hand by at most this amount of time to introduce some asymmetry.
        /// </summary>
        [EuphoriaDetail("If bracing with 2 hands delay one hand by at most this amount of time to introduce some asymmetry.")]
        public float HandsDelayMax
        {
            get { return handsDelayMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("handsDelayMax", value);
                handsDelayMax = value;
            }
        }

        private bool moveAway = false;
        /// <summary>
        /// move away from the car (if in reaching zone)
        /// </summary>
        [EuphoriaDetail("move away from the car (if in reaching zone)")]
        public bool MoveAway
        {
            get { return moveAway; }
            set
            {

                SetArgument("moveAway", value);
                moveAway = value;
            }
        }

        private float moveAwayAmount = 0.10f;
        /// <summary>
        /// forceLean away amount (-ve is lean towards)
        /// </summary>
        [EuphoriaDetail("forceLean away amount (-ve is lean towards)")]
        public float MoveAwayAmount
        {
            get { return moveAwayAmount; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("moveAwayAmount", value);
                moveAwayAmount = value;
            }
        }

        private float moveAwayLean = 0.050f;
        /// <summary>
        /// Lean away amount (-ve is lean towards)
        /// </summary>
        [EuphoriaDetail("Lean away amount (-ve is lean towards)")]
        public float MoveAwayLean
        {
            get { return moveAwayLean; }
            set
            {
                value = MathHelper.Clamp(value, -0.5f, 0.5f);
                SetArgument("moveAwayLean", value);
                moveAwayLean = value;
            }
        }

        private float moveSideways = 0.30f;
        /// <summary>
        /// Amount of sideways movement if at the front or back of the car to add to the move away from car
        /// </summary>
        [EuphoriaDetail("Amount of sideways movement if at the front or back of the car to add to the move away from car")]
        public float MoveSideways
        {
            get { return moveSideways; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("moveSideways", value);
                moveSideways = value;
            }
        }

        private bool bbArms = false;
        /// <summary>
        /// Use bodyBalance arms for the default (non bracing) behaviour if bodyBalance is active
        /// </summary>
        [EuphoriaDetail("Use bodyBalance arms for the default (non bracing) behaviour if bodyBalance is active")]
        public bool BbArms
        {
            get { return bbArms; }
            set
            {

                SetArgument("bbArms", value);
                bbArms = value;
            }
        }

        private bool newBrace = true;
        /// <summary>
        /// Use the new brace prediction code
        /// </summary>
        [EuphoriaDetail("Use the new brace prediction code")]
        public bool NewBrace
        {
            get { return newBrace; }
            set
            {

                SetArgument("newBrace", value);
                newBrace = value;
            }
        }

        private bool braceOnImpact = false;
        /// <summary>
        /// If true then if a shin or thigh is in contact with the car then brace. NB: newBrace must be true.  For those situations where the car has pushed the ped backwards (at the same speed as the car) before the behaviour has been started and so doesn't predict an impact.
        /// </summary>
        [EuphoriaDetail("If true then if a shin or thigh is in contact with the car then brace. NB: newBrace must be true.  For those situations where the car has pushed the ped backwards (at the same speed as the car) before the behaviour has been started and so doesn't predict an impact.")]
        public bool BraceOnImpact
        {
            get { return braceOnImpact; }
            set
            {

                SetArgument("braceOnImpact", value);
                braceOnImpact = value;
            }
        }

        private bool roll2Velocity = false;
        /// <summary>
        /// When rollDownStairs is running use roll2Velocity to control the helper torques (this only attempts to roll to the chaarcter's velocity not some default linear velocity mag
        /// </summary>
        [EuphoriaDetail("When rollDownStairs is running use roll2Velocity to control the helper torques (this only attempts to roll to the chaarcter's velocity not some default linear velocity mag")]
        public bool Roll2Velocity
        {
            get { return roll2Velocity; }
            set
            {

                SetArgument("roll2Velocity", value);
                roll2Velocity = value;
            }
        }

        private int rollType = 3;
        /// <summary>
        /// 0 = original/roll off/stay on car:  Roll with character velocity, 1 = //Gentle: roll off/stay on car = use relative velocity of character to car to roll against, 2 = //roll over car:  Roll against character velocity.  i.e. roll against any velocity picked up by hitting car, 3 = //Gentle: roll over car:  use relative velocity of character to car to roll with
        /// </summary>
        [EuphoriaDetail("0 = original/roll off/stay on car:  Roll with character velocity, 1 = //Gentle: roll off/stay on car = use relative velocity of character to car to roll against, 2 = //roll over car:  Roll against character velocity.  i.e. roll against any velocity picked up by hitting car, 3 = //Gentle: roll over car:  use relative velocity of character to car to roll with")]
        public int RollType
        {
            get { return rollType; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("rollType", value);
                rollType = value;
            }
        }

        private bool snapImpacts = false;
        /// <summary>
        /// Exaggerate impacts using snap
        /// </summary>
        [EuphoriaDetail("Exaggerate impacts using snap")]
        public bool SnapImpacts
        {
            get { return snapImpacts; }
            set
            {

                SetArgument("snapImpacts", value);
                snapImpacts = value;
            }
        }

        private float snapImpact = 7.00f;
        /// <summary>
        /// Exaggeration amount of the initial impact (legs).  +ve fold with car impact (as if pushed at hips in the car velocity direction).  -ve fold away from car impact
        /// </summary>
        [EuphoriaDetail("Exaggeration amount of the initial impact (legs).  +ve fold with car impact (as if pushed at hips in the car velocity direction).  -ve fold away from car impact")]
        public float SnapImpact
        {
            get { return snapImpact; }
            set
            {
                value = MathHelper.Clamp(value, -20.00f, 20.00f);
                SetArgument("snapImpact", value);
                snapImpact = value;
            }
        }

        private float snapBonnet = -7.00f;
        /// <summary>
        /// Exaggeration amount of the secondary (torso) impact with bonnet. +ve fold with car impact (as if pushed at hips by the impact normal).  -ve fold away from car impact
        /// </summary>
        [EuphoriaDetail("Exaggeration amount of the secondary (torso) impact with bonnet. +ve fold with car impact (as if pushed at hips by the impact normal).  -ve fold away from car impact")]
        public float SnapBonnet
        {
            get { return snapBonnet; }
            set
            {
                value = MathHelper.Clamp(value, -20.00f, 20.00f);
                SetArgument("snapBonnet", value);
                snapBonnet = value;
            }
        }

        private float snapFloor = 7.00f;
        /// <summary>
        /// Exaggeration amount of the impact with the floor after falling off of car +ve fold with floor impact (as if pushed at hips in the impact normal direction).  -ve fold away from car impact
        /// </summary>
        [EuphoriaDetail("Exaggeration amount of the impact with the floor after falling off of car +ve fold with floor impact (as if pushed at hips in the impact normal direction).  -ve fold away from car impact")]
        public float SnapFloor
        {
            get { return snapFloor; }
            set
            {
                value = MathHelper.Clamp(value, -20.00f, 20.00f);
                SetArgument("snapFloor", value);
                snapFloor = value;
            }
        }

        private bool dampVel = false;
        /// <summary>
        /// Damp out excessive spin and upward velocity when on car
        /// </summary>
        [EuphoriaDetail("Damp out excessive spin and upward velocity when on car")]
        public bool DampVel
        {
            get { return dampVel; }
            set
            {

                SetArgument("dampVel", value);
                dampVel = value;
            }
        }

        private float dampSpin = 0.00f;
        /// <summary>
        /// Amount to damp spinning by (cartwheeling and somersaulting)
        /// </summary>
        [EuphoriaDetail("Amount to damp spinning by (cartwheeling and somersaulting)")]
        public float DampSpin
        {
            get { return dampSpin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 40.00f);
                SetArgument("dampSpin", value);
                dampSpin = value;
            }
        }

        private float dampUpVel = 10.00f;
        /// <summary>
        /// Amount to damp upward velocity by to limit the amount of air above the car the character can get.
        /// </summary>
        [EuphoriaDetail("Amount to damp upward velocity by to limit the amount of air above the car the character can get.")]
        public float DampUpVel
        {
            get { return dampUpVel; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 40.00f);
                SetArgument("dampUpVel", value);
                dampUpVel = value;
            }
        }

        private float dampSpinThresh = 4.00f;
        /// <summary>
        /// Angular velocity above which we start damping
        /// </summary>
        [EuphoriaDetail("Angular velocity above which we start damping")]
        public float DampSpinThresh
        {
            get { return dampSpinThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("dampSpinThresh", value);
                dampSpinThresh = value;
            }
        }

        private float dampUpVelThresh = 2.00f;
        /// <summary>
        /// Upward velocity above which we start damping
        /// </summary>
        [EuphoriaDetail("Upward velocity above which we start damping")]
        public float DampUpVelThresh
        {
            get { return dampUpVelThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("dampUpVelThresh", value);
                dampUpVelThresh = value;
            }
        }

        private bool gsHelp = false;
        /// <summary>
        /// Enhance a glancing spin with the side of the car by modulating body friction.
        /// </summary>
        [EuphoriaDetail("Enhance a glancing spin with the side of the car by modulating body friction.")]
        public bool GsHelp
        {
            get { return gsHelp; }
            set
            {

                SetArgument("gsHelp", value);
                gsHelp = value;
            }
        }

        private float gsEndMin = -0.10f;
        /// <summary>
        /// ID for glancing spin. min depth to be considered from either end (front/rear) of a car (-ve is inside the car area)
        /// </summary>
        [EuphoriaDetail("ID for glancing spin. min depth to be considered from either end (front/rear) of a car (-ve is inside the car area)")]
        public float GsEndMin
        {
            get { return gsEndMin; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 1.00f);
                SetArgument("gsEndMin", value);
                gsEndMin = value;
            }
        }

        private float gsSideMin = -0.20f;
        /// <summary>
        /// ID for glancing spin. min depth to be considered on the side of a car (-ve is inside the car area)
        /// </summary>
        [EuphoriaDetail("ID for glancing spin. min depth to be considered on the side of a car (-ve is inside the car area)")]
        public float GsSideMin
        {
            get { return gsSideMin; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 1.00f);
                SetArgument("gsSideMin", value);
                gsSideMin = value;
            }
        }

        private float gsSideMax = 0.50f;
        /// <summary>
        /// ID for glancing spin. max depth to be considered on the side of a car (+ve is outside the car area)
        /// </summary>
        [EuphoriaDetail("ID for glancing spin. max depth to be considered on the side of a car (+ve is outside the car area)")]
        public float GsSideMax
        {
            get { return gsSideMax; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 1.00f);
                SetArgument("gsSideMax", value);
                gsSideMax = value;
            }
        }

        private float gsUpness = 0.90f;
        /// <summary>
        /// ID for glancing spin. Character has to be more upright than this value for it to be considered on the side of a car. Fully upright = 1, upsideDown = -1.  Max Angle from upright is acos(gsUpness)
        /// </summary>
        [EuphoriaDetail("ID for glancing spin. Character has to be more upright than this value for it to be considered on the side of a car. Fully upright = 1, upsideDown = -1.  Max Angle from upright is acos(gsUpness)")]
        public float GsUpness
        {
            get { return gsUpness; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("gsUpness", value);
                gsUpness = value;
            }
        }

        private float gsCarVelMin = 3.00f;
        /// <summary>
        /// ID for glancing spin. Minimum car velocity.
        /// </summary>
        [EuphoriaDetail("ID for glancing spin. Minimum car velocity.")]
        public float GsCarVelMin
        {
            get { return gsCarVelMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("gsCarVelMin", value);
                gsCarVelMin = value;
            }
        }

        private bool gsScale1Foot = true;
        /// <summary>
        /// Apply gsFricScale1 to the foot if colliding with car.  (Otherwise foot friction - with the ground - is determined by gsFricScale2 if it is in gsFricMask2)
        /// </summary>
        [EuphoriaDetail("Apply gsFricScale1 to the foot if colliding with car.  (Otherwise foot friction - with the ground - is determined by gsFricScale2 if it is in gsFricMask2)")]
        public bool GsScale1Foot
        {
            get { return gsScale1Foot; }
            set
            {

                SetArgument("gsScale1Foot", value);
                gsScale1Foot = value;
            }
        }

        private float gsFricScale1 = 8.00f;
        /// <summary>
        /// Glancing spin help. Friction scale applied when to the side of the car.  e.g. make the character spin more by upping the friction against the car
        /// </summary>
        [EuphoriaDetail("Glancing spin help. Friction scale applied when to the side of the car.  e.g. make the character spin more by upping the friction against the car")]
        public float GsFricScale1
        {
            get { return gsFricScale1; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("gsFricScale1", value);
                gsFricScale1 = value;
            }
        }

        private string gsFricMask1 = "fb";
        /// <summary>
        /// Glancing spin help. Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see notes for explanation). Note gsFricMask1 and gsFricMask2 are made independent by the code so you can have fb for gsFricMask1 but gsFricScale1 will not be applied to any bodyParts in gsFricMask2
        /// </summary>
        [EuphoriaDetail("Glancing spin help. Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see notes for explanation). Note gsFricMask1 and gsFricMask2 are made independent by the code so you can have fb for gsFricMask1 but gsFricScale1 will not be applied to any bodyParts in gsFricMask2")]
        public string GsFricMask1
        {
            get { return gsFricMask1; }
            set
            {

                SetArgument("gsFricMask1", value);
                gsFricMask1 = value;
            }
        }

        private float gsFricScale2 = 0.20f;
        /// <summary>
        /// Glancing spin help. Friction scale applied when to the side of the car.  e.g. make the character spin more by lowering the feet friction. You could also lower the wrist friction here to stop the car pulling along the hands i.e. gsFricMask2 = la|uw
        /// </summary>
        [EuphoriaDetail("Glancing spin help. Friction scale applied when to the side of the car.  e.g. make the character spin more by lowering the feet friction. You could also lower the wrist friction here to stop the car pulling along the hands i.e. gsFricMask2 = la|uw")]
        public float GsFricScale2
        {
            get { return gsFricScale2; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("gsFricScale2", value);
                gsFricScale2 = value;
            }
        }

        private string gsFricMask2 = "la";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see notes for explanation). Note gsFricMask1 and gsFricMask2 are made independent by the code so you can have fb for gsFricMask1 but gsFricScale1 will not be applied to any bodyParts in gsFricMask2
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see notes for explanation). Note gsFricMask1 and gsFricMask2 are made independent by the code so you can have fb for gsFricMask1 but gsFricScale1 will not be applied to any bodyParts in gsFricMask2")]
        public string GsFricMask2
        {
            get { return gsFricMask2; }
            set
            {

                SetArgument("gsFricMask2", value);
                gsFricMask2 = value;
            }
        }


        public EuphoriaMessageBraceForImpact(bool startNow) : base("braceForImpact", startNow)
        { }

        public new void Reset()
        {
            braceDistance = 0.50f;
            targetPredictionTime = 0.450f;
            reachAbsorbtionTime = 0.150f;
            instanceIndex = -1;
            bodyStiffness = 12.00f;
            grabDontLetGo = false;
            grabStrength = 40.00f;
            grabDistance = 2.00f;
            grabReachAngle = 1.50f;
            grabHoldTimer = 2.50f;
            maxGrabCarVelocity = 95.00f;
            legStiffness = 12.00f;
            timeToBackwardsBrace = 1.00f;
            look = new Vector3(0f, 0f, 0f);
            pos = new Vector3(0f, 0f, 0f);
            minBraceTime = 0.30f;
            handsDelayMin = 0.10f;
            handsDelayMax = 0.30f;
            moveAway = false;
            moveAwayAmount = 0.10f;
            moveAwayLean = 0.050f;
            moveSideways = 0.30f;
            bbArms = false;
            newBrace = true;
            braceOnImpact = false;
            roll2Velocity = false;
            rollType = 3;
            snapImpacts = false;
            snapImpact = 7.00f;
            snapBonnet = -7.00f;
            snapFloor = 7.00f;
            dampVel = false;
            dampSpin = 0.00f;
            dampUpVel = 10.00f;
            dampSpinThresh = 4.00f;
            dampUpVelThresh = 2.00f;
            gsHelp = false;
            gsEndMin = -0.10f;
            gsSideMin = -0.20f;
            gsSideMax = 0.50f;
            gsUpness = 0.90f;
            gsCarVelMin = 3.00f;
            gsScale1Foot = true;
            gsFricScale1 = 8.00f;
            gsFricMask1 = "fb";
            gsFricScale2 = 0.20f;
            gsFricMask2 = "la";
            base.Reset();
        }
    }


    /// <summary>
    /// buoyancy:  Simple buoyancy model.  No character movement just fluid forces/torques added to parts.
    /// </summary>
    [EuphoriaDetail("buoyancy:  Simple buoyancy model.  No character movement just fluid forces/torques added to parts.")]
    internal class EuphoriaMessageBuoyancy : EuphoriaMessage
    {
        private Vector3 surfacePoint = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Arbitrary point on surface of water.
        /// </summary>
        [EuphoriaDetail("Arbitrary point on surface of water.")]
        public Vector3 SurfacePoint
        {
            get { return surfacePoint; }
            set
            {

                SetArgument("surfacePoint", value);
                surfacePoint = value;
            }
        }

        private Vector3 surfaceNormal = new Vector3(0f, 0f, 1f);
        /// <summary>
        /// Normal to surface of water.
        /// </summary>
        [EuphoriaDetail("Normal to surface of water.")]
        public Vector3 SurfaceNormal
        {
            get { return surfaceNormal; }
            set
            {

                SetArgument("surfaceNormal", value);
                surfaceNormal = value;
            }
        }

        private float buoyancy = 1.0f;
        /// <summary>
        /// Buoyancy multiplier.
        /// </summary>
        [EuphoriaDetail("Buoyancy multiplier.")]
        public float Buoyancy
        {
            get { return buoyancy; }
            set
            {

                SetArgument("buoyancy", value);
                buoyancy = value;
            }
        }

        private float chestBuoyancy = 8.0f;
        /// <summary>
        /// Buoyancy mulplier for spine2/3. Helps character float upright.
        /// </summary>
        [EuphoriaDetail("Buoyancy mulplier for spine2/3. Helps character float upright.")]
        public float ChestBuoyancy
        {
            get { return chestBuoyancy; }
            set
            {

                SetArgument("chestBuoyancy", value);
                chestBuoyancy = value;
            }
        }

        private float damping = 40.0f;
        /// <summary>
        /// Damping for submerged parts.
        /// </summary>
        [EuphoriaDetail("Damping for submerged parts.")]
        public float Damping
        {
            get { return damping; }
            set
            {

                SetArgument("damping", value);
                damping = value;
            }
        }

        private bool righting = true;
        /// <summary>
        /// Use righting torque to being character face-up in water?
        /// </summary>
        [EuphoriaDetail("Use righting torque to being character face-up in water?")]
        public bool Righting
        {
            get { return righting; }
            set
            {

                SetArgument("righting", value);
                righting = value;
            }
        }

        private float rightingStrength = 25.0f;
        /// <summary>
        /// Strength of righting torque.
        /// </summary>
        [EuphoriaDetail("Strength of righting torque.")]
        public float RightingStrength
        {
            get { return rightingStrength; }
            set
            {

                SetArgument("rightingStrength", value);
                rightingStrength = value;
            }
        }

        private float rightingTime = 1.0f;
        /// <summary>
        /// How long to wait after chest hits water to begin righting torque.
        /// </summary>
        [EuphoriaDetail("How long to wait after chest hits water to begin righting torque.")]
        public float RightingTime
        {
            get { return rightingTime; }
            set
            {

                SetArgument("rightingTime", value);
                rightingTime = value;
            }
        }


        public EuphoriaMessageBuoyancy(bool startNow) : base("buoyancy", startNow)
        { }

        public new void Reset()
        {
            surfacePoint = new Vector3(0f, 0f, 0f);
            surfaceNormal = new Vector3(0f, 0f, 1f);
            buoyancy = 1.0f;
            chestBuoyancy = 8.0f;
            damping = 40.0f;
            righting = true;
            rightingStrength = 25.0f;
            rightingTime = 1.0f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageCatchFall : EuphoriaMessage
    {
        private float torsoStiffness = 9.0f;
        /// <summary>
        /// stiffness of torso
        /// </summary>
        [EuphoriaDetail("stiffness of torso")]
        public float TorsoStiffness
        {
            get { return torsoStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("torsoStiffness", value);
                torsoStiffness = value;
            }
        }

        private float legsStiffness = 6.0f;
        /// <summary>
        /// stiffness of legs
        /// </summary>
        [EuphoriaDetail("stiffness of legs")]
        public float LegsStiffness
        {
            get { return legsStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 4.0f, 16.0f);
                SetArgument("legsStiffness", value);
                legsStiffness = value;
            }
        }

        private float armsStiffness = 15.0f;
        /// <summary>
        /// stiffness of arms
        /// </summary>
        [EuphoriaDetail("stiffness of arms")]
        public float ArmsStiffness
        {
            get { return armsStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("armsStiffness", value);
                armsStiffness = value;
            }
        }

        private float backwardsMinArmOffset = -0.25f;
        /// <summary>
        /// 0 will prop arms up near his shoulders. -0.3 will place hands nearer his behind
        /// </summary>
        [EuphoriaDetail("0 will prop arms up near his shoulders. -0.3 will place hands nearer his behind")]
        public float BackwardsMinArmOffset
        {
            get { return backwardsMinArmOffset; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 0.0f);
                SetArgument("backwardsMinArmOffset", value);
                backwardsMinArmOffset = value;
            }
        }

        private float forwardMaxArmOffset = 0.35f;
        /// <summary>
        /// 0 will point arms down with angled body, 0.45 will point arms forward a bit to catch nearer the head
        /// </summary>
        [EuphoriaDetail("0 will point arms down with angled body, 0.45 will point arms forward a bit to catch nearer the head")]
        public float ForwardMaxArmOffset
        {
            get { return forwardMaxArmOffset; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("forwardMaxArmOffset", value);
                forwardMaxArmOffset = value;
            }
        }

        private float zAxisSpinReduction = 0.0f;
        /// <summary>
        /// Tries to reduce the spin around the Z axis. Scale 0 - 1.
        /// </summary>
        [EuphoriaDetail("Tries to reduce the spin around the Z axis. Scale 0 - 1.")]
        public float ZAxisSpinReduction
        {
            get { return zAxisSpinReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("zAxisSpinReduction", value);
                zAxisSpinReduction = value;
            }
        }

        private float extraSit = 1.0f;
        /// <summary>
        /// Scale extra-sit value 0..1. Setting to 0 helps with arched-back issues.  Set to 1 for a more alive-looking finish.
        /// </summary>
        [EuphoriaDetail("Scale extra-sit value 0..1. Setting to 0 helps with arched-back issues.  Set to 1 for a more alive-looking finish.")]
        public float ExtraSit
        {
            get { return extraSit; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("extraSit", value);
                extraSit = value;
            }
        }

        private bool useHeadLook = true;
        /// <summary>
        /// Toggle to use the head look in this behaviour.
        /// </summary>
        [EuphoriaDetail("Toggle to use the head look in this behaviour.")]
        public bool UseHeadLook
        {
            get { return useHeadLook; }
            set
            {

                SetArgument("useHeadLook", value);
                useHeadLook = value;
            }
        }

        private string mask = "fb";
        /// <summary>
        /// Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)
        /// </summary>
        [EuphoriaDetail("Two character body-masking value, bitwise joint mask or bitwise logic string of two character body-masking value  (see Active Pose notes for possible values)")]
        public string Mask
        {
            get { return mask; }
            set
            {

                SetArgument("mask", value);
                mask = value;
            }
        }


        public EuphoriaMessageCatchFall(bool startNow) : base("catchFall", startNow)
        { }

        public new void Reset()
        {
            torsoStiffness = 9.0f;
            legsStiffness = 6.0f;
            armsStiffness = 15.0f;
            backwardsMinArmOffset = -0.25f;
            forwardMaxArmOffset = 0.35f;
            zAxisSpinReduction = 0.0f;
            extraSit = 1.0f;
            useHeadLook = true;
            mask = "fb";
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageElectrocute : EuphoriaMessage
    {
        private float stunMag = 0.250f;
        /// <summary>
        /// The magnitude of the reaction
        /// </summary>
        [EuphoriaDetail("The magnitude of the reaction")]
        public float StunMag
        {
            get { return stunMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("stunMag", value);
                stunMag = value;
            }
        }

        private float initialMult = 1.00f;
        /// <summary>
        /// initialMult*stunMag = The magnitude of the 1st snap reaction (other mults are applied after this)
        /// </summary>
        [EuphoriaDetail("initialMult*stunMag = The magnitude of the 1st snap reaction (other mults are applied after this)")]
        public float InitialMult
        {
            get { return initialMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("initialMult", value);
                initialMult = value;
            }
        }

        private float largeMult = 1.00f;
        /// <summary>
        /// largeMult*stunMag = The magnitude of a random large snap reaction (other mults are applied after this)
        /// </summary>
        [EuphoriaDetail("largeMult*stunMag = The magnitude of a random large snap reaction (other mults are applied after this)")]
        public float LargeMult
        {
            get { return largeMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.0f);
                SetArgument("largeMult", value);
                largeMult = value;
            }
        }

        private float largeMinTime = 1.00f;
        /// <summary>
        /// min time to next large random snap (about 14 snaps with stunInterval = 0.07s)
        /// </summary>
        [EuphoriaDetail("min time to next large random snap (about 14 snaps with stunInterval = 0.07s)")]
        public float LargeMinTime
        {
            get { return largeMinTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 200.00f);
                SetArgument("largeMinTime", value);
                largeMinTime = value;
            }
        }

        private float largeMaxTime = 2.00f;
        /// <summary>
        /// max time to next large random snap (about 28 snaps with stunInterval = 0.07s)
        /// </summary>
        [EuphoriaDetail("max time to next large random snap (about 28 snaps with stunInterval = 0.07s)")]
        public float LargeMaxTime
        {
            get { return largeMaxTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 200.00f);
                SetArgument("largeMaxTime", value);
                largeMaxTime = value;
            }
        }

        private float movingMult = 1.00f;
        /// <summary>
        /// movingMult*stunMag = The magnitude of the reaction if moving(comVelMag) faster than movingThresh
        /// </summary>
        [EuphoriaDetail("movingMult*stunMag = The magnitude of the reaction if moving(comVelMag) faster than movingThresh")]
        public float MovingMult
        {
            get { return movingMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("movingMult", value);
                movingMult = value;
            }
        }

        private float balancingMult = 1.00f;
        /// <summary>
        /// balancingMult*stunMag = The magnitude of the reaction if balancing = (not lying on the floor/ not upper body not collided) and not airborne
        /// </summary>
        [EuphoriaDetail("balancingMult*stunMag = The magnitude of the reaction if balancing = (not lying on the floor/ not upper body not collided) and not airborne")]
        public float BalancingMult
        {
            get { return balancingMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("balancingMult", value);
                balancingMult = value;
            }
        }

        private float airborneMult = 1.00f;
        /// <summary>
        /// airborneMult*stunMag = The magnitude of the reaction if airborne
        /// </summary>
        [EuphoriaDetail("airborneMult*stunMag = The magnitude of the reaction if airborne")]
        public float AirborneMult
        {
            get { return airborneMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("airborneMult", value);
                airborneMult = value;
            }
        }

        private float movingThresh = 1.00f;
        /// <summary>
        /// If moving(comVelMag) faster than movingThresh then mvingMult applied to stunMag
        /// </summary>
        [EuphoriaDetail("If moving(comVelMag) faster than movingThresh then mvingMult applied to stunMag")]
        public float MovingThresh
        {
            get { return movingThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.00f);
                SetArgument("movingThresh", value);
                movingThresh = value;
            }
        }

        private float stunInterval = 0.070f;
        /// <summary>
        /// Direction flips every stunInterval
        /// </summary>
        [EuphoriaDetail("Direction flips every stunInterval")]
        public float StunInterval
        {
            get { return stunInterval; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("stunInterval", value);
                stunInterval = value;
            }
        }

        private float directionRandomness = 0.30f;
        /// <summary>
        /// The character vibrates in a prescribed way - Higher the value the more random this direction is.
        /// </summary>
        [EuphoriaDetail("The character vibrates in a prescribed way - Higher the value the more random this direction is.")]
        public float DirectionRandomness
        {
            get { return directionRandomness; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("directionRandomness", value);
                directionRandomness = value;
            }
        }

        private bool leftArm = true;
        /// <summary>
        /// vibrate the leftArm.
        /// </summary>
        [EuphoriaDetail("vibrate the leftArm.")]
        public bool LeftArm
        {
            get { return leftArm; }
            set
            {

                SetArgument("leftArm", value);
                leftArm = value;
            }
        }

        private bool rightArm = true;
        /// <summary>
        /// vibrate the rightArm.
        /// </summary>
        [EuphoriaDetail("vibrate the rightArm.")]
        public bool RightArm
        {
            get { return rightArm; }
            set
            {

                SetArgument("rightArm", value);
                rightArm = value;
            }
        }

        private bool leftLeg = true;
        /// <summary>
        /// vibrate the leftLeg.
        /// </summary>
        [EuphoriaDetail("vibrate the leftLeg.")]
        public bool LeftLeg
        {
            get { return leftLeg; }
            set
            {

                SetArgument("leftLeg", value);
                leftLeg = value;
            }
        }

        private bool rightLeg = true;
        /// <summary>
        /// vibrate the rightLeg.
        /// </summary>
        [EuphoriaDetail("vibrate the rightLeg.")]
        public bool RightLeg
        {
            get { return rightLeg; }
            set
            {

                SetArgument("rightLeg", value);
                rightLeg = value;
            }
        }

        private bool spine = true;
        /// <summary>
        /// vibrate the spine.
        /// </summary>
        [EuphoriaDetail("vibrate the spine.")]
        public bool Spine
        {
            get { return spine; }
            set
            {

                SetArgument("spine", value);
                spine = value;
            }
        }

        private bool neck = true;
        /// <summary>
        /// vibrate the neck.
        /// </summary>
        [EuphoriaDetail("vibrate the neck.")]
        public bool Neck
        {
            get { return neck; }
            set
            {

                SetArgument("neck", value);
                neck = value;
            }
        }

        private bool phasedLegs = true;
        /// <summary>
        /// Legs are either in phase with each other or not
        /// </summary>
        [EuphoriaDetail("Legs are either in phase with each other or not")]
        public bool PhasedLegs
        {
            get { return phasedLegs; }
            set
            {

                SetArgument("phasedLegs", value);
                phasedLegs = value;
            }
        }

        private bool applyStiffness = true;
        /// <summary>
        /// let electrocute apply a (higher generally) stiffness to the character whilst being vibrated
        /// </summary>
        [EuphoriaDetail("let electrocute apply a (higher generally) stiffness to the character whilst being vibrated")]
        public bool ApplyStiffness
        {
            get { return applyStiffness; }
            set
            {

                SetArgument("applyStiffness", value);
                applyStiffness = value;
            }
        }

        private bool useTorques = true;
        /// <summary>
        /// use torques to make vibration otherwise use a change in the parts angular velocity
        /// </summary>
        [EuphoriaDetail("use torques to make vibration otherwise use a change in the parts angular velocity")]
        public bool UseTorques
        {
            get { return useTorques; }
            set
            {

                SetArgument("useTorques", value);
                useTorques = value;
            }
        }

        private int hipType = 2;
        /// <summary>
        /// type of hip reaction 0=none, 1=side2side 2=steplike
        /// </summary>
        [EuphoriaDetail("type of hip reaction 0=none, 1=side2side 2=steplike")]
        public int HipType
        {
            get { return hipType; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("hipType", value);
                hipType = value;
            }
        }


        public EuphoriaMessageElectrocute(bool startNow) : base("electrocute", startNow)
        { }

        public new void Reset()
        {
            stunMag = 0.250f;
            initialMult = 1.00f;
            largeMult = 1.00f;
            largeMinTime = 1.00f;
            largeMaxTime = 2.00f;
            movingMult = 1.00f;
            balancingMult = 1.00f;
            airborneMult = 1.00f;
            movingThresh = 1.00f;
            stunInterval = 0.070f;
            directionRandomness = 0.30f;
            leftArm = true;
            rightArm = true;
            leftLeg = true;
            rightLeg = true;
            spine = true;
            neck = true;
            phasedLegs = true;
            applyStiffness = true;
            useTorques = true;
            hipType = 2;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageFallOverWall : EuphoriaMessage
    {
        private float bodyStiffness = 9.000f;
        /// <summary>
        /// stiffness of the body, roll up stiffness scales with this and defaults at this default value
        /// </summary>
        [EuphoriaDetail("stiffness of the body, roll up stiffness scales with this and defaults at this default value")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private float damping = 0.500f;
        /// <summary>
        /// Damping in the effectors
        /// </summary>
        [EuphoriaDetail("Damping in the effectors")]
        public float Damping
        {
            get { return damping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("damping", value);
                damping = value;
            }
        }

        private float magOfForce = 0.50f;
        /// <summary>
        /// Magnitude of the falloverWall helper force
        /// </summary>
        [EuphoriaDetail("Magnitude of the falloverWall helper force")]
        public float MagOfForce
        {
            get { return magOfForce; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("magOfForce", value);
                magOfForce = value;
            }
        }

        private float maxDistanceFromPelToHitPoint = 0.250f;
        /// <summary>
        /// The maximum distance away from the pelvis that hit points will be registered.
        /// </summary>
        [EuphoriaDetail("The maximum distance away from the pelvis that hit points will be registered.")]
        public float MaxDistanceFromPelToHitPoint
        {
            get { return maxDistanceFromPelToHitPoint; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 1.00f);
                SetArgument("maxDistanceFromPelToHitPoint", value);
                maxDistanceFromPelToHitPoint = value;
            }
        }

        private float maxForceDist = 0.80f;
        /// <summary>
        /// maximum distance between hitPoint and body part at which forces are applied to part
        /// </summary>
        [EuphoriaDetail("maximum distance between hitPoint and body part at which forces are applied to part")]
        public float MaxForceDist
        {
            get { return maxForceDist; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 2.00f);
                SetArgument("maxForceDist", value);
                maxForceDist = value;
            }
        }

        private float stepExclusionZone = 0.50f;
        /// <summary>
        /// Specifies extent of area in front of the wall in which balancer won't try to take another step
        /// </summary>
        [EuphoriaDetail("Specifies extent of area in front of the wall in which balancer won't try to take another step")]
        public float StepExclusionZone
        {
            get { return stepExclusionZone; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 2.00f);
                SetArgument("stepExclusionZone", value);
                stepExclusionZone = value;
            }
        }

        private float minLegHeight = 0.40f;
        /// <summary>
        /// minimum height of pelvis above feet at which fallOverWall is attempted
        /// </summary>
        [EuphoriaDetail("minimum height of pelvis above feet at which fallOverWall is attempted")]
        public float MinLegHeight
        {
            get { return minLegHeight; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 2.00f);
                SetArgument("minLegHeight", value);
                minLegHeight = value;
            }
        }

        private float bodyTwist = 0.540f;
        /// <summary>
        /// amount of twist to apply to the spine as the character tries to fling himself over the wall, provides more of a believable roll but increases the amount of lateral space the character needs to successfully flip.
        /// </summary>
        [EuphoriaDetail("amount of twist to apply to the spine as the character tries to fling himself over the wall, provides more of a believable roll but increases the amount of lateral space the character needs to successfully flip.")]
        public float BodyTwist
        {
            get { return bodyTwist; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("bodyTwist", value);
                bodyTwist = value;
            }
        }

        private float maxTwist = 3.141593f;
        /// <summary>
        /// max angle the character can twist before twsit helper torques are turned off
        /// </summary>
        [EuphoriaDetail("max angle the character can twist before twsit helper torques are turned off")]
        public float MaxTwist
        {
            get { return maxTwist; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("maxTwist", value);
                maxTwist = value;
            }
        }

        private Vector3 fallOverWallEndA = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// One end of the wall to try to fall over.
        /// </summary>
        [EuphoriaDetail("One end of the wall to try to fall over.")]
        public Vector3 FallOverWallEndA
        {
            get { return fallOverWallEndA; }
            set
            {

                SetArgument("fallOverWallEndA", value);
                fallOverWallEndA = value;
            }
        }

        private Vector3 fallOverWallEndB = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// One end of the wall over which we are trying to fall over.
        /// </summary>
        [EuphoriaDetail("One end of the wall over which we are trying to fall over.")]
        public Vector3 FallOverWallEndB
        {
            get { return fallOverWallEndB; }
            set
            {

                SetArgument("fallOverWallEndB", value);
                fallOverWallEndB = value;
            }
        }

        private float forceAngleAbort = -0.20f;
        /// <summary>
        /// The angle abort threshold.
        /// </summary>
        [EuphoriaDetail("The angle abort threshold.")]
        public float ForceAngleAbort
        {
            get { return forceAngleAbort; }
            set
            {

                SetArgument("forceAngleAbort", value);
                forceAngleAbort = value;
            }
        }

        private float forceTimeOut = 2.00f;
        /// <summary>
        /// The force time out.
        /// </summary>
        [EuphoriaDetail("The force time out.")]
        public float ForceTimeOut
        {
            get { return forceTimeOut; }
            set
            {

                SetArgument("forceTimeOut", value);
                forceTimeOut = value;
            }
        }

        private bool moveArms = true;
        /// <summary>
        /// Lift the arms up if true.  Do nothing with the arms if false (eg when using catchfall arms or brace etc)
        /// </summary>
        [EuphoriaDetail("Lift the arms up if true.  Do nothing with the arms if false (eg when using catchfall arms or brace etc)")]
        public bool MoveArms
        {
            get { return moveArms; }
            set
            {

                SetArgument("moveArms", value);
                moveArms = value;
            }
        }

        private bool moveLegs = true;
        /// <summary>
        /// Move the legs if true.  Do nothing with the legs if false (eg when using dynamicBalancer etc)
        /// </summary>
        [EuphoriaDetail("Move the legs if true.  Do nothing with the legs if false (eg when using dynamicBalancer etc)")]
        public bool MoveLegs
        {
            get { return moveLegs; }
            set
            {

                SetArgument("moveLegs", value);
                moveLegs = value;
            }
        }

        private bool bendSpine = true;
        /// <summary>
        /// Bend spine to help falloverwall if true.  Do nothing with the spine if false.
        /// </summary>
        [EuphoriaDetail("Bend spine to help falloverwall if true.  Do nothing with the spine if false.")]
        public bool BendSpine
        {
            get { return bendSpine; }
            set
            {

                SetArgument("bendSpine", value);
                bendSpine = value;
            }
        }

        private float angleDirWithWallNormal = 180.00f;
        /// <summary>
        /// Maximum angle in degrees (between the direction of the velocity of the COM and the wall normal) to start to apply forces and torques to fall over the wall.
        /// </summary>
        [EuphoriaDetail("Maximum angle in degrees (between the direction of the velocity of the COM and the wall normal) to start to apply forces and torques to fall over the wall.")]
        public float AngleDirWithWallNormal
        {
            get { return angleDirWithWallNormal; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("angleDirWithWallNormal", value);
                angleDirWithWallNormal = value;
            }
        }

        private float leaningAngleThreshold = 180.00f;
        /// <summary>
        /// Maximum angle in degrees (between the vertical vector and a vector from pelvis to lower neck) to start to apply forces and torques to fall over the wall.
        /// </summary>
        [EuphoriaDetail("Maximum angle in degrees (between the vertical vector and a vector from pelvis to lower neck) to start to apply forces and torques to fall over the wall.")]
        public float LeaningAngleThreshold
        {
            get { return leaningAngleThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("leaningAngleThreshold", value);
                leaningAngleThreshold = value;
            }
        }

        private float maxAngVel = 2.00f;
        /// <summary>
        /// if the angular velocity is higher than maxAngVel, the torques and forces are not applied.
        /// </summary>
        [EuphoriaDetail("if the angular velocity is higher than maxAngVel, the torques and forces are not applied.")]
        public float MaxAngVel
        {
            get { return maxAngVel; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 30.00f);
                SetArgument("maxAngVel", value);
                maxAngVel = value;
            }
        }

        private bool adaptForcesToLowWall = false;
        /// <summary>
        /// Will reduce the magnitude of the forces applied to the character to help him to fall over wall
        /// </summary>
        [EuphoriaDetail("Will reduce the magnitude of the forces applied to the character to help him to fall over wall")]
        public bool AdaptForcesToLowWall
        {
            get { return adaptForcesToLowWall; }
            set
            {

                SetArgument("adaptForcesToLowWall", value);
                adaptForcesToLowWall = value;
            }
        }

        private float maxWallHeight = -1.00f;
        /// <summary>
        /// Maximum height (from the lowest foot) to start to apply forces and torques to fall over the wall.
        /// </summary>
        [EuphoriaDetail("Maximum height (from the lowest foot) to start to apply forces and torques to fall over the wall.")]
        public float MaxWallHeight
        {
            get { return maxWallHeight; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 3.00f);
                SetArgument("maxWallHeight", value);
                maxWallHeight = value;
            }
        }

        private float distanceToSendSuccessMessage = -1.00f;
        /// <summary>
        /// Minimum distance between the pelvis and the wall to send the success message. If negative doesn't take this parameter into account when sending feedback.
        /// </summary>
        [EuphoriaDetail("Minimum distance between the pelvis and the wall to send the success message. If negative doesn't take this parameter into account when sending feedback.")]
        public float DistanceToSendSuccessMessage
        {
            get { return distanceToSendSuccessMessage; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 3.00f);
                SetArgument("distanceToSendSuccessMessage", value);
                distanceToSendSuccessMessage = value;
            }
        }

        private float rollingBackThr = 0.50f;
        /// <summary>
        /// Value of the angular velocity about the wallEgde above which the character is considered as rolling backwards i.e. goes in to fow_RollingBack state
        /// </summary>
        [EuphoriaDetail("Value of the angular velocity about the wallEgde above which the character is considered as rolling backwards i.e. goes in to fow_RollingBack state")]
        public float RollingBackThr
        {
            get { return rollingBackThr; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("rollingBackThr", value);
                rollingBackThr = value;
            }
        }

        private float rollingPotential = 0.30f;
        /// <summary>
        /// On impact with the wall if the rollingPotential(calculated from the characters linear velocity w.r.t the wall) is greater than this value the character will try to go over the wall otherwise it won't try (fow_Aborted).
        /// </summary>
        [EuphoriaDetail("On impact with the wall if the rollingPotential(calculated from the characters linear velocity w.r.t the wall) is greater than this value the character will try to go over the wall otherwise it won't try (fow_Aborted).")]
        public float RollingPotential
        {
            get { return rollingPotential; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 10.00f);
                SetArgument("rollingPotential", value);
                rollingPotential = value;
            }
        }

        private bool useArmIK = false;
        /// <summary>
        /// Try to reach the wallEdge. To configure the IK : use limitAngleBack, limitAngleFront and limitAngleTotallyBack.
        /// </summary>
        [EuphoriaDetail("Try to reach the wallEdge. To configure the IK : use limitAngleBack, limitAngleFront and limitAngleTotallyBack.")]
        public bool UseArmIK
        {
            get { return useArmIK; }
            set
            {

                SetArgument("useArmIK", value);
                useArmIK = value;
            }
        }

        private float reachDistanceFromHitPoint = 0.30f;
        /// <summary>
        /// distance from predicted hitpoint where each hands will try to reach the wall.
        /// </summary>
        [EuphoriaDetail("distance from predicted hitpoint where each hands will try to reach the wall.")]
        public float ReachDistanceFromHitPoint
        {
            get { return reachDistanceFromHitPoint; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("reachDistanceFromHitPoint", value);
                reachDistanceFromHitPoint = value;
            }
        }

        private float minReachDistanceFromHitPoint = 0.10f;
        /// <summary>
        /// minimal distance from predicted hitpoint where each hands will try to reach the wall. Used if the hand target is outside the wall Edge.
        /// </summary>
        [EuphoriaDetail("minimal distance from predicted hitpoint where each hands will try to reach the wall. Used if the hand target is outside the wall Edge.")]
        public float MinReachDistanceFromHitPoint
        {
            get { return minReachDistanceFromHitPoint; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("minReachDistanceFromHitPoint", value);
                minReachDistanceFromHitPoint = value;
            }
        }

        private float angleTotallyBack = 15.00f;
        /// <summary>
        /// max angle in degrees (between 1.the vector between two hips and 2. wallEdge) to try to reach the wall just behind his pelvis with his arms when the character is back to the wall.
        /// </summary>
        [EuphoriaDetail("max angle in degrees (between 1.the vector between two hips and 2. wallEdge) to try to reach the wall just behind his pelvis with his arms when the character is back to the wall.")]
        public float AngleTotallyBack
        {
            get { return angleTotallyBack; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("angleTotallyBack", value);
                angleTotallyBack = value;
            }
        }


        public EuphoriaMessageFallOverWall(bool startNow) : base("fallOverWall", startNow)
        { }

        public new void Reset()
        {
            bodyStiffness = 9.000f;
            damping = 0.500f;
            magOfForce = 0.50f;
            maxDistanceFromPelToHitPoint = 0.250f;
            maxForceDist = 0.80f;
            stepExclusionZone = 0.50f;
            minLegHeight = 0.40f;
            bodyTwist = 0.540f;
            maxTwist = 3.141593f;
            fallOverWallEndA = new Vector3(0f, 0f, 0f);
            fallOverWallEndB = new Vector3(0f, 0f, 0f);
            forceAngleAbort = -0.20f;
            forceTimeOut = 2.00f;
            moveArms = true;
            moveLegs = true;
            bendSpine = true;
            angleDirWithWallNormal = 180.00f;
            leaningAngleThreshold = 180.00f;
            maxAngVel = 2.00f;
            adaptForcesToLowWall = false;
            maxWallHeight = -1.00f;
            distanceToSendSuccessMessage = -1.00f;
            rollingBackThr = 0.50f;
            rollingPotential = 0.30f;
            useArmIK = false;
            reachDistanceFromHitPoint = 0.30f;
            minReachDistanceFromHitPoint = 0.10f;
            angleTotallyBack = 15.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageGrab : EuphoriaMessage
    {
        private bool useLeft = false;
        /// <summary>
        /// Flag to toggle use of left hand
        /// </summary>
        [EuphoriaDetail("Flag to toggle use of left hand")]
        public bool UseLeft
        {
            get { return useLeft; }
            set
            {

                SetArgument("useLeft", value);
                useLeft = value;
            }
        }

        private bool useRight = false;
        /// <summary>
        /// Flag to toggle the use of the Right hand
        /// </summary>
        [EuphoriaDetail("Flag to toggle the use of the Right hand")]
        public bool UseRight
        {
            get { return useRight; }
            set
            {

                SetArgument("useRight", value);
                useRight = value;
            }
        }

        private bool dropWeaponIfNecessary = false;
        /// <summary>
        /// if hasn't grabbed when weapon carrying hand is close to target, grab anyway
        /// </summary>
        [EuphoriaDetail("if hasn't grabbed when weapon carrying hand is close to target, grab anyway")]
        public bool DropWeaponIfNecessary
        {
            get { return dropWeaponIfNecessary; }
            set
            {

                SetArgument("dropWeaponIfNecessary", value);
                dropWeaponIfNecessary = value;
            }
        }

        private float dropWeaponDistance = 0.30f;
        /// <summary>
        /// distance below which a weapon carrying hand will request weapon to be dropped
        /// </summary>
        [EuphoriaDetail("distance below which a weapon carrying hand will request weapon to be dropped")]
        public float DropWeaponDistance
        {
            get { return dropWeaponDistance; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("dropWeaponDistance", value);
                dropWeaponDistance = value;
            }
        }

        private float grabStrength = -1.0f;
        /// <summary>
        /// strength in hands for grabbing (kg m/s), -1 to ignore/disable
        /// </summary>
        [EuphoriaDetail("strength in hands for grabbing (kg m/s), -1 to ignore/disable")]
        public float GrabStrength
        {
            get { return grabStrength; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 10000.0f);
                SetArgument("grabStrength", value);
                grabStrength = value;
            }
        }

        private float stickyHands = 4.0f;
        /// <summary>
        /// strength of cheat force on hands to pull towards target and stick to target ("cleverHandIK" strength)
        /// </summary>
        [EuphoriaDetail("strength of cheat force on hands to pull towards target and stick to target (\"cleverHandIK\" strength)")]
        public float StickyHands
        {
            get { return stickyHands; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("stickyHands", value);
                stickyHands = value;
            }
        }

        private int turnToTarget = 1;
        /// <summary>
        /// 0=don't turn, 1=turnToTarget, 2=turnAwayFromTarget
        /// </summary>
        [EuphoriaDetail("0=don't turn, 1=turnToTarget, 2=turnAwayFromTarget")]
        public int TurnToTarget
        {
            get { return turnToTarget; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("turnToTarget", value);
                turnToTarget = value;
            }
        }

        private float grabHoldMaxTimer = 100.0f;
        /// <summary>
        /// amount of time, in seconds, before grab automatically bails
        /// </summary>
        [EuphoriaDetail("amount of time, in seconds, before grab automatically bails")]
        public float GrabHoldMaxTimer
        {
            get { return grabHoldMaxTimer; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1000.0f);
                SetArgument("grabHoldMaxTimer", value);
                grabHoldMaxTimer = value;
            }
        }

        private float pullUpTime = 1.0f;
        /// <summary>
        /// Time to reach the full pullup strength
        /// </summary>
        [EuphoriaDetail("Time to reach the full pullup strength")]
        public float PullUpTime
        {
            get { return pullUpTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("pullUpTime", value);
                pullUpTime = value;
            }
        }

        private float pullUpStrengthRight = 0.0f;
        /// <summary>
        /// Strength to pull up with the right arm. 0 = no pull up.
        /// </summary>
        [EuphoriaDetail("Strength to pull up with the right arm. 0 = no pull up.")]
        public float PullUpStrengthRight
        {
            get { return pullUpStrengthRight; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("pullUpStrengthRight", value);
                pullUpStrengthRight = value;
            }
        }

        private float pullUpStrengthLeft = 0.0f;
        /// <summary>
        /// Strength to pull up with the left arm. 0 = no pull up.
        /// </summary>
        [EuphoriaDetail("Strength to pull up with the left arm. 0 = no pull up.")]
        public float PullUpStrengthLeft
        {
            get { return pullUpStrengthLeft; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("pullUpStrengthLeft", value);
                pullUpStrengthLeft = value;
            }
        }

        private Vector3 pos1 = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Grab pos1, right hand if not using line or surface grab.
        /// </summary>
        [EuphoriaDetail("Grab pos1, right hand if not using line or surface grab.")]
        public Vector3 Pos1
        {
            get { return pos1; }
            set
            {

                SetArgument("pos1", value);
                pos1 = value;
            }
        }

        private Vector3 pos2 = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Grab pos2, left hand if not using line or surface grab.
        /// </summary>
        [EuphoriaDetail("Grab pos2, left hand if not using line or surface grab.")]
        public Vector3 Pos2
        {
            get { return pos2; }
            set
            {

                SetArgument("pos2", value);
                pos2 = value;
            }
        }

        private Vector3 pos3 = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public Vector3 Pos3
        {
            get { return pos3; }
            set
            {

                SetArgument("pos3", value);
                pos3 = value;
            }
        }

        private Vector3 pos4 = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public Vector3 Pos4
        {
            get { return pos4; }
            set
            {

                SetArgument("pos4", value);
                pos4 = value;
            }
        }

        private Vector3 normalR = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Normal for the right grab point.
        /// </summary>
        [EuphoriaDetail("Normal for the right grab point.")]
        public Vector3 NormalR
        {
            get { return normalR; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -1.0f, 1.0f);
                value.Y = MathHelper.Clamp(value.Y, -1.0f, 1.0f);
                value.Z = MathHelper.Clamp(value.Z, -1.0f, 1.0f);
                SetArgument("normalR", value);
                normalR = value;
            }
        }

        private Vector3 normalL = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Normal for the left grab point.
        /// </summary>
        [EuphoriaDetail("Normal for the left grab point.")]
        public Vector3 NormalL
        {
            get { return normalL; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -1.0f, 1.0f);
                value.Y = MathHelper.Clamp(value.Y, -1.0f, 1.0f);
                value.Z = MathHelper.Clamp(value.Z, -1.0f, 1.0f);
                SetArgument("normalL", value);
                normalL = value;
            }
        }

        private Vector3 normalR2 = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Normal for the 2nd right grab point (if pointsX4grab=true).
        /// </summary>
        [EuphoriaDetail("Normal for the 2nd right grab point (if pointsX4grab=true).")]
        public Vector3 NormalR2
        {
            get { return normalR2; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -1.0f, 1.0f);
                value.Y = MathHelper.Clamp(value.Y, -1.0f, 1.0f);
                value.Z = MathHelper.Clamp(value.Z, -1.0f, 1.0f);
                SetArgument("normalR2", value);
                normalR2 = value;
            }
        }

        private Vector3 normalL2 = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Normal for the 3rd left grab point (if pointsX4grab=true).
        /// </summary>
        [EuphoriaDetail("Normal for the 3rd left grab point (if pointsX4grab=true).")]
        public Vector3 NormalL2
        {
            get { return normalL2; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -1.0f, 1.0f);
                value.Y = MathHelper.Clamp(value.Y, -1.0f, 1.0f);
                value.Z = MathHelper.Clamp(value.Z, -1.0f, 1.0f);
                SetArgument("normalL2", value);
                normalL2 = value;
            }
        }

        private bool handsCollide = false;
        /// <summary>
        /// Hand collisions on when grabbing (false turns off hand collisions making grab more stable esp. to grab points slightly inside geometry)
        /// </summary>
        [EuphoriaDetail("Hand collisions on when grabbing (false turns off hand collisions making grab more stable esp. to grab points slightly inside geometry)")]
        public bool HandsCollide
        {
            get { return handsCollide; }
            set
            {

                SetArgument("handsCollide", value);
                handsCollide = value;
            }
        }

        private bool justBrace = false;
        /// <summary>
        /// Flag to toggle between grabbing and bracing
        /// </summary>
        [EuphoriaDetail("Flag to toggle between grabbing and bracing")]
        public bool JustBrace
        {
            get { return justBrace; }
            set
            {

                SetArgument("justBrace", value);
                justBrace = value;
            }
        }

        private bool useLineGrab = false;
        /// <summary>
        /// use the line grab, Grab along the line (x-x2)
        /// </summary>
        [EuphoriaDetail("use the line grab, Grab along the line (x-x2)")]
        public bool UseLineGrab
        {
            get { return useLineGrab; }
            set
            {

                SetArgument("useLineGrab", value);
                useLineGrab = value;
            }
        }

        private bool pointsX4grab = false;
        /// <summary>
        /// use 2 point
        /// </summary>
        [EuphoriaDetail("use 2 point")]
        public bool PointsX4grab
        {
            get { return pointsX4grab; }
            set
            {

                SetArgument("pointsX4grab", value);
                pointsX4grab = value;
            }
        }

        private bool fromEA = false;
        /// <summary>
        /// use 2 point
        /// </summary>
        [EuphoriaDetail("use 2 point")]
        public bool FromEA
        {
            get { return fromEA; }
            set
            {

                SetArgument("fromEA", value);
                fromEA = value;
            }
        }

        private bool surfaceGrab = false;
        /// <summary>
        /// Toggle surface grab on. Requires pos1,pos2,pos3 and pos4 to be specified.
        /// </summary>
        [EuphoriaDetail("Toggle surface grab on. Requires pos1,pos2,pos3 and pos4 to be specified.")]
        public bool SurfaceGrab
        {
            get { return surfaceGrab; }
            set
            {

                SetArgument("surfaceGrab", value);
                surfaceGrab = value;
            }
        }

        private int instanceIndex = -1;
        /// <summary>
        /// levelIndex of instance to grab (-1 = world coordinates)
        /// </summary>
        [EuphoriaDetail("levelIndex of instance to grab (-1 = world coordinates)")]
        public int InstanceIndex
        {
            get { return instanceIndex; }
            set
            {

                SetArgument("instanceIndex", value);
                instanceIndex = value;
            }
        }

        private int instancePartIndex = 0;
        /// <summary>
        /// boundIndex of part on instance to grab (0 = just use instance coordinates)
        /// </summary>
        [EuphoriaDetail("boundIndex of part on instance to grab (0 = just use instance coordinates)")]
        public int InstancePartIndex
        {
            get { return instancePartIndex; }
            set
            {

                SetArgument("instancePartIndex", value);
                instancePartIndex = value;
            }
        }

        private bool dontLetGo = false;
        /// <summary>
        /// Once a constraint is made, keep reaching with whatever hand is allowed - no matter what the angle/distance and whether or not the constraint has broken due to constraintForce  GT  grabStrength.  mmmtodo this is a badly named parameter
        /// </summary>
        [EuphoriaDetail("Once a constraint is made, keep reaching with whatever hand is allowed - no matter what the angle/distance and whether or not the constraint has broken due to constraintForce  GT  grabStrength.  mmmtodo this is a badly named parameter")]
        public bool DontLetGo
        {
            get { return dontLetGo; }
            set
            {

                SetArgument("dontLetGo", value);
                dontLetGo = value;
            }
        }

        private float bodyStiffness = 11.0f;
        /// <summary>
        /// stiffness of upper body. Scales the arm grab such that the armStiffness is default when this is at default value
        /// </summary>
        [EuphoriaDetail("stiffness of upper body. Scales the arm grab such that the armStiffness is default when this is at default value")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private float reachAngle = 2.80f;
        /// <summary>
        /// Angle from front at which the grab activates. If the point is outside this angle from front will not try to grab.
        /// </summary>
        [EuphoriaDetail("Angle from front at which the grab activates. If the point is outside this angle from front will not try to grab.")]
        public float ReachAngle
        {
            get { return reachAngle; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("reachAngle", value);
                reachAngle = value;
            }
        }

        private float oneSideReachAngle = 1.4f;
        /// <summary>
        /// Angle at which we will only reach with one hand.
        /// </summary>
        [EuphoriaDetail("Angle at which we will only reach with one hand.")]
        public float OneSideReachAngle
        {
            get { return oneSideReachAngle; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("oneSideReachAngle", value);
                oneSideReachAngle = value;
            }
        }

        private float grabDistance = 1.0f;
        /// <summary>
        /// Relative distance at which the grab starts.
        /// </summary>
        [EuphoriaDetail("Relative distance at which the grab starts.")]
        public float GrabDistance
        {
            get { return grabDistance; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("grabDistance", value);
                grabDistance = value;
            }
        }

        private float move2Radius = 0.0f;
        /// <summary>
        /// Relative distance (additional to grabDistance - doesn't try to move inside grabDistance)at which the grab tries to use the balancer to move to the grab point.
        /// </summary>
        [EuphoriaDetail("Relative distance (additional to grabDistance - doesn't try to move inside grabDistance)at which the grab tries to use the balancer to move to the grab point.")]
        public float Move2Radius
        {
            get { return move2Radius; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 14.0f);
                SetArgument("move2Radius", value);
                move2Radius = value;
            }
        }

        private float armStiffness = 14.0f;
        /// <summary>
        /// Stiffness of the arm.
        /// </summary>
        [EuphoriaDetail("Stiffness of the arm.")]
        public float ArmStiffness
        {
            get { return armStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("armStiffness", value);
                armStiffness = value;
            }
        }

        private float maxReachDistance = 0.7f;
        /// <summary>
        /// distance to reach out towards the grab point.
        /// </summary>
        [EuphoriaDetail("distance to reach out towards the grab point.")]
        public float MaxReachDistance
        {
            get { return maxReachDistance; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("maxReachDistance", value);
                maxReachDistance = value;
            }
        }

        private float orientationConstraintScale = 1.0f;
        /// <summary>
        /// scale torque used to rotate hands to face normals
        /// </summary>
        [EuphoriaDetail("scale torque used to rotate hands to face normals")]
        public float OrientationConstraintScale
        {
            get { return orientationConstraintScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("orientationConstraintScale", value);
                orientationConstraintScale = value;
            }
        }

        private float maxWristAngle = 3.141593f;
        /// <summary>
        /// When we are grabbing the max angle the wrist ccan be at before we break the grab.
        /// </summary>
        [EuphoriaDetail("When we are grabbing the max angle the wrist ccan be at before we break the grab.")]
        public float MaxWristAngle
        {
            get { return maxWristAngle; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.151593f);
                SetArgument("maxWristAngle", value);
                maxWristAngle = value;
            }
        }

        private bool useHeadLookToTarget = false;
        /// <summary>
        /// if true, the character will look at targetForHeadLook after a hand grabs until the end of the behavior. (Before grabbing it looks at the grab target)
        /// </summary>
        [EuphoriaDetail("if true, the character will look at targetForHeadLook after a hand grabs until the end of the behavior. (Before grabbing it looks at the grab target)")]
        public bool UseHeadLookToTarget
        {
            get { return useHeadLookToTarget; }
            set
            {

                SetArgument("useHeadLookToTarget", value);
                useHeadLookToTarget = value;
            }
        }

        private bool lookAtGrab = true;
        /// <summary>
        /// if true, the character will look at the grab
        /// </summary>
        [EuphoriaDetail("if true, the character will look at the grab")]
        public bool LookAtGrab
        {
            get { return lookAtGrab; }
            set
            {

                SetArgument("lookAtGrab", value);
                lookAtGrab = value;
            }
        }

        private Vector3 targetForHeadLook = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Only used if useHeadLookToTarget is true, the target in world space to look at.
        /// </summary>
        [EuphoriaDetail("Only used if useHeadLookToTarget is true, the target in world space to look at.")]
        public Vector3 TargetForHeadLook
        {
            get { return targetForHeadLook; }
            set
            {

                SetArgument("targetForHeadLook", value);
                targetForHeadLook = value;
            }
        }


        public EuphoriaMessageGrab(bool startNow) : base("grab", startNow)
        { }

        public new void Reset()
        {
            useLeft = false;
            useRight = false;
            dropWeaponIfNecessary = false;
            dropWeaponDistance = 0.30f;
            grabStrength = -1.0f;
            stickyHands = 4.0f;
            turnToTarget = 1;
            grabHoldMaxTimer = 100.0f;
            pullUpTime = 1.0f;
            pullUpStrengthRight = 0.0f;
            pullUpStrengthLeft = 0.0f;
            pos1 = new Vector3(0f, 0f, 0f);
            pos2 = new Vector3(0f, 0f, 0f);
            pos3 = new Vector3(0f, 0f, 0f);
            pos4 = new Vector3(0f, 0f, 0f);
            normalR = new Vector3(0f, 0f, 0f);
            normalL = new Vector3(0f, 0f, 0f);
            normalR2 = new Vector3(0f, 0f, 0f);
            normalL2 = new Vector3(0f, 0f, 0f);
            handsCollide = false;
            justBrace = false;
            useLineGrab = false;
            pointsX4grab = false;
            fromEA = false;
            surfaceGrab = false;
            instanceIndex = -1;
            instancePartIndex = 0;
            dontLetGo = false;
            bodyStiffness = 11.0f;
            reachAngle = 2.80f;
            oneSideReachAngle = 1.4f;
            grabDistance = 1.0f;
            move2Radius = 0.0f;
            armStiffness = 14.0f;
            maxReachDistance = 0.7f;
            orientationConstraintScale = 1.0f;
            maxWristAngle = 3.141593f;
            useHeadLookToTarget = false;
            lookAtGrab = true;
            targetForHeadLook = new Vector3(0f, 0f, 0f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageHeadLook : EuphoriaMessage
    {
        private float damping = 1.000f;
        /// <summary>
        /// Damping  of the muscles
        /// </summary>
        [EuphoriaDetail("Damping  of the muscles")]
        public float Damping
        {
            get { return damping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("damping", value);
                damping = value;
            }
        }

        private float stiffness = 10.000f;
        /// <summary>
        /// Stiffness of the muscles
        /// </summary>
        [EuphoriaDetail("Stiffness of the muscles")]
        public float Stiffness
        {
            get { return stiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("stiffness", value);
                stiffness = value;
            }
        }

        private int instanceIndex = -1;
        /// <summary>
        /// levelIndex of object to be looked at. vel parameters are ignored if this is non -1
        /// </summary>
        [EuphoriaDetail("levelIndex of object to be looked at. vel parameters are ignored if this is non -1")]
        public int InstanceIndex
        {
            get { return instanceIndex; }
            set
            {

                SetArgument("instanceIndex", value);
                instanceIndex = value;
            }
        }

        private Vector3 vel = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// The velocity of the point being looked at
        /// </summary>
        [EuphoriaDetail("The velocity of the point being looked at")]
        public Vector3 Vel
        {
            get { return vel; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -100.0f, 100.0f);
                value.Y = MathHelper.Clamp(value.Y, -100.0f, 100.0f);
                value.Z = MathHelper.Clamp(value.Z, -100.0f, 100.0f);
                SetArgument("vel", value);
                vel = value;
            }
        }

        private Vector3 pos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// The point being looked at
        /// </summary>
        [EuphoriaDetail("The point being looked at")]
        public Vector3 Pos
        {
            get { return pos; }
            set
            {

                SetArgument("pos", value);
                pos = value;
            }
        }

        private bool alwaysLook = false;
        /// <summary>
        /// Flag to force always to look
        /// </summary>
        [EuphoriaDetail("Flag to force always to look")]
        public bool AlwaysLook
        {
            get { return alwaysLook; }
            set
            {

                SetArgument("alwaysLook", value);
                alwaysLook = value;
            }
        }

        private bool eyesHorizontal = true;
        /// <summary>
        /// Keep the eyes horizontal.  Use true for impact with cars.  Use false if you want better look at target accuracy when the character is on the floor or leaned over alot.
        /// </summary>
        [EuphoriaDetail("Keep the eyes horizontal.  Use true for impact with cars.  Use false if you want better look at target accuracy when the character is on the floor or leaned over alot.")]
        public bool EyesHorizontal
        {
            get { return eyesHorizontal; }
            set
            {

                SetArgument("eyesHorizontal", value);
                eyesHorizontal = value;
            }
        }

        private bool alwaysEyesHorizontal = true;
        /// <summary>
        /// Keep the eyes horizontal.  Use true for impact with cars.  Use false if you want better look at target accuracy when the character is on the floor or leaned over (when not leaned over the eyes are still kept horizontal if eyesHorizontal=true ) alot.
        /// </summary>
        [EuphoriaDetail("Keep the eyes horizontal.  Use true for impact with cars.  Use false if you want better look at target accuracy when the character is on the floor or leaned over (when not leaned over the eyes are still kept horizontal if eyesHorizontal=true ) alot.")]
        public bool AlwaysEyesHorizontal
        {
            get { return alwaysEyesHorizontal; }
            set
            {

                SetArgument("alwaysEyesHorizontal", value);
                alwaysEyesHorizontal = value;
            }
        }

        private bool keepHeadAwayFromGround = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool KeepHeadAwayFromGround
        {
            get { return keepHeadAwayFromGround; }
            set
            {

                SetArgument("keepHeadAwayFromGround", value);
                keepHeadAwayFromGround = value;
            }
        }

        private bool twistSpine = true;
        /// <summary>
        /// Allow headlook to twist spine.
        /// </summary>
        [EuphoriaDetail("Allow headlook to twist spine.")]
        public bool TwistSpine
        {
            get { return twistSpine; }
            set
            {

                SetArgument("twistSpine", value);
                twistSpine = value;
            }
        }


        public EuphoriaMessageHeadLook(bool startNow) : base("headLook", startNow)
        { }

        public new void Reset()
        {
            damping = 1.000f;
            stiffness = 10.000f;
            instanceIndex = -1;
            vel = new Vector3(0f, 0f, 0f);
            pos = new Vector3(0f, 0f, 0f);
            alwaysLook = false;
            eyesHorizontal = true;
            alwaysEyesHorizontal = true;
            keepHeadAwayFromGround = false;
            twistSpine = true;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageHighFall : EuphoriaMessage
    {
        private float bodyStiffness = 11.00f;
        /// <summary>
        /// stiffness of body. Value feeds through to bodyBalance (synched with defaults), to armsWindmill (14 for this value at default ), legs pedal, head look and roll down stairs directly
        /// </summary>
        [EuphoriaDetail("stiffness of body. Value feeds through to bodyBalance (synched with defaults), to armsWindmill (14 for this value at default ), legs pedal, head look and roll down stairs directly")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private float bodydamping = 1.00f;
        /// <summary>
        /// The damping of the joints.
        /// </summary>
        [EuphoriaDetail("The damping of the joints.")]
        public float Bodydamping
        {
            get { return bodydamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("bodydamping", value);
                bodydamping = value;
            }
        }

        private float catchfalltime = 0.300f;
        /// <summary>
        /// The length of time before the impact that the character transitions to the landing.
        /// </summary>
        [EuphoriaDetail("The length of time before the impact that the character transitions to the landing.")]
        public float Catchfalltime
        {
            get { return catchfalltime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("catchfalltime", value);
                catchfalltime = value;
            }
        }

        private float crashOrLandCutOff = 0.8680f;
        /// <summary>
        /// 0.52angle is 0.868 dot//A threshold for deciding how far away from upright the character needs to be before bailing out (going into a foetal) instead of trying to land (keeping stretched out).  NB: never does bailout if ignorWorldCollisions true
        /// </summary>
        [EuphoriaDetail("0.52angle is 0.868 dot//A threshold for deciding how far away from upright the character needs to be before bailing out (going into a foetal) instead of trying to land (keeping stretched out).  NB: never does bailout if ignorWorldCollisions true")]
        public float CrashOrLandCutOff
        {
            get { return crashOrLandCutOff; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("crashOrLandCutOff", value);
                crashOrLandCutOff = value;
            }
        }

        private float pdStrength = 0.00f;
        /// <summary>
        /// Strength of the controller to keep the character at angle aimAngleBase from vertical.
        /// </summary>
        [EuphoriaDetail("Strength of the controller to keep the character at angle aimAngleBase from vertical.")]
        public float PdStrength
        {
            get { return pdStrength; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("pdStrength", value);
                pdStrength = value;
            }
        }

        private float pdDamping = 1.00f;
        /// <summary>
        /// Damping multiplier of the controller to keep the character at angle aimAngleBase from vertical.  The actual damping is pdDamping*pdStrength*constant*angVel.
        /// </summary>
        [EuphoriaDetail("Damping multiplier of the controller to keep the character at angle aimAngleBase from vertical.  The actual damping is pdDamping*pdStrength*constant*angVel.")]
        public float PdDamping
        {
            get { return pdDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("pdDamping", value);
                pdDamping = value;
            }
        }

        private float armAngSpeed = 7.850f;
        /// <summary>
        /// arm circling speed in armWindMillAdaptive
        /// </summary>
        [EuphoriaDetail("arm circling speed in armWindMillAdaptive")]
        public float ArmAngSpeed
        {
            get { return armAngSpeed; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.0f);
                SetArgument("armAngSpeed", value);
                armAngSpeed = value;
            }
        }

        private float armAmplitude = 2.00f;
        /// <summary>
        /// in armWindMillAdaptive
        /// </summary>
        [EuphoriaDetail("in armWindMillAdaptive")]
        public float ArmAmplitude
        {
            get { return armAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("armAmplitude", value);
                armAmplitude = value;
            }
        }

        private float armPhase = 3.10f;
        /// <summary>
        /// in armWindMillAdaptive 3.1 opposite for stuntman.  1.0 old default.  0.0 in phase.
        /// </summary>
        [EuphoriaDetail("in armWindMillAdaptive 3.1 opposite for stuntman.  1.0 old default.  0.0 in phase.")]
        public float ArmPhase
        {
            get { return armPhase; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 6.283185f);
                SetArgument("armPhase", value);
                armPhase = value;
            }
        }

        private bool armBendElbows = true;
        /// <summary>
        /// in armWindMillAdaptive bend the elbows as a function of armAngle.  For stuntman true otherwise false.
        /// </summary>
        [EuphoriaDetail("in armWindMillAdaptive bend the elbows as a function of armAngle.  For stuntman true otherwise false.")]
        public bool ArmBendElbows
        {
            get { return armBendElbows; }
            set
            {

                SetArgument("armBendElbows", value);
                armBendElbows = value;
            }
        }

        private float legRadius = 0.40f;
        /// <summary>
        /// radius of legs on pedal
        /// </summary>
        [EuphoriaDetail("radius of legs on pedal")]
        public float LegRadius
        {
            get { return legRadius; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 0.50f);
                SetArgument("legRadius", value);
                legRadius = value;
            }
        }

        private float legAngSpeed = 7.850f;
        /// <summary>
        /// in pedal
        /// </summary>
        [EuphoriaDetail("in pedal")]
        public float LegAngSpeed
        {
            get { return legAngSpeed; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 15.0f);
                SetArgument("legAngSpeed", value);
                legAngSpeed = value;
            }
        }

        private float legAsymmetry = 4.00f;
        /// <summary>
        /// 0.0 for stuntman.  Random offset applied per leg to the angular speed to desynchronise the pedaling - set to 0 to disable, otherwise should be set to less than the angularSpeed value.
        /// </summary>
        [EuphoriaDetail("0.0 for stuntman.  Random offset applied per leg to the angular speed to desynchronise the pedaling - set to 0 to disable, otherwise should be set to less than the angularSpeed value.")]
        public float LegAsymmetry
        {
            get { return legAsymmetry; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 10.00f);
                SetArgument("legAsymmetry", value);
                legAsymmetry = value;
            }
        }

        private float arms2LegsPhase = 0.00f;
        /// <summary>
        /// phase angle between the arms and legs circling angle
        /// </summary>
        [EuphoriaDetail("phase angle between the arms and legs circling angle")]
        public float Arms2LegsPhase
        {
            get { return arms2LegsPhase; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 6.50f);
                SetArgument("arms2LegsPhase", value);
                arms2LegsPhase = value;
            }
        }

        private int arms2LegsSync = 1;
        /// <summary>
        /// 0=not synched, 1=always synched, 2= synch at start only.  Synchs the arms angle to what the leg angle is.  All speed/direction parameters of armswindmill are overwritten if = 1.  If 2 and you want synced arms/legs then armAngSpeed=legAngSpeed, legAsymmetry = 0.0 (to stop randomizations of the leg cicle speed)
        /// </summary>
        [EuphoriaDetail("0=not synched, 1=always synched, 2= synch at start only.  Synchs the arms angle to what the leg angle is.  All speed/direction parameters of armswindmill are overwritten if = 1.  If 2 and you want synced arms/legs then armAngSpeed=legAngSpeed, legAsymmetry = 0.0 (to stop randomizations of the leg cicle speed)")]
        public int Arms2LegsSync
        {
            get { return arms2LegsSync; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("arms2LegsSync", value);
                arms2LegsSync = value;
            }
        }

        private float armsUp = -3.10f;
        /// <summary>
        /// Where to put the arms when preparing to land. Approx 1 = above head, 0 = head height, -1 = down.   LT -2.0 use catchFall arms,  LT -3.0 use prepare for landing pose if Agent is due to land vertically, feet first.
        /// </summary>
        [EuphoriaDetail("Where to put the arms when preparing to land. Approx 1 = above head, 0 = head height, -1 = down.   LT -2.0 use catchFall arms,  LT -3.0 use prepare for landing pose if Agent is due to land vertically, feet first.")]
        public float ArmsUp
        {
            get { return armsUp; }
            set
            {
                value = MathHelper.Clamp(value, -4.00f, 2.00f);
                SetArgument("armsUp", value);
                armsUp = value;
            }
        }

        private bool orientateBodyToFallDirection = false;
        /// <summary>
        /// toggle to orientate to fall direction.  i.e. orientate so that the character faces the horizontal velocity direction
        /// </summary>
        [EuphoriaDetail("toggle to orientate to fall direction.  i.e. orientate so that the character faces the horizontal velocity direction")]
        public bool OrientateBodyToFallDirection
        {
            get { return orientateBodyToFallDirection; }
            set
            {

                SetArgument("orientateBodyToFallDirection", value);
                orientateBodyToFallDirection = value;
            }
        }

        private bool orientateTwist = true;
        /// <summary>
        /// If false don't worry about the twist angle of the character when orientating the character.  If false this allows the twist axis of the character to be free (You can get a nice twisting highFall like the one in dieHard 4 when the car goes into the helicopter)
        /// </summary>
        [EuphoriaDetail("If false don't worry about the twist angle of the character when orientating the character.  If false this allows the twist axis of the character to be free (You can get a nice twisting highFall like the one in dieHard 4 when the car goes into the helicopter)")]
        public bool OrientateTwist
        {
            get { return orientateTwist; }
            set
            {

                SetArgument("orientateTwist", value);
                orientateTwist = value;
            }
        }

        private float orientateMax = 300.00f;
        /// <summary>
        /// DEVEL parameter - suggest you don't edit it.  Maximum torque the orientation controller can apply.  If 0 then no helper torques will be used.  300 will orientate the character soflty for all but extreme angles away from aimAngleBase.  If abs (current -aimAngleBase) is getting near 3.0 then this can be reduced to give a softer feel.
        /// </summary>
        [EuphoriaDetail("DEVEL parameter - suggest you don't edit it.  Maximum torque the orientation controller can apply.  If 0 then no helper torques will be used.  300 will orientate the character soflty for all but extreme angles away from aimAngleBase.  If abs (current -aimAngleBase) is getting near 3.0 then this can be reduced to give a softer feel.")]
        public float OrientateMax
        {
            get { return orientateMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2000.00f);
                SetArgument("orientateMax", value);
                orientateMax = value;
            }
        }

        private bool alanRickman = false;
        /// <summary>
        /// If true then orientate the character to face the point from where it started falling.  HighFall like the one in dieHard with Alan Rickman
        /// </summary>
        [EuphoriaDetail("If true then orientate the character to face the point from where it started falling.  HighFall like the one in dieHard with Alan Rickman")]
        public bool AlanRickman
        {
            get { return alanRickman; }
            set
            {

                SetArgument("alanRickman", value);
                alanRickman = value;
            }
        }

        private bool fowardRoll = false;
        /// <summary>
        /// Try to execute a forward Roll on landing
        /// </summary>
        [EuphoriaDetail("Try to execute a forward Roll on landing")]
        public bool FowardRoll
        {
            get { return fowardRoll; }
            set
            {

                SetArgument("fowardRoll", value);
                fowardRoll = value;
            }
        }

        private bool useZeroPose_withFowardRoll = false;
        /// <summary>
        /// Blend to a zero pose when forward roll is attempted.
        /// </summary>
        [EuphoriaDetail("Blend to a zero pose when forward roll is attempted.")]
        public bool UseZeroPose_withFowardRoll
        {
            get { return useZeroPose_withFowardRoll; }
            set
            {

                SetArgument("useZeroPose_withFowardRoll", value);
                useZeroPose_withFowardRoll = value;
            }
        }

        private float aimAngleBase = 0.180f;
        /// <summary>
        /// Angle from vertical the pdController is driving to ( positive = forwards)
        /// </summary>
        [EuphoriaDetail("Angle from vertical the pdController is driving to ( positive = forwards)")]
        public float AimAngleBase
        {
            get { return aimAngleBase; }
            set
            {
                value = MathHelper.Clamp(value, -3.141593f, 3.141593f);
                SetArgument("aimAngleBase", value);
                aimAngleBase = value;
            }
        }

        private float fowardVelRotation = -0.020f;
        /// <summary>
        /// scale to add/subtract from aimAngle based on forward speed (Internal)
        /// </summary>
        [EuphoriaDetail("scale to add/subtract from aimAngle based on forward speed (Internal)")]
        public float FowardVelRotation
        {
            get { return fowardVelRotation; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("fowardVelRotation", value);
                fowardVelRotation = value;
            }
        }

        private float footVelCompScale = 0.050f;
        /// <summary>
        /// Scale to change to amount of vel that is added to the foot ik from the velocity (Internal)
        /// </summary>
        [EuphoriaDetail("Scale to change to amount of vel that is added to the foot ik from the velocity (Internal)")]
        public float FootVelCompScale
        {
            get { return footVelCompScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("footVelCompScale", value);
                footVelCompScale = value;
            }
        }

        private float sideD = 0.20f;
        /// <summary>
        /// sideoffset for the feet during prepareForLanding. +ve = right.
        /// </summary>
        [EuphoriaDetail("sideoffset for the feet during prepareForLanding. +ve = right.")]
        public float SideD
        {
            get { return sideD; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("sideD", value);
                sideD = value;
            }
        }

        private float fowardOffsetOfLegIK = 0.00f;
        /// <summary>
        /// Forward offset for the feet during prepareForLanding
        /// </summary>
        [EuphoriaDetail("Forward offset for the feet during prepareForLanding")]
        public float FowardOffsetOfLegIK
        {
            get { return fowardOffsetOfLegIK; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("fowardOffsetOfLegIK", value);
                fowardOffsetOfLegIK = value;
            }
        }

        private float legL = 1.00f;
        /// <summary>
        /// Leg Length for ik (Internal)//unused
        /// </summary>
        [EuphoriaDetail("Leg Length for ik (Internal)//unused")]
        public float LegL
        {
            get { return legL; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.00f);
                SetArgument("legL", value);
                legL = value;
            }
        }

        private float catchFallCutOff = 0.8780f;
        /// <summary>
        /// 0.5angle is 0.878 dot. Cutoff to go to the catchFall ( internal) //mmmtodo do like crashOrLandCutOff
        /// </summary>
        [EuphoriaDetail("0.5angle is 0.878 dot. Cutoff to go to the catchFall ( internal) //mmmtodo do like crashOrLandCutOff")]
        public float CatchFallCutOff
        {
            get { return catchFallCutOff; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("catchFallCutOff", value);
                catchFallCutOff = value;
            }
        }

        private float legStrength = 12.00f;
        /// <summary>
        /// Strength of the legs at landing
        /// </summary>
        [EuphoriaDetail("Strength of the legs at landing")]
        public float LegStrength
        {
            get { return legStrength; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.0f);
                SetArgument("legStrength", value);
                legStrength = value;
            }
        }

        private bool balance = true;
        /// <summary>
        /// If true have enough strength to balance.  If false not enough strength in legs to balance (even though bodyBlance called)
        /// </summary>
        [EuphoriaDetail("If true have enough strength to balance.  If false not enough strength in legs to balance (even though bodyBlance called)")]
        public bool Balance
        {
            get { return balance; }
            set
            {

                SetArgument("balance", value);
                balance = value;
            }
        }

        private bool ignorWorldCollisions = false;
        /// <summary>
        /// Never go into bailout (foetal)
        /// </summary>
        [EuphoriaDetail("Never go into bailout (foetal)")]
        public bool IgnorWorldCollisions
        {
            get { return ignorWorldCollisions; }
            set
            {

                SetArgument("ignorWorldCollisions", value);
                ignorWorldCollisions = value;
            }
        }

        private bool adaptiveCircling = true;
        /// <summary>
        /// stuntman type fall.  Arm and legs circling direction controlled by angmom and orientation
        /// </summary>
        [EuphoriaDetail("stuntman type fall.  Arm and legs circling direction controlled by angmom and orientation")]
        public bool AdaptiveCircling
        {
            get { return adaptiveCircling; }
            set
            {

                SetArgument("adaptiveCircling", value);
                adaptiveCircling = value;
            }
        }

        private bool hula = true;
        /// <summary>
        /// With stuntman type fall.  Hula reaction if can't see floor and not rotating fast
        /// </summary>
        [EuphoriaDetail("With stuntman type fall.  Hula reaction if can't see floor and not rotating fast")]
        public bool Hula
        {
            get { return hula; }
            set
            {

                SetArgument("hula", value);
                hula = value;
            }
        }

        private float maxSpeedForRecoverableFall = 15.00f;
        /// <summary>
        /// Character needs to be moving less than this speed to consider fall as a recoverable one.
        /// </summary>
        [EuphoriaDetail("Character needs to be moving less than this speed to consider fall as a recoverable one.")]
        public float MaxSpeedForRecoverableFall
        {
            get { return maxSpeedForRecoverableFall; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("maxSpeedForRecoverableFall", value);
                maxSpeedForRecoverableFall = value;
            }
        }

        private float minSpeedForBrace = 10.00f;
        /// <summary>
        /// Character needs to be moving at least this fast horizontally to start bracing for impact if there is an object along its trajectory.
        /// </summary>
        [EuphoriaDetail("Character needs to be moving at least this fast horizontally to start bracing for impact if there is an object along its trajectory.")]
        public float MinSpeedForBrace
        {
            get { return minSpeedForBrace; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("minSpeedForBrace", value);
                minSpeedForBrace = value;
            }
        }

        private float landingNormal = 0.60f;
        /// <summary>
        /// Ray-cast normal doted with up direction has to be greater than this number to consider object flat enough to land on it.
        /// </summary>
        [EuphoriaDetail("Ray-cast normal doted with up direction has to be greater than this number to consider object flat enough to land on it.")]
        public float LandingNormal
        {
            get { return landingNormal; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("landingNormal", value);
                landingNormal = value;
            }
        }


        public EuphoriaMessageHighFall(bool startNow) : base("highFall", startNow)
        { }

        public new void Reset()
        {
            bodyStiffness = 11.00f;
            bodydamping = 1.00f;
            catchfalltime = 0.300f;
            crashOrLandCutOff = 0.8680f;
            pdStrength = 0.00f;
            pdDamping = 1.00f;
            armAngSpeed = 7.850f;
            armAmplitude = 2.00f;
            armPhase = 3.10f;
            armBendElbows = true;
            legRadius = 0.40f;
            legAngSpeed = 7.850f;
            legAsymmetry = 4.00f;
            arms2LegsPhase = 0.00f;
            arms2LegsSync = 1;
            armsUp = -3.10f;
            orientateBodyToFallDirection = false;
            orientateTwist = true;
            orientateMax = 300.00f;
            alanRickman = false;
            fowardRoll = false;
            useZeroPose_withFowardRoll = false;
            aimAngleBase = 0.180f;
            fowardVelRotation = -0.020f;
            footVelCompScale = 0.050f;
            sideD = 0.20f;
            fowardOffsetOfLegIK = 0.00f;
            legL = 1.00f;
            catchFallCutOff = 0.8780f;
            legStrength = 12.00f;
            balance = true;
            ignorWorldCollisions = false;
            adaptiveCircling = true;
            hula = true;
            maxSpeedForRecoverableFall = 15.00f;
            minSpeedForBrace = 10.00f;
            landingNormal = 0.60f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageIncomingTransforms : EuphoriaMessage
    {

        public EuphoriaMessageIncomingTransforms(bool startNow) : base("incomingTransforms", startNow)
        { }

        public new void Reset()
        {
            base.Reset();
        }
    }


    /// <summary>
    /// InjuredOnGround
    /// </summary>
    [EuphoriaDetail("InjuredOnGround")]
    internal class EuphoriaMessageInjuredOnGround : EuphoriaMessage
    {
        private int numInjuries = 0;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public int NumInjuries
        {
            get { return numInjuries; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("numInjuries", value);
                numInjuries = value;
            }
        }

        private int injury1Component = 0;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public int Injury1Component
        {
            get { return injury1Component; }
            set
            {

                SetArgument("injury1Component", value);
                injury1Component = value;
            }
        }

        private int injury2Component = 0;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public int Injury2Component
        {
            get { return injury2Component; }
            set
            {

                SetArgument("injury2Component", value);
                injury2Component = value;
            }
        }

        private Vector3 injury1LocalPosition = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public Vector3 Injury1LocalPosition
        {
            get { return injury1LocalPosition; }
            set
            {

                SetArgument("injury1LocalPosition", value);
                injury1LocalPosition = value;
            }
        }

        private Vector3 injury2LocalPosition = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public Vector3 Injury2LocalPosition
        {
            get { return injury2LocalPosition; }
            set
            {

                SetArgument("injury2LocalPosition", value);
                injury2LocalPosition = value;
            }
        }

        private Vector3 injury1LocalNormal = new Vector3(1f, 0f, 0f);
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public Vector3 Injury1LocalNormal
        {
            get { return injury1LocalNormal; }
            set
            {
                value.X = MathHelper.Clamp(value.X, 0.0f, 1.0f);
                value.Y = MathHelper.Clamp(value.Y, 0.0f, 1.0f);
                value.Z = MathHelper.Clamp(value.Z, 0.0f, 1.0f);
                SetArgument("injury1LocalNormal", value);
                injury1LocalNormal = value;
            }
        }

        private Vector3 injury2LocalNormal = new Vector3(1f, 0f, 0f);
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public Vector3 Injury2LocalNormal
        {
            get { return injury2LocalNormal; }
            set
            {
                value.X = MathHelper.Clamp(value.X, 0.0f, 1.0f);
                value.Y = MathHelper.Clamp(value.Y, 0.0f, 1.0f);
                value.Z = MathHelper.Clamp(value.Z, 0.0f, 1.0f);
                SetArgument("injury2LocalNormal", value);
                injury2LocalNormal = value;
            }
        }

        private Vector3 attackerPos = new Vector3(1f, 0f, 0f);
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public Vector3 AttackerPos
        {
            get { return attackerPos; }
            set
            {

                SetArgument("attackerPos", value);
                attackerPos = value;
            }
        }

        private bool dontReachWithLeft = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool DontReachWithLeft
        {
            get { return dontReachWithLeft; }
            set
            {

                SetArgument("dontReachWithLeft", value);
                dontReachWithLeft = value;
            }
        }

        private bool dontReachWithRight = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool DontReachWithRight
        {
            get { return dontReachWithRight; }
            set
            {

                SetArgument("dontReachWithRight", value);
                dontReachWithRight = value;
            }
        }

        private bool strongRollForce = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool StrongRollForce
        {
            get { return strongRollForce; }
            set
            {

                SetArgument("strongRollForce", value);
                strongRollForce = value;
            }
        }


        public EuphoriaMessageInjuredOnGround(bool startNow) : base("injuredOnGround", startNow)
        { }

        public new void Reset()
        {
            numInjuries = 0;
            injury1Component = 0;
            injury2Component = 0;
            injury1LocalPosition = new Vector3(0f, 0f, 0f);
            injury2LocalPosition = new Vector3(0f, 0f, 0f);
            injury1LocalNormal = new Vector3(1f, 0f, 0f);
            injury2LocalNormal = new Vector3(1f, 0f, 0f);
            attackerPos = new Vector3(1f, 0f, 0f);
            dontReachWithLeft = false;
            dontReachWithRight = false;
            strongRollForce = false;
            base.Reset();
        }
    }


    /// <summary>
    /// Carried
    /// </summary>
    [EuphoriaDetail("Carried")]
    internal class EuphoriaMessageCarried : EuphoriaMessage
    {

        public EuphoriaMessageCarried(bool startNow) : base("carried", startNow)
        { }

        public new void Reset()
        {
            base.Reset();
        }
    }


    /// <summary>
    /// Dangle
    /// </summary>
    [EuphoriaDetail("Dangle")]
    internal class EuphoriaMessageDangle : EuphoriaMessage
    {
        private bool doGrab = true;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool DoGrab
        {
            get { return doGrab; }
            set
            {

                SetArgument("doGrab", value);
                doGrab = value;
            }
        }

        private float grabFrequency = 1.00f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float GrabFrequency
        {
            get { return grabFrequency; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("grabFrequency", value);
                grabFrequency = value;
            }
        }


        public EuphoriaMessageDangle(bool startNow) : base("dangle", startNow)
        { }

        public new void Reset()
        {
            doGrab = true;
            grabFrequency = 1.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageOnFire : EuphoriaMessage
    {
        private float staggerTime = 2.50f;
        /// <summary>
        /// Max time for stumbling around before falling to ground.
        /// </summary>
        [EuphoriaDetail("Max time for stumbling around before falling to ground.")]
        public float StaggerTime
        {
            get { return staggerTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 30.00f);
                SetArgument("staggerTime", value);
                staggerTime = value;
            }
        }

        private float staggerLeanRate = 0.90f;
        /// <summary>
        /// How quickly the character leans hips when staggering.
        /// </summary>
        [EuphoriaDetail("How quickly the character leans hips when staggering.")]
        public float StaggerLeanRate
        {
            get { return staggerLeanRate; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("staggerLeanRate", value);
                staggerLeanRate = value;
            }
        }

        private float stumbleMaxLeanBack = 0.40f;
        /// <summary>
        /// max the character leans hips back when staggering
        /// </summary>
        [EuphoriaDetail("max the character leans hips back when staggering")]
        public float StumbleMaxLeanBack
        {
            get { return stumbleMaxLeanBack; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.50f);
                SetArgument("stumbleMaxLeanBack", value);
                stumbleMaxLeanBack = value;
            }
        }

        private float stumbleMaxLeanForward = 0.50f;
        /// <summary>
        /// max the character leans hips forwards when staggering
        /// </summary>
        [EuphoriaDetail("max the character leans hips forwards when staggering")]
        public float StumbleMaxLeanForward
        {
            get { return stumbleMaxLeanForward; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.50f);
                SetArgument("stumbleMaxLeanForward", value);
                stumbleMaxLeanForward = value;
            }
        }

        private float armsWindmillWritheBlend = 0.40f;
        /// <summary>
        /// Blend armsWindmill with the bodyWrithe arms when character is upright.
        /// </summary>
        [EuphoriaDetail("Blend armsWindmill with the bodyWrithe arms when character is upright.")]
        public float ArmsWindmillWritheBlend
        {
            get { return armsWindmillWritheBlend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("armsWindmillWritheBlend", value);
                armsWindmillWritheBlend = value;
            }
        }

        private float spineStumbleWritheBlend = 0.70f;
        /// <summary>
        /// Blend spine stumble with the bodyWrithe spine when character is upright.
        /// </summary>
        [EuphoriaDetail("Blend spine stumble with the bodyWrithe spine when character is upright.")]
        public float SpineStumbleWritheBlend
        {
            get { return spineStumbleWritheBlend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("spineStumbleWritheBlend", value);
                spineStumbleWritheBlend = value;
            }
        }

        private float legsStumbleWritheBlend = 0.20f;
        /// <summary>
        /// Blend legs stumble with the bodyWrithe legs when character is upright.
        /// </summary>
        [EuphoriaDetail("Blend legs stumble with the bodyWrithe legs when character is upright.")]
        public float LegsStumbleWritheBlend
        {
            get { return legsStumbleWritheBlend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("legsStumbleWritheBlend", value);
                legsStumbleWritheBlend = value;
            }
        }

        private float armsPoseWritheBlend = 0.70f;
        /// <summary>
        /// Blend the bodyWrithe arms with the current desired pose from on fire behaviour when character is on the floor.
        /// </summary>
        [EuphoriaDetail("Blend the bodyWrithe arms with the current desired pose from on fire behaviour when character is on the floor.")]
        public float ArmsPoseWritheBlend
        {
            get { return armsPoseWritheBlend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("armsPoseWritheBlend", value);
                armsPoseWritheBlend = value;
            }
        }

        private float spinePoseWritheBlend = 0.550f;
        /// <summary>
        /// Blend the bodyWrithe back with the current desired pose from on fire behaviour when character is on the floor.
        /// </summary>
        [EuphoriaDetail("Blend the bodyWrithe back with the current desired pose from on fire behaviour when character is on the floor.")]
        public float SpinePoseWritheBlend
        {
            get { return spinePoseWritheBlend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("spinePoseWritheBlend", value);
                spinePoseWritheBlend = value;
            }
        }

        private float legsPoseWritheBlend = 0.50f;
        /// <summary>
        /// Blend the bodyWrithe legs with the current desired pose from on fire behaviour when character is on the floor.
        /// </summary>
        [EuphoriaDetail("Blend the bodyWrithe legs with the current desired pose from on fire behaviour when character is on the floor.")]
        public float LegsPoseWritheBlend
        {
            get { return legsPoseWritheBlend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("legsPoseWritheBlend", value);
                legsPoseWritheBlend = value;
            }
        }

        private bool rollOverFlag = true;
        /// <summary>
        /// Flag to set bodyWrithe trying to rollOver.
        /// </summary>
        [EuphoriaDetail("Flag to set bodyWrithe trying to rollOver.")]
        public bool RollOverFlag
        {
            get { return rollOverFlag; }
            set
            {

                SetArgument("rollOverFlag", value);
                rollOverFlag = value;
            }
        }

        private float rollTorqueScale = 25.00f;
        /// <summary>
        /// Scale rolling torque that is applied to character spine by bodyWrithe. Torque magnitude is calculated with the following formula: m_rollOverDirection*rollOverPhase*rollTorqueScale.
        /// </summary>
        [EuphoriaDetail("Scale rolling torque that is applied to character spine by bodyWrithe. Torque magnitude is calculated with the following formula: m_rollOverDirection*rollOverPhase*rollTorqueScale.")]
        public float RollTorqueScale
        {
            get { return rollTorqueScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 300.00f);
                SetArgument("rollTorqueScale", value);
                rollTorqueScale = value;
            }
        }

        private float predictTime = 0.10f;
        /// <summary>
        /// Character pose depends on character facing direction that is evaluated from its COMTM orientation. Set this value to 0 to use no orientation prediction i.e. current character COMTM orientation will be used to determine character facing direction and finally the pose bodyWrithe is blending to. Set this value to  GT  0 to predict character COMTM orientation this amout of time in seconds to the future.
        /// </summary>
        [EuphoriaDetail("Character pose depends on character facing direction that is evaluated from its COMTM orientation. Set this value to 0 to use no orientation prediction i.e. current character COMTM orientation will be used to determine character facing direction and finally the pose bodyWrithe is blending to. Set this value to  GT  0 to predict character COMTM orientation this amout of time in seconds to the future.")]
        public float PredictTime
        {
            get { return predictTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("predictTime", value);
                predictTime = value;
            }
        }

        private float maxRollOverTime = 8.00f;
        /// <summary>
        /// Rolling torque is ramped down over time. At this time in seconds torque value converges to zero. Use this parameter to restrict time the character is rolling.
        /// </summary>
        [EuphoriaDetail("Rolling torque is ramped down over time. At this time in seconds torque value converges to zero. Use this parameter to restrict time the character is rolling.")]
        public float MaxRollOverTime
        {
            get { return maxRollOverTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 60.00f);
                SetArgument("maxRollOverTime", value);
                maxRollOverTime = value;
            }
        }

        private float rollOverRadius = 2.00f;
        /// <summary>
        /// Rolling torque is ramped down with distance measured from position where character hit the ground and started rolling. At this distance in meters torque value converges to zero. Use this parameter to restrict distance the character travels due to rolling.
        /// </summary>
        [EuphoriaDetail("Rolling torque is ramped down with distance measured from position where character hit the ground and started rolling. At this distance in meters torque value converges to zero. Use this parameter to restrict distance the character travels due to rolling.")]
        public float RollOverRadius
        {
            get { return rollOverRadius; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("rollOverRadius", value);
                rollOverRadius = value;
            }
        }


        public EuphoriaMessageOnFire(bool startNow) : base("onFire", startNow)
        { }

        public new void Reset()
        {
            staggerTime = 2.50f;
            staggerLeanRate = 0.90f;
            stumbleMaxLeanBack = 0.40f;
            stumbleMaxLeanForward = 0.50f;
            armsWindmillWritheBlend = 0.40f;
            spineStumbleWritheBlend = 0.70f;
            legsStumbleWritheBlend = 0.20f;
            armsPoseWritheBlend = 0.70f;
            spinePoseWritheBlend = 0.550f;
            legsPoseWritheBlend = 0.50f;
            rollOverFlag = true;
            rollTorqueScale = 25.00f;
            predictTime = 0.10f;
            maxRollOverTime = 8.00f;
            rollOverRadius = 2.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessagePedalLegs : EuphoriaMessage
    {
        private bool pedalLeftLeg = true;
        /// <summary>
        /// pedal with this leg or not
        /// </summary>
        [EuphoriaDetail("pedal with this leg or not")]
        public bool PedalLeftLeg
        {
            get { return pedalLeftLeg; }
            set
            {

                SetArgument("pedalLeftLeg", value);
                pedalLeftLeg = value;
            }
        }

        private bool pedalRightLeg = true;
        /// <summary>
        /// pedal with this leg or not
        /// </summary>
        [EuphoriaDetail("pedal with this leg or not")]
        public bool PedalRightLeg
        {
            get { return pedalRightLeg; }
            set
            {

                SetArgument("pedalRightLeg", value);
                pedalRightLeg = value;
            }
        }

        private bool backPedal = false;
        /// <summary>
        /// pedal forwards or backwards
        /// </summary>
        [EuphoriaDetail("pedal forwards or backwards")]
        public bool BackPedal
        {
            get { return backPedal; }
            set
            {

                SetArgument("backPedal", value);
                backPedal = value;
            }
        }

        private float radius = 0.250f;
        /// <summary>
        /// base radius of pedal action
        /// </summary>
        [EuphoriaDetail("base radius of pedal action")]
        public float Radius
        {
            get { return radius; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 2.00f);
                SetArgument("radius", value);
                radius = value;
            }
        }

        private float angularSpeed = 10.00f;
        /// <summary>
        /// rate of pedaling. If adaptivePedal4Dragging is true then the legsAngularSpeed calculated to match the linear speed of the character can have a maximum value of angularSpeed (this max used to be hard coded to 13.0)
        /// </summary>
        [EuphoriaDetail("rate of pedaling. If adaptivePedal4Dragging is true then the legsAngularSpeed calculated to match the linear speed of the character can have a maximum value of angularSpeed (this max used to be hard coded to 13.0)")]
        public float AngularSpeed
        {
            get { return angularSpeed; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("angularSpeed", value);
                angularSpeed = value;
            }
        }

        private float legStiffness = 10.00f;
        /// <summary>
        /// stiffness of legs
        /// </summary>
        [EuphoriaDetail("stiffness of legs")]
        public float LegStiffness
        {
            get { return legStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("legStiffness", value);
                legStiffness = value;
            }
        }

        private float pedalOffset = 0.00f;
        /// <summary>
        /// Move the centre of the pedal for the left leg up by this amount, the right leg down by this amount
        /// </summary>
        [EuphoriaDetail("Move the centre of the pedal for the left leg up by this amount, the right leg down by this amount")]
        public float PedalOffset
        {
            get { return pedalOffset; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("pedalOffset", value);
                pedalOffset = value;
            }
        }

        private int randomSeed = 100;
        /// <summary>
        /// Random seed used to generate speed changes
        /// </summary>
        [EuphoriaDetail("Random seed used to generate speed changes")]
        public int RandomSeed
        {
            get { return randomSeed; }
            set
            {

                SetArgument("randomSeed", value);
                randomSeed = value;
            }
        }

        private float speedAsymmetry = 8.00f;
        /// <summary>
        /// Random offset applied per leg to the angular speed to desynchronise the pedaling - set to 0 to disable, otherwise should be set to less than the angularSpeed value.
        /// </summary>
        [EuphoriaDetail("Random offset applied per leg to the angular speed to desynchronise the pedaling - set to 0 to disable, otherwise should be set to less than the angularSpeed value.")]
        public float SpeedAsymmetry
        {
            get { return speedAsymmetry; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 10.00f);
                SetArgument("speedAsymmetry", value);
                speedAsymmetry = value;
            }
        }

        private bool adaptivePedal4Dragging = false;
        /// <summary>
        /// Will pedal in the direction of travel (if backPedal = false, against travel if backPedal = true) and with an angular velocity relative to speed upto a maximum of 13(rads/sec).  Use when being dragged by a car.  Overrides angularSpeed.
        /// </summary>
        [EuphoriaDetail("Will pedal in the direction of travel (if backPedal = false, against travel if backPedal = true) and with an angular velocity relative to speed upto a maximum of 13(rads/sec).  Use when being dragged by a car.  Overrides angularSpeed.")]
        public bool AdaptivePedal4Dragging
        {
            get { return adaptivePedal4Dragging; }
            set
            {

                SetArgument("adaptivePedal4Dragging", value);
                adaptivePedal4Dragging = value;
            }
        }

        private float angSpeedMultiplier4Dragging = 0.30f;
        /// <summary>
        /// newAngularSpeed = Clamp(angSpeedMultiplier4Dragging * linear_speed/pedalRadius, 0.0, angularSpeed)
        /// </summary>
        [EuphoriaDetail("newAngularSpeed = Clamp(angSpeedMultiplier4Dragging * linear_speed/pedalRadius, 0.0, angularSpeed)")]
        public float AngSpeedMultiplier4Dragging
        {
            get { return angSpeedMultiplier4Dragging; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("angSpeedMultiplier4Dragging", value);
                angSpeedMultiplier4Dragging = value;
            }
        }

        private float radiusVariance = 0.40f;
        /// <summary>
        /// 0-1 value used to add variance to the radius value while pedalling, to desynchonize the legs' movement and provide some variety
        /// </summary>
        [EuphoriaDetail("0-1 value used to add variance to the radius value while pedalling, to desynchonize the legs' movement and provide some variety")]
        public float RadiusVariance
        {
            get { return radiusVariance; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("radiusVariance", value);
                radiusVariance = value;
            }
        }

        private float legAngleVariance = 0.50f;
        /// <summary>
        /// 0-1 value used to vary the angle of the legs from the hips during the pedal
        /// </summary>
        [EuphoriaDetail("0-1 value used to vary the angle of the legs from the hips during the pedal")]
        public float LegAngleVariance
        {
            get { return legAngleVariance; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("legAngleVariance", value);
                legAngleVariance = value;
            }
        }

        private float centreSideways = 0.00f;
        /// <summary>
        /// Move the centre of the pedal for both legs sideways (+ve = right).  NB: not applied to hula.
        /// </summary>
        [EuphoriaDetail("Move the centre of the pedal for both legs sideways (+ve = right).  NB: not applied to hula.")]
        public float CentreSideways
        {
            get { return centreSideways; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("centreSideways", value);
                centreSideways = value;
            }
        }

        private float centreForwards = 0.00f;
        /// <summary>
        /// Move the centre of the pedal for both legs forward (or backward -ve)
        /// </summary>
        [EuphoriaDetail("Move the centre of the pedal for both legs forward (or backward -ve)")]
        public float CentreForwards
        {
            get { return centreForwards; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("centreForwards", value);
                centreForwards = value;
            }
        }

        private float centreUp = 0.00f;
        /// <summary>
        /// Move the centre of the pedal for both legs up (or down -ve)
        /// </summary>
        [EuphoriaDetail("Move the centre of the pedal for both legs up (or down -ve)")]
        public float CentreUp
        {
            get { return centreUp; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("centreUp", value);
                centreUp = value;
            }
        }

        private float ellipse = 1.00f;
        /// <summary>
        /// Turn the circle into an ellipse.  Ellipse has horizontal radius a and vertical radius b.  If ellipse is +ve then a=radius*ellipse and b=radius.  If ellipse is -ve then a=radius and b = radius*ellipse.  0.0 = vertical line of length 2*radius, 0.0:1.0 circle squashed horizontally (vertical radius = radius), 1.0=circle.  -0.001 = horizontal line of length 2*radius, -0.0:-1.0 circle squashed vertically (horizontal radius = radius), -1.0 = circle
        /// </summary>
        [EuphoriaDetail("Turn the circle into an ellipse.  Ellipse has horizontal radius a and vertical radius b.  If ellipse is +ve then a=radius*ellipse and b=radius.  If ellipse is -ve then a=radius and b = radius*ellipse.  0.0 = vertical line of length 2*radius, 0.0:1.0 circle squashed horizontally (vertical radius = radius), 1.0=circle.  -0.001 = horizontal line of length 2*radius, -0.0:-1.0 circle squashed vertically (horizontal radius = radius), -1.0 = circle")]
        public float Ellipse
        {
            get { return ellipse; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("ellipse", value);
                ellipse = value;
            }
        }

        private float dragReduction = 0.250f;
        /// <summary>
        /// how much to account for the target moving through space rather than being static
        /// </summary>
        [EuphoriaDetail("how much to account for the target moving through space rather than being static")]
        public float DragReduction
        {
            get { return dragReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("dragReduction", value);
                dragReduction = value;
            }
        }

        private float spread = 0.00f;
        /// <summary>
        /// Spread legs.
        /// </summary>
        [EuphoriaDetail("Spread legs.")]
        public float Spread
        {
            get { return spread; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("spread", value);
                spread = value;
            }
        }

        private bool hula = false;
        /// <summary>
        /// If true circle the legs in a hula motion.
        /// </summary>
        [EuphoriaDetail("If true circle the legs in a hula motion.")]
        public bool Hula
        {
            get { return hula; }
            set
            {

                SetArgument("hula", value);
                hula = value;
            }
        }


        public EuphoriaMessagePedalLegs(bool startNow) : base("pedalLegs", startNow)
        { }

        public new void Reset()
        {
            pedalLeftLeg = true;
            pedalRightLeg = true;
            backPedal = false;
            radius = 0.250f;
            angularSpeed = 10.00f;
            legStiffness = 10.00f;
            pedalOffset = 0.00f;
            randomSeed = 100;
            speedAsymmetry = 8.00f;
            adaptivePedal4Dragging = false;
            angSpeedMultiplier4Dragging = 0.30f;
            radiusVariance = 0.40f;
            legAngleVariance = 0.50f;
            centreSideways = 0.00f;
            centreForwards = 0.00f;
            centreUp = 0.00f;
            ellipse = 1.00f;
            dragReduction = 0.250f;
            spread = 0.00f;
            hula = false;
            base.Reset();
        }
    }


    /// <summary>
    /// pointArm:BEHAVIOURS REFERENCED: AnimPose - allows animPose to overridebodyParts: Arms (useLeftArm, useRightArm)
    /// </summary>
    [EuphoriaDetail("pointArm:BEHAVIOURS REFERENCED: AnimPose - allows animPose to overridebodyParts: Arms (useLeftArm, useRightArm)")]
    internal class EuphoriaMessagePointArm : EuphoriaMessage
    {
        private Vector3 targetLeft = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// point to point to (in world space)
        /// </summary>
        [EuphoriaDetail("point to point to (in world space)")]
        public Vector3 TargetLeft
        {
            get { return targetLeft; }
            set
            {

                SetArgument("targetLeft", value);
                targetLeft = value;
            }
        }

        private float twistLeft = 0.3f;
        /// <summary>
        /// twist of the arm around point direction
        /// </summary>
        [EuphoriaDetail("twist of the arm around point direction")]
        public float TwistLeft
        {
            get { return twistLeft; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("twistLeft", value);
                twistLeft = value;
            }
        }

        private float armStraightnessLeft = 0.8f;
        /// <summary>
        /// values less than 1 can give the arm a more bent look
        /// </summary>
        [EuphoriaDetail("values less than 1 can give the arm a more bent look")]
        public float ArmStraightnessLeft
        {
            get { return armStraightnessLeft; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armStraightnessLeft", value);
                armStraightnessLeft = value;
            }
        }

        private bool useLeftArm = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool UseLeftArm
        {
            get { return useLeftArm; }
            set
            {

                SetArgument("useLeftArm", value);
                useLeftArm = value;
            }
        }

        private float armStiffnessLeft = 15.0f;
        /// <summary>
        /// stiffness of arm
        /// </summary>
        [EuphoriaDetail("stiffness of arm")]
        public float ArmStiffnessLeft
        {
            get { return armStiffnessLeft; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("armStiffnessLeft", value);
                armStiffnessLeft = value;
            }
        }

        private float armDampingLeft = 1.0f;
        /// <summary>
        /// damping value for arm used to point
        /// </summary>
        [EuphoriaDetail("damping value for arm used to point")]
        public float ArmDampingLeft
        {
            get { return armDampingLeft; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armDampingLeft", value);
                armDampingLeft = value;
            }
        }

        private int instanceIndexLeft = -1;
        /// <summary>
        /// level index of thing to point at, or -1 for none. if -1, target is specified in world space, otherwise it is an offset from the object specified by this index.
        /// </summary>
        [EuphoriaDetail("level index of thing to point at, or -1 for none. if -1, target is specified in world space, otherwise it is an offset from the object specified by this index.")]
        public int InstanceIndexLeft
        {
            get { return instanceIndexLeft; }
            set
            {

                SetArgument("instanceIndexLeft", value);
                instanceIndexLeft = value;
            }
        }

        private float pointSwingLimitLeft = 1.5f;
        /// <summary>
        /// Swing limit
        /// </summary>
        [EuphoriaDetail("Swing limit")]
        public float PointSwingLimitLeft
        {
            get { return pointSwingLimitLeft; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("pointSwingLimitLeft", value);
                pointSwingLimitLeft = value;
            }
        }

        private bool useZeroPoseWhenNotPointingLeft = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool UseZeroPoseWhenNotPointingLeft
        {
            get { return useZeroPoseWhenNotPointingLeft; }
            set
            {

                SetArgument("useZeroPoseWhenNotPointingLeft", value);
                useZeroPoseWhenNotPointingLeft = value;
            }
        }

        private Vector3 targetRight = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// point to point to (in world space)
        /// </summary>
        [EuphoriaDetail("point to point to (in world space)")]
        public Vector3 TargetRight
        {
            get { return targetRight; }
            set
            {

                SetArgument("targetRight", value);
                targetRight = value;
            }
        }

        private float twistRight = 0.3f;
        /// <summary>
        /// twist of the arm around point direction
        /// </summary>
        [EuphoriaDetail("twist of the arm around point direction")]
        public float TwistRight
        {
            get { return twistRight; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("twistRight", value);
                twistRight = value;
            }
        }

        private float armStraightnessRight = 0.8f;
        /// <summary>
        /// values less than 1 can give the arm a more bent look
        /// </summary>
        [EuphoriaDetail("values less than 1 can give the arm a more bent look")]
        public float ArmStraightnessRight
        {
            get { return armStraightnessRight; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armStraightnessRight", value);
                armStraightnessRight = value;
            }
        }

        private bool useRightArm = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool UseRightArm
        {
            get { return useRightArm; }
            set
            {

                SetArgument("useRightArm", value);
                useRightArm = value;
            }
        }

        private float armStiffnessRight = 15.0f;
        /// <summary>
        /// stiffness of arm
        /// </summary>
        [EuphoriaDetail("stiffness of arm")]
        public float ArmStiffnessRight
        {
            get { return armStiffnessRight; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("armStiffnessRight", value);
                armStiffnessRight = value;
            }
        }

        private float armDampingRight = 1.0f;
        /// <summary>
        /// damping value for arm used to point
        /// </summary>
        [EuphoriaDetail("damping value for arm used to point")]
        public float ArmDampingRight
        {
            get { return armDampingRight; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armDampingRight", value);
                armDampingRight = value;
            }
        }

        private int instanceIndexRight = -1;
        /// <summary>
        /// level index of thing to point at, or -1 for none. if -1, target is specified in world space, otherwise it is an offset from the object specified by this index.
        /// </summary>
        [EuphoriaDetail("level index of thing to point at, or -1 for none. if -1, target is specified in world space, otherwise it is an offset from the object specified by this index.")]
        public int InstanceIndexRight
        {
            get { return instanceIndexRight; }
            set
            {

                SetArgument("instanceIndexRight", value);
                instanceIndexRight = value;
            }
        }

        private float pointSwingLimitRight = 1.5f;
        /// <summary>
        /// Swing limit
        /// </summary>
        [EuphoriaDetail("Swing limit")]
        public float PointSwingLimitRight
        {
            get { return pointSwingLimitRight; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("pointSwingLimitRight", value);
                pointSwingLimitRight = value;
            }
        }

        private bool useZeroPoseWhenNotPointingRight = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool UseZeroPoseWhenNotPointingRight
        {
            get { return useZeroPoseWhenNotPointingRight; }
            set
            {

                SetArgument("useZeroPoseWhenNotPointingRight", value);
                useZeroPoseWhenNotPointingRight = value;
            }
        }


        public EuphoriaMessagePointArm(bool startNow) : base("pointArm", startNow)
        { }

        public new void Reset()
        {
            targetLeft = new Vector3(0f, 0f, 0f);
            twistLeft = 0.3f;
            armStraightnessLeft = 0.8f;
            useLeftArm = false;
            armStiffnessLeft = 15.0f;
            armDampingLeft = 1.0f;
            instanceIndexLeft = -1;
            pointSwingLimitLeft = 1.5f;
            useZeroPoseWhenNotPointingLeft = false;
            targetRight = new Vector3(0f, 0f, 0f);
            twistRight = 0.3f;
            armStraightnessRight = 0.8f;
            useRightArm = false;
            armStiffnessRight = 15.0f;
            armDampingRight = 1.0f;
            instanceIndexRight = -1;
            pointSwingLimitRight = 1.5f;
            useZeroPoseWhenNotPointingRight = false;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessagePointGun : EuphoriaMessage
    {
        private bool enableRight = true;
        /// <summary>
        /// Allow right hand to point/support?
        /// </summary>
        [EuphoriaDetail("Allow right hand to point/support?")]
        public bool EnableRight
        {
            get { return enableRight; }
            set
            {

                SetArgument("enableRight", value);
                enableRight = value;
            }
        }

        private bool enableLeft = true;
        /// <summary>
        /// Allow right hand to point/support?
        /// </summary>
        [EuphoriaDetail("Allow right hand to point/support?")]
        public bool EnableLeft
        {
            get { return enableLeft; }
            set
            {

                SetArgument("enableLeft", value);
                enableLeft = value;
            }
        }

        private Vector3 leftHandTarget = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Target for the left Hand
        /// </summary>
        [EuphoriaDetail("Target for the left Hand")]
        public Vector3 LeftHandTarget
        {
            get { return leftHandTarget; }
            set
            {

                SetArgument("leftHandTarget", value);
                leftHandTarget = value;
            }
        }

        private int leftHandTargetIndex = -1;
        /// <summary>
        /// Index of the object that the left hand target is specified in, -1 is world space.
        /// </summary>
        [EuphoriaDetail("Index of the object that the left hand target is specified in, -1 is world space.")]
        public int LeftHandTargetIndex
        {
            get { return leftHandTargetIndex; }
            set
            {

                SetArgument("leftHandTargetIndex", value);
                leftHandTargetIndex = value;
            }
        }

        private Vector3 rightHandTarget = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Target for the right Hand
        /// </summary>
        [EuphoriaDetail("Target for the right Hand")]
        public Vector3 RightHandTarget
        {
            get { return rightHandTarget; }
            set
            {

                SetArgument("rightHandTarget", value);
                rightHandTarget = value;
            }
        }

        private int rightHandTargetIndex = -1;
        /// <summary>
        /// Index of the object that the right hand target is specified in, -1 is world space.
        /// </summary>
        [EuphoriaDetail("Index of the object that the right hand target is specified in, -1 is world space.")]
        public int RightHandTargetIndex
        {
            get { return rightHandTargetIndex; }
            set
            {

                SetArgument("rightHandTargetIndex", value);
                rightHandTargetIndex = value;
            }
        }

        private float leadTarget = 0.00f;
        /// <summary>
        /// NB: Only Applied to single handed weapons (some more work is required to have this tech on two handed weapons). Amount to lead target based on target velocity relative to the chest.
        /// </summary>
        [EuphoriaDetail("NB: Only Applied to single handed weapons (some more work is required to have this tech on two handed weapons). Amount to lead target based on target velocity relative to the chest.")]
        public float LeadTarget
        {
            get { return leadTarget; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("leadTarget", value);
                leadTarget = value;
            }
        }

        private float armStiffness = 14.00f;
        /// <summary>
        /// Stiffness of the arm.
        /// </summary>
        [EuphoriaDetail("Stiffness of the arm.")]
        public float ArmStiffness
        {
            get { return armStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 2.00f, 15.00f);
                SetArgument("armStiffness", value);
                armStiffness = value;
            }
        }

        private float armStiffnessDetSupport = 8.00f;
        /// <summary>
        /// Stiffness of the arm on pointing arm when a support arm is detached from a two-handed weapon.
        /// </summary>
        [EuphoriaDetail("Stiffness of the arm on pointing arm when a support arm is detached from a two-handed weapon.")]
        public float ArmStiffnessDetSupport
        {
            get { return armStiffnessDetSupport; }
            set
            {
                value = MathHelper.Clamp(value, 2.00f, 15.00f);
                SetArgument("armStiffnessDetSupport", value);
                armStiffnessDetSupport = value;
            }
        }

        private float armDamping = 1.00f;
        /// <summary>
        /// Damping.
        /// </summary>
        [EuphoriaDetail("Damping.")]
        public float ArmDamping
        {
            get { return armDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 5.00f);
                SetArgument("armDamping", value);
                armDamping = value;
            }
        }

        private float gravityOpposition = 1.00f;
        /// <summary>
        /// Amount of gravity opposition on pointing arm.
        /// </summary>
        [EuphoriaDetail("Amount of gravity opposition on pointing arm.")]
        public float GravityOpposition
        {
            get { return gravityOpposition; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("gravityOpposition", value);
                gravityOpposition = value;
            }
        }

        private float gravOppDetachedSupport = 0.50f;
        /// <summary>
        /// Amount of gravity opposition on pointing arm when a support arm is detached from a two-handed weapon.
        /// </summary>
        [EuphoriaDetail("Amount of gravity opposition on pointing arm when a support arm is detached from a two-handed weapon.")]
        public float GravOppDetachedSupport
        {
            get { return gravOppDetachedSupport; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("gravOppDetachedSupport", value);
                gravOppDetachedSupport = value;
            }
        }

        private float massMultDetachedSupport = 0.10f;
        /// <summary>
        /// Amount of mass of weapon taken into account by gravity opposition on pointing arm when a support arm is detached from a two-handed weapon.  The lower the value the more the character doesn't know about the weapon mass and therefore is more affected by it.
        /// </summary>
        [EuphoriaDetail("Amount of mass of weapon taken into account by gravity opposition on pointing arm when a support arm is detached from a two-handed weapon.  The lower the value the more the character doesn't know about the weapon mass and therefore is more affected by it.")]
        public float MassMultDetachedSupport
        {
            get { return massMultDetachedSupport; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("massMultDetachedSupport", value);
                massMultDetachedSupport = value;
            }
        }

        private bool allowShotLooseness = false;
        /// <summary>
        /// Allow shot to set a lower arm muscleStiffness than pointGun normally would.
        /// </summary>
        [EuphoriaDetail("Allow shot to set a lower arm muscleStiffness than pointGun normally would.")]
        public bool AllowShotLooseness
        {
            get { return allowShotLooseness; }
            set
            {

                SetArgument("allowShotLooseness", value);
                allowShotLooseness = value;
            }
        }

        private float clavicleBlend = 0.00f;
        /// <summary>
        /// How much of blend should come from incoming transforms 0(all IK) .. 1(all ITMs)   For pointing arms only.  (Support arm uses the IK solution as is for clavicles)
        /// </summary>
        [EuphoriaDetail("How much of blend should come from incoming transforms 0(all IK) .. 1(all ITMs)   For pointing arms only.  (Support arm uses the IK solution as is for clavicles)")]
        public float ClavicleBlend
        {
            get { return clavicleBlend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("clavicleBlend", value);
                clavicleBlend = value;
            }
        }

        private float elbowAttitude = 0.30f;
        /// <summary>
        /// Controls arm twist. (except in pistolIK)
        /// </summary>
        [EuphoriaDetail("Controls arm twist. (except in pistolIK)")]
        public float ElbowAttitude
        {
            get { return elbowAttitude; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("elbowAttitude", value);
                elbowAttitude = value;
            }
        }

        private int supportConstraint = 1;
        /// <summary>
        /// Type of constraint between the support hand and gun.  0=no constraint, 1=hard distance constraint, 2=Force based constraint, 3=hard spherical constraint
        /// </summary>
        [EuphoriaDetail("Type of constraint between the support hand and gun.  0=no constraint, 1=hard distance constraint, 2=Force based constraint, 3=hard spherical constraint")]
        public int SupportConstraint
        {
            get { return supportConstraint; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("supportConstraint", value);
                supportConstraint = value;
            }
        }

        private float constraintMinDistance = 0.0150f;
        /// <summary>
        /// For supportConstraint = 1: Support hand constraint distance will be slowly reduced until it hits this value.  This is for stability and also allows the pointing arm to lead a little.  Don't set lower than NM_MIN_STABLE_DISTANCECONSTRAINT_DISTANCE 0.001f
        /// </summary>
        [EuphoriaDetail("For supportConstraint = 1: Support hand constraint distance will be slowly reduced until it hits this value.  This is for stability and also allows the pointing arm to lead a little.  Don't set lower than NM_MIN_STABLE_DISTANCECONSTRAINT_DISTANCE 0.001f")]
        public float ConstraintMinDistance
        {
            get { return constraintMinDistance; }
            set
            {
                value = MathHelper.Clamp(value, 0.0010f, 0.10f);
                SetArgument("constraintMinDistance", value);
                constraintMinDistance = value;
            }
        }

        private float makeConstraintDistance = 0.10f;
        /// <summary>
        /// For supportConstraint = 1:  Minimum distance within which support hand constraint will be made.
        /// </summary>
        [EuphoriaDetail("For supportConstraint = 1:  Minimum distance within which support hand constraint will be made.")]
        public float MakeConstraintDistance
        {
            get { return makeConstraintDistance; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("makeConstraintDistance", value);
                makeConstraintDistance = value;
            }
        }

        private float reduceConstraintLengthVel = 1.50f;
        /// <summary>
        /// For supportConstraint = 1:  Velocity at which to reduce the support hand constraint length
        /// </summary>
        [EuphoriaDetail("For supportConstraint = 1:  Velocity at which to reduce the support hand constraint length")]
        public float ReduceConstraintLengthVel
        {
            get { return reduceConstraintLengthVel; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 10.00f);
                SetArgument("reduceConstraintLengthVel", value);
                reduceConstraintLengthVel = value;
            }
        }

        private float breakingStrength = -1.00f;
        /// <summary>
        /// For supportConstraint = 1: strength of the supporting hands constraint (kg m/s), -1 to ignore/disable
        /// </summary>
        [EuphoriaDetail("For supportConstraint = 1: strength of the supporting hands constraint (kg m/s), -1 to ignore/disable")]
        public float BreakingStrength
        {
            get { return breakingStrength; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1000.00f);
                SetArgument("breakingStrength", value);
                breakingStrength = value;
            }
        }

        private float brokenSupportTime = 1.00f;
        /// <summary>
        /// Once constraint is broken then do not try to reconnect/support for this amount of time
        /// </summary>
        [EuphoriaDetail("Once constraint is broken then do not try to reconnect/support for this amount of time")]
        public float BrokenSupportTime
        {
            get { return brokenSupportTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("brokenSupportTime", value);
                brokenSupportTime = value;
            }
        }

        private float brokenToSideProb = 0.50f;
        /// <summary>
        /// Probability that the when a constraint is broken that during brokenSupportTime a side pose will be selected.
        /// </summary>
        [EuphoriaDetail("Probability that the when a constraint is broken that during brokenSupportTime a side pose will be selected.")]
        public float BrokenToSideProb
        {
            get { return brokenToSideProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("brokenToSideProb", value);
                brokenToSideProb = value;
            }
        }

        private float connectAfter = 0.70f;
        /// <summary>
        /// If gunArm has been controlled by other behaviours for this time when it could have been pointing but couldn't due to pointing only allowed if connected, change gunArm pose to something that could connect for connectFor seconds
        /// </summary>
        [EuphoriaDetail("If gunArm has been controlled by other behaviours for this time when it could have been pointing but couldn't due to pointing only allowed if connected, change gunArm pose to something that could connect for connectFor seconds")]
        public float ConnectAfter
        {
            get { return connectAfter; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("connectAfter", value);
                connectAfter = value;
            }
        }

        private float connectFor = 0.550f;
        /// <summary>
        /// Time to try to reconnect for
        /// </summary>
        [EuphoriaDetail("Time to try to reconnect for")]
        public float ConnectFor
        {
            get { return connectFor; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("connectFor", value);
                connectFor = value;
            }
        }

        private int oneHandedPointing = 1;
        /// <summary>
        /// 0 = don't allow, 1= allow for kPistol(two handed pistol) only, 2 = allow for kRifle only, 3 = allow for kPistol and kRifle. Allow one handed pointing - no constraint if cant be supported .  If not allowed then gunHand does not try to point at target if it cannot be supported - the constraint will be controlled by always support.
        /// </summary>
        [EuphoriaDetail("0 = don't allow, 1= allow for kPistol(two handed pistol) only, 2 = allow for kRifle only, 3 = allow for kPistol and kRifle. Allow one handed pointing - no constraint if cant be supported .  If not allowed then gunHand does not try to point at target if it cannot be supported - the constraint will be controlled by always support.")]
        public int OneHandedPointing
        {
            get { return oneHandedPointing; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("oneHandedPointing", value);
                oneHandedPointing = value;
            }
        }

        private bool alwaysSupport = false;
        /// <summary>
        /// Support a non pointing gunHand i.e. if in zero pose (constrain as well  if constraint possible)
        /// </summary>
        [EuphoriaDetail("Support a non pointing gunHand i.e. if in zero pose (constrain as well  if constraint possible)")]
        public bool AlwaysSupport
        {
            get { return alwaysSupport; }
            set
            {

                SetArgument("alwaysSupport", value);
                alwaysSupport = value;
            }
        }

        private bool poseUnusedGunArm = false;
        /// <summary>
        /// Apply neutral pose when a gun arm isn't in use.  NB: at the moment Rifle hand is always controlled by pointGun.
        /// </summary>
        [EuphoriaDetail("Apply neutral pose when a gun arm isn't in use.  NB: at the moment Rifle hand is always controlled by pointGun.")]
        public bool PoseUnusedGunArm
        {
            get { return poseUnusedGunArm; }
            set
            {

                SetArgument("poseUnusedGunArm", value);
                poseUnusedGunArm = value;
            }
        }

        private bool poseUnusedSupportArm = false;
        /// <summary>
        /// Apply neutral pose when a support arm isn't in use.
        /// </summary>
        [EuphoriaDetail("Apply neutral pose when a support arm isn't in use.")]
        public bool PoseUnusedSupportArm
        {
            get { return poseUnusedSupportArm; }
            set
            {

                SetArgument("poseUnusedSupportArm", value);
                poseUnusedSupportArm = value;
            }
        }

        private bool poseUnusedOtherArm = false;
        /// <summary>
        /// Apply neutral pose to the non-gun arm (otherwise it is always under the control of other behaviours or not set). If the non-gun hand is a supporting hand it is not controlled by this parameter but by poseUnusedSupportArm
        /// </summary>
        [EuphoriaDetail("Apply neutral pose to the non-gun arm (otherwise it is always under the control of other behaviours or not set). If the non-gun hand is a supporting hand it is not controlled by this parameter but by poseUnusedSupportArm")]
        public bool PoseUnusedOtherArm
        {
            get { return poseUnusedOtherArm; }
            set
            {

                SetArgument("poseUnusedOtherArm", value);
                poseUnusedOtherArm = value;
            }
        }

        private float maxAngleAcross = 90.00f;
        /// <summary>
        /// max aiming angle(deg) sideways across body midline measured from chest forward that the character will try to point
        /// </summary>
        [EuphoriaDetail("max aiming angle(deg) sideways across body midline measured from chest forward that the character will try to point")]
        public float MaxAngleAcross
        {
            get { return maxAngleAcross; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("maxAngleAcross", value);
                maxAngleAcross = value;
            }
        }

        private float maxAngleAway = 90.00f;
        /// <summary>
        /// max aiming angle(deg) sideways away from body midline measured from chest forward that the character will try to point
        /// </summary>
        [EuphoriaDetail("max aiming angle(deg) sideways away from body midline measured from chest forward that the character will try to point")]
        public float MaxAngleAway
        {
            get { return maxAngleAway; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("maxAngleAway", value);
                maxAngleAway = value;
            }
        }

        private int fallingLimits = 0;
        /// <summary>
        /// 0= don't apply limits.  1=apply the limits below only when the character is falling.  2 =  always apply these limits (instead of applying maxAngleAcross and maxAngleAway which only limits the horizontal angle but implicity limits the updown (the limit shape is a vertical hinge)
        /// </summary>
        [EuphoriaDetail("0= don't apply limits.  1=apply the limits below only when the character is falling.  2 =  always apply these limits (instead of applying maxAngleAcross and maxAngleAway which only limits the horizontal angle but implicity limits the updown (the limit shape is a vertical hinge)")]
        public int FallingLimits
        {
            get { return fallingLimits; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("fallingLimits", value);
                fallingLimits = value;
            }
        }

        private float acrossLimit = 90.00f;
        /// <summary>
        /// max aiming angle(deg) sideways across body midline measured from chest forward that the character will try to point.  i.e. for rightHanded gun this is the angle left of the midline
        /// </summary>
        [EuphoriaDetail("max aiming angle(deg) sideways across body midline measured from chest forward that the character will try to point.  i.e. for rightHanded gun this is the angle left of the midline")]
        public float AcrossLimit
        {
            get { return acrossLimit; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("acrossLimit", value);
                acrossLimit = value;
            }
        }

        private float awayLimit = 90.00f;
        /// <summary>
        /// max aiming angle(deg) sideways away from body midline measured from chest forward that the character will try to point.  i.e. for rightHanded gun this is the angle right of the midline
        /// </summary>
        [EuphoriaDetail("max aiming angle(deg) sideways away from body midline measured from chest forward that the character will try to point.  i.e. for rightHanded gun this is the angle right of the midline")]
        public float AwayLimit
        {
            get { return awayLimit; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("awayLimit", value);
                awayLimit = value;
            }
        }

        private float upLimit = 90.00f;
        /// <summary>
        /// max aiming angle(deg) upwards from body midline measured from chest forward that the character will try to point.
        /// </summary>
        [EuphoriaDetail("max aiming angle(deg) upwards from body midline measured from chest forward that the character will try to point.")]
        public float UpLimit
        {
            get { return upLimit; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("upLimit", value);
                upLimit = value;
            }
        }

        private float downLimit = 45.00f;
        /// <summary>
        /// max aiming angle(deg) downwards from body midline measured from chest forward that the character will try to point
        /// </summary>
        [EuphoriaDetail("max aiming angle(deg) downwards from body midline measured from chest forward that the character will try to point")]
        public float DownLimit
        {
            get { return downLimit; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 180.00f);
                SetArgument("downLimit", value);
                downLimit = value;
            }
        }

        private int rifleFall = 0;
        /// <summary>
        /// Pose the rifle hand to reduce complications with collisions. 0 = false, 1 = always when falling, 2 = when falling except if falling backwards
        /// </summary>
        [EuphoriaDetail("Pose the rifle hand to reduce complications with collisions. 0 = false, 1 = always when falling, 2 = when falling except if falling backwards")]
        public int RifleFall
        {
            get { return rifleFall; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("rifleFall", value);
                rifleFall = value;
            }
        }

        private int fallingSupport = 1;
        /// <summary>
        /// Allow supporting of a rifle(or two handed pistol) when falling. 0 = false, 1 = support if allowed, 2 = support until constraint not active (don't allow support to restart), 3 = support until constraint not effective (support hand to support distance must be less than 0.15 - don't allow support to restart).
        /// </summary>
        [EuphoriaDetail("Allow supporting of a rifle(or two handed pistol) when falling. 0 = false, 1 = support if allowed, 2 = support until constraint not active (don't allow support to restart), 3 = support until constraint not effective (support hand to support distance must be less than 0.15 - don't allow support to restart).")]
        public int FallingSupport
        {
            get { return fallingSupport; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("fallingSupport", value);
                fallingSupport = value;
            }
        }

        private int fallingTypeSupport = 0;
        /// <summary>
        /// What is considered a fall by fallingSupport). Apply fallingSupport 0=never(will support if allowed), 1 = falling, 2 = falling except if falling backwards, 3 = falling and collided, 4 = falling and collided except if falling backwards, 5 = falling except if falling backwards until collided
        /// </summary>
        [EuphoriaDetail("What is considered a fall by fallingSupport). Apply fallingSupport 0=never(will support if allowed), 1 = falling, 2 = falling except if falling backwards, 3 = falling and collided, 4 = falling and collided except if falling backwards, 5 = falling except if falling backwards until collided")]
        public int FallingTypeSupport
        {
            get { return fallingTypeSupport; }
            set
            {
                value = MathHelper.Clamp(value, 0, 5);
                SetArgument("fallingTypeSupport", value);
                fallingTypeSupport = value;
            }
        }

        private int pistolNeutralType = 0;
        /// <summary>
        /// 0 = byFace, 1=acrossFront, 2=bySide.  NB: bySide is not connectible so be careful if combined with kPistol and oneHandedPointing = 0 or 2
        /// </summary>
        [EuphoriaDetail("0 = byFace, 1=acrossFront, 2=bySide.  NB: bySide is not connectible so be careful if combined with kPistol and oneHandedPointing = 0 or 2")]
        public int PistolNeutralType
        {
            get { return pistolNeutralType; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("pistolNeutralType", value);
                pistolNeutralType = value;
            }
        }

        private bool neutralPoint4Pistols = false;
        /// <summary>
        /// NOT IMPLEMENTED YET KEEP=false - use pointing for neutral targets in pistol modes
        /// </summary>
        [EuphoriaDetail("NOT IMPLEMENTED YET KEEP=false - use pointing for neutral targets in pistol modes")]
        public bool NeutralPoint4Pistols
        {
            get { return neutralPoint4Pistols; }
            set
            {

                SetArgument("neutralPoint4Pistols", value);
                neutralPoint4Pistols = value;
            }
        }

        private bool neutralPoint4Rifle = true;
        /// <summary>
        /// use pointing for neutral targets in rifle mode
        /// </summary>
        [EuphoriaDetail("use pointing for neutral targets in rifle mode")]
        public bool NeutralPoint4Rifle
        {
            get { return neutralPoint4Rifle; }
            set
            {

                SetArgument("neutralPoint4Rifle", value);
                neutralPoint4Rifle = value;
            }
        }

        private bool checkNeutralPoint = false;
        /// <summary>
        /// Check the neutral pointing is pointable, if it isn't then choose a neutral pose instead
        /// </summary>
        [EuphoriaDetail("Check the neutral pointing is pointable, if it isn't then choose a neutral pose instead")]
        public bool CheckNeutralPoint
        {
            get { return checkNeutralPoint; }
            set
            {

                SetArgument("checkNeutralPoint", value);
                checkNeutralPoint = value;
            }
        }

        private Vector3 point2Side = new Vector3(5.00f, -5.00f, -2.00f);
        /// <summary>
        /// side, up, back) side is left for left arm, right for right arm mmmmtodo
        /// </summary>
        [EuphoriaDetail("side, up, back) side is left for left arm, right for right arm mmmmtodo")]
        public Vector3 Point2Side
        {
            get { return point2Side; }
            set
            {

                SetArgument("point2Side", value);
                point2Side = value;
            }
        }

        private float add2WeaponDistSide = 0.30f;
        /// <summary>
        /// add to weaponDistance for point2Side neutral pointing (to straighten the arm)
        /// </summary>
        [EuphoriaDetail("add to weaponDistance for point2Side neutral pointing (to straighten the arm)")]
        public float Add2WeaponDistSide
        {
            get { return add2WeaponDistSide; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1000.00f);
                SetArgument("add2WeaponDistSide", value);
                add2WeaponDistSide = value;
            }
        }

        private Vector3 point2Connect = new Vector3(-1.00f, -0.90f, -0.20f);
        /// <summary>
        /// side, up, back) side is left for left arm, right for rght arm mmmmtodo
        /// </summary>
        [EuphoriaDetail("side, up, back) side is left for left arm, right for rght arm mmmmtodo")]
        public Vector3 Point2Connect
        {
            get { return point2Connect; }
            set
            {

                SetArgument("point2Connect", value);
                point2Connect = value;
            }
        }

        private float add2WeaponDistConnect = 0.00f;
        /// <summary>
        /// add to weaponDistance for point2Connect neutral pointing (to straighten the arm)
        /// </summary>
        [EuphoriaDetail("add to weaponDistance for point2Connect neutral pointing (to straighten the arm)")]
        public float Add2WeaponDistConnect
        {
            get { return add2WeaponDistConnect; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1000.00f);
                SetArgument("add2WeaponDistConnect", value);
                add2WeaponDistConnect = value;
            }
        }

        private bool usePistolIK = true;
        /// <summary>
        /// enable new ik for pistol pointing.
        /// </summary>
        [EuphoriaDetail("enable new ik for pistol pointing.")]
        public bool UsePistolIK
        {
            get { return usePistolIK; }
            set
            {

                SetArgument("usePistolIK", value);
                usePistolIK = value;
            }
        }

        private bool useSpineTwist = true;
        /// <summary>
        /// Use spine twist to orient chest?
        /// </summary>
        [EuphoriaDetail("Use spine twist to orient chest?")]
        public bool UseSpineTwist
        {
            get { return useSpineTwist; }
            set
            {

                SetArgument("useSpineTwist", value);
                useSpineTwist = value;
            }
        }

        private bool useTurnToTarget = false;
        /// <summary>
        /// Turn balancer to help gun point at target
        /// </summary>
        [EuphoriaDetail("Turn balancer to help gun point at target")]
        public bool UseTurnToTarget
        {
            get { return useTurnToTarget; }
            set
            {

                SetArgument("useTurnToTarget", value);
                useTurnToTarget = value;
            }
        }

        private bool useHeadLook = true;
        /// <summary>
        /// Use head look to drive head?
        /// </summary>
        [EuphoriaDetail("Use head look to drive head?")]
        public bool UseHeadLook
        {
            get { return useHeadLook; }
            set
            {

                SetArgument("useHeadLook", value);
                useHeadLook = value;
            }
        }

        private float errorThreshold = 0.39260f;
        /// <summary>
        /// angular difference between pointing direction and target direction above which feedback will be generated.
        /// </summary>
        [EuphoriaDetail("angular difference between pointing direction and target direction above which feedback will be generated.")]
        public float ErrorThreshold
        {
            get { return errorThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.141590f);
                SetArgument("errorThreshold", value);
                errorThreshold = value;
            }
        }

        private float fireWeaponRelaxTime = 0.40f;
        /// <summary>
        /// Duration of arms relax following firing weapon.  NB:This is clamped (0,5) in pointGun
        /// </summary>
        [EuphoriaDetail("Duration of arms relax following firing weapon.  NB:This is clamped (0,5) in pointGun")]
        public float FireWeaponRelaxTime
        {
            get { return fireWeaponRelaxTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("fireWeaponRelaxTime", value);
                fireWeaponRelaxTime = value;
            }
        }

        private float fireWeaponRelaxAmount = 0.50f;
        /// <summary>
        /// Relax multiplier following firing weapon. Recovers over relaxTime.
        /// </summary>
        [EuphoriaDetail("Relax multiplier following firing weapon. Recovers over relaxTime.")]
        public float FireWeaponRelaxAmount
        {
            get { return fireWeaponRelaxAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 1.00f);
                SetArgument("fireWeaponRelaxAmount", value);
                fireWeaponRelaxAmount = value;
            }
        }

        private float fireWeaponRelaxDistance = 0.050f;
        /// <summary>
        /// Range of motion for ik-based recoil.
        /// </summary>
        [EuphoriaDetail("Range of motion for ik-based recoil.")]
        public float FireWeaponRelaxDistance
        {
            get { return fireWeaponRelaxDistance; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 0.250f);
                SetArgument("fireWeaponRelaxDistance", value);
                fireWeaponRelaxDistance = value;
            }
        }

        private bool useIncomingTransforms = true;
        /// <summary>
        /// Use the incoming transforms to inform the pointGun of the primaryWeaponDistance, poleVector for the arm
        /// </summary>
        [EuphoriaDetail("Use the incoming transforms to inform the pointGun of the primaryWeaponDistance, poleVector for the arm")]
        public bool UseIncomingTransforms
        {
            get { return useIncomingTransforms; }
            set
            {

                SetArgument("useIncomingTransforms", value);
                useIncomingTransforms = value;
            }
        }

        private bool measureParentOffset = true;
        /// <summary>
        /// If useIncomingTransforms = true and measureParentOffset=true then measure the Pointing-from offset from parent effector, using itms - this should point the barrel of the gun to the target.  This is added to the rightHandParentOffset. NB NOT used if rightHandParentEffector LT 0
        /// </summary>
        [EuphoriaDetail("If useIncomingTransforms = true and measureParentOffset=true then measure the Pointing-from offset from parent effector, using itms - this should point the barrel of the gun to the target.  This is added to the rightHandParentOffset. NB NOT used if rightHandParentEffector LT 0")]
        public bool MeasureParentOffset
        {
            get { return measureParentOffset; }
            set
            {

                SetArgument("measureParentOffset", value);
                measureParentOffset = value;
            }
        }

        private Vector3 leftHandParentOffset = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Pointing-from offset from parent effector, expressed in spine3's frame, x = back/forward, y = right/left, z = up/down.
        /// </summary>
        [EuphoriaDetail("Pointing-from offset from parent effector, expressed in spine3's frame, x = back/forward, y = right/left, z = up/down.")]
        public Vector3 LeftHandParentOffset
        {
            get { return leftHandParentOffset; }
            set
            {

                SetArgument("leftHandParentOffset", value);
                leftHandParentOffset = value;
            }
        }

        private int leftHandParentEffector = -1;
        /// <summary>
        /// 1 = Use leftShoulder. Effector from which the left hand pointing originates. ie, point from this part to the target. -1 causes default offset for active weapon mode to be applied.
        /// </summary>
        [EuphoriaDetail("1 = Use leftShoulder. Effector from which the left hand pointing originates. ie, point from this part to the target. -1 causes default offset for active weapon mode to be applied.")]
        public int LeftHandParentEffector
        {
            get { return leftHandParentEffector; }
            set
            {
                value = MathHelper.Clamp(value, -1, 21);
                SetArgument("leftHandParentEffector", value);
                leftHandParentEffector = value;
            }
        }

        private Vector3 rightHandParentOffset = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// Pointing-from offset from parent effector, expressed in spine3's frame, x = back/forward, y = right/left, z = up/down. This is added to the measured one if useIncomingTransforms=true and measureParentOffset=true.  NB NOT used if rightHandParentEffector LT 0.  Pistol(0,0,0) Rifle(0.0032, 0.0, -0.0)
        /// </summary>
        [EuphoriaDetail("Pointing-from offset from parent effector, expressed in spine3's frame, x = back/forward, y = right/left, z = up/down. This is added to the measured one if useIncomingTransforms=true and measureParentOffset=true.  NB NOT used if rightHandParentEffector LT 0.  Pistol(0,0,0) Rifle(0.0032, 0.0, -0.0)")]
        public Vector3 RightHandParentOffset
        {
            get { return rightHandParentOffset; }
            set
            {

                SetArgument("rightHandParentOffset", value);
                rightHandParentOffset = value;
            }
        }

        private int rightHandParentEffector = -1;
        /// <summary>
        /// 1 = Use rightShoulder.. Effector from which the right hand pointing originates. ie, point from this part to the target. -1 causes default offset for active weapon mode to be applied.
        /// </summary>
        [EuphoriaDetail("1 = Use rightShoulder.. Effector from which the right hand pointing originates. ie, point from this part to the target. -1 causes default offset for active weapon mode to be applied.")]
        public int RightHandParentEffector
        {
            get { return rightHandParentEffector; }
            set
            {
                value = MathHelper.Clamp(value, -1, 21);
                SetArgument("rightHandParentEffector", value);
                rightHandParentEffector = value;
            }
        }

        private float primaryHandWeaponDistance = -1.00f;
        /// <summary>
        /// Distance from the shoulder to hold the weapon. If -1 and useIncomingTransforms then weaponDistance is read from ITMs. weaponDistance=primaryHandWeaponDistance clamped [0.2f:m_maxArmReach=0.65] if useIncomingTransforms = false. pistol 0.60383, rifle 0.336
        /// </summary>
        [EuphoriaDetail("Distance from the shoulder to hold the weapon. If -1 and useIncomingTransforms then weaponDistance is read from ITMs. weaponDistance=primaryHandWeaponDistance clamped [0.2f:m_maxArmReach=0.65] if useIncomingTransforms = false. pistol 0.60383, rifle 0.336")]
        public float PrimaryHandWeaponDistance
        {
            get { return primaryHandWeaponDistance; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("primaryHandWeaponDistance", value);
                primaryHandWeaponDistance = value;
            }
        }

        private bool constrainRifle = true;
        /// <summary>
        /// Use hard constraint to keep rifle stock against shoulder?
        /// </summary>
        [EuphoriaDetail("Use hard constraint to keep rifle stock against shoulder?")]
        public bool ConstrainRifle
        {
            get { return constrainRifle; }
            set
            {

                SetArgument("constrainRifle", value);
                constrainRifle = value;
            }
        }

        private float rifleConstraintMinDistance = 0.20f;
        /// <summary>
        /// Rifle constraint distance. Deliberately kept large to create a flat constraint surface where rifle meets the shoulder.
        /// </summary>
        [EuphoriaDetail("Rifle constraint distance. Deliberately kept large to create a flat constraint surface where rifle meets the shoulder.")]
        public float RifleConstraintMinDistance
        {
            get { return rifleConstraintMinDistance; }
            set
            {

                SetArgument("rifleConstraintMinDistance", value);
                rifleConstraintMinDistance = value;
            }
        }

        private bool disableArmCollisions = false;
        /// <summary>
        /// Disable collisions between right hand/forearm and the torso/legs.
        /// </summary>
        [EuphoriaDetail("Disable collisions between right hand/forearm and the torso/legs.")]
        public bool DisableArmCollisions
        {
            get { return disableArmCollisions; }
            set
            {

                SetArgument("disableArmCollisions", value);
                disableArmCollisions = value;
            }
        }

        private bool disableRifleCollisions = false;
        /// <summary>
        /// Disable collisions between right hand/forearm and spine3/spine2 if in rifle mode.
        /// </summary>
        [EuphoriaDetail("Disable collisions between right hand/forearm and spine3/spine2 if in rifle mode.")]
        public bool DisableRifleCollisions
        {
            get { return disableRifleCollisions; }
            set
            {

                SetArgument("disableRifleCollisions", value);
                disableRifleCollisions = value;
            }
        }


        public EuphoriaMessagePointGun(bool startNow) : base("pointGun", startNow)
        { }

        public new void Reset()
        {
            enableRight = true;
            enableLeft = true;
            leftHandTarget = new Vector3(0f, 0f, 0f);
            leftHandTargetIndex = -1;
            rightHandTarget = new Vector3(0f, 0f, 0f);
            rightHandTargetIndex = -1;
            leadTarget = 0.00f;
            armStiffness = 14.00f;
            armStiffnessDetSupport = 8.00f;
            armDamping = 1.00f;
            gravityOpposition = 1.00f;
            gravOppDetachedSupport = 0.50f;
            massMultDetachedSupport = 0.10f;
            allowShotLooseness = false;
            clavicleBlend = 0.00f;
            elbowAttitude = 0.30f;
            supportConstraint = 1;
            constraintMinDistance = 0.0150f;
            makeConstraintDistance = 0.10f;
            reduceConstraintLengthVel = 1.50f;
            breakingStrength = -1.00f;
            brokenSupportTime = 1.00f;
            brokenToSideProb = 0.50f;
            connectAfter = 0.70f;
            connectFor = 0.550f;
            oneHandedPointing = 1;
            alwaysSupport = false;
            poseUnusedGunArm = false;
            poseUnusedSupportArm = false;
            poseUnusedOtherArm = false;
            maxAngleAcross = 90.00f;
            maxAngleAway = 90.00f;
            fallingLimits = 0;
            acrossLimit = 90.00f;
            awayLimit = 90.00f;
            upLimit = 90.00f;
            downLimit = 45.00f;
            rifleFall = 0;
            fallingSupport = 1;
            fallingTypeSupport = 0;
            pistolNeutralType = 0;
            neutralPoint4Pistols = false;
            neutralPoint4Rifle = true;
            checkNeutralPoint = false;
            point2Side = new Vector3(5.00f, -5.00f, -2.00f);
            add2WeaponDistSide = 0.30f;
            point2Connect = new Vector3(-1.00f, -0.90f, -0.20f);
            add2WeaponDistConnect = 0.00f;
            usePistolIK = true;
            useSpineTwist = true;
            useTurnToTarget = false;
            useHeadLook = true;
            errorThreshold = 0.39260f;
            fireWeaponRelaxTime = 0.40f;
            fireWeaponRelaxAmount = 0.50f;
            fireWeaponRelaxDistance = 0.050f;
            useIncomingTransforms = true;
            measureParentOffset = true;
            leftHandParentOffset = new Vector3(0f, 0f, 0f);
            leftHandParentEffector = -1;
            rightHandParentOffset = new Vector3(0f, 0f, 0f);
            rightHandParentEffector = -1;
            primaryHandWeaponDistance = -1.00f;
            constrainRifle = true;
            rifleConstraintMinDistance = 0.20f;
            disableArmCollisions = false;
            disableRifleCollisions = false;
            base.Reset();
        }
    }


    /// <summary>
    /// pointGunExtra:  Seldom set parameters for pointGun - just to keep number of parameters in any message less than or equal to 64
    /// </summary>
    [EuphoriaDetail("pointGunExtra:  Seldom set parameters for pointGun - just to keep number of parameters in any message less than or equal to 64")]
    internal class EuphoriaMessagePointGunExtra : EuphoriaMessage
    {
        private float constraintStrength = 2.00f;
        /// <summary>
        /// For supportConstraint = 2: force constraint strength of the supporting hands - it gets shaky at about 4.0
        /// </summary>
        [EuphoriaDetail("For supportConstraint = 2: force constraint strength of the supporting hands - it gets shaky at about 4.0")]
        public float ConstraintStrength
        {
            get { return constraintStrength; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("constraintStrength", value);
                constraintStrength = value;
            }
        }

        private float constraintThresh = 0.10f;
        /// <summary>
        /// For supportConstraint = 2:  Like makeConstraintDistance. Force starts acting when the hands are  LT  3.0*thresh apart but is maximum strength  LT  thresh. For comparison: 0.1 is used for reachForWound in shot, 0.25 is used in grab.
        /// </summary>
        [EuphoriaDetail("For supportConstraint = 2:  Like makeConstraintDistance. Force starts acting when the hands are  LT  3.0*thresh apart but is maximum strength  LT  thresh. For comparison: 0.1 is used for reachForWound in shot, 0.25 is used in grab.")]
        public float ConstraintThresh
        {
            get { return constraintThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("constraintThresh", value);
                constraintThresh = value;
            }
        }

        private int weaponMask = 1024;
        /// <summary>
        /// Currently unused - no intoWorldTest. RAGE bit mask to exclude weapons from ray probe - currently defaults to MP3 weapon flag
        /// </summary>
        [EuphoriaDetail("Currently unused - no intoWorldTest. RAGE bit mask to exclude weapons from ray probe - currently defaults to MP3 weapon flag")]
        public int WeaponMask
        {
            get { return weaponMask; }
            set
            {

                SetArgument("weaponMask", value);
                weaponMask = value;
            }
        }

        private bool timeWarpActive = false;
        /// <summary>
        /// Is timeWarpActive enabled?
        /// </summary>
        [EuphoriaDetail("Is timeWarpActive enabled?")]
        public bool TimeWarpActive
        {
            get { return timeWarpActive; }
            set
            {

                SetArgument("timeWarpActive", value);
                timeWarpActive = value;
            }
        }

        private float timeWarpStrengthScale = 1.00f;
        /// <summary>
        /// Scale for arm and helper strength when timewarp is enabled. 1 = normal compensation.
        /// </summary>
        [EuphoriaDetail("Scale for arm and helper strength when timewarp is enabled. 1 = normal compensation.")]
        public float TimeWarpStrengthScale
        {
            get { return timeWarpStrengthScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 2.00f);
                SetArgument("timeWarpStrengthScale", value);
                timeWarpStrengthScale = value;
            }
        }

        private float oriStiff = 0.00f;
        /// <summary>
        /// Hand stabilization controller stiffness.
        /// </summary>
        [EuphoriaDetail("Hand stabilization controller stiffness.")]
        public float OriStiff
        {
            get { return oriStiff; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("oriStiff", value);
                oriStiff = value;
            }
        }

        private float oriDamp = 0.00f;
        /// <summary>
        /// Hand stabilization controller damping.
        /// </summary>
        [EuphoriaDetail("Hand stabilization controller damping.")]
        public float OriDamp
        {
            get { return oriDamp; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("oriDamp", value);
                oriDamp = value;
            }
        }

        private float posStiff = 0.00f;
        /// <summary>
        /// Hand stabilization controller stiffness.
        /// </summary>
        [EuphoriaDetail("Hand stabilization controller stiffness.")]
        public float PosStiff
        {
            get { return posStiff; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("posStiff", value);
                posStiff = value;
            }
        }

        private float posDamp = 0.00f;
        /// <summary>
        /// Hand stabilization controller damping.
        /// </summary>
        [EuphoriaDetail("Hand stabilization controller damping.")]
        public float PosDamp
        {
            get { return posDamp; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("posDamp", value);
                posDamp = value;
            }
        }


        public EuphoriaMessagePointGunExtra(bool startNow) : base("pointGunExtra", startNow)
        { }

        public new void Reset()
        {
            constraintStrength = 2.00f;
            constraintThresh = 0.10f;
            weaponMask = 1024;
            timeWarpActive = false;
            timeWarpStrengthScale = 1.00f;
            oriStiff = 0.00f;
            oriDamp = 0.00f;
            posStiff = 0.00f;
            posDamp = 0.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageRollDownStairs : EuphoriaMessage
    {
        private float stiffness = 11.0f;
        /// <summary>
        /// Effector Stiffness. value feeds through to rollUp directly
        /// </summary>
        [EuphoriaDetail("Effector Stiffness. value feeds through to rollUp directly")]
        public float Stiffness
        {
            get { return stiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("stiffness", value);
                stiffness = value;
            }
        }

        private float damping = 1.4f;
        /// <summary>
        /// Effector  Damping.
        /// </summary>
        [EuphoriaDetail("Effector  Damping.")]
        public float Damping
        {
            get { return damping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("damping", value);
                damping = value;
            }
        }

        private float forcemag = 0.55f;
        /// <summary>
        /// Helper force strength.  Do not go above 1 for a rollDownStairs/roll along ground reaction.
        /// </summary>
        [EuphoriaDetail("Helper force strength.  Do not go above 1 for a rollDownStairs/roll along ground reaction.")]
        public float Forcemag
        {
            get { return forcemag; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("forcemag", value);
                forcemag = value;
            }
        }

        private float m_useArmToSlowDown = -1.9f;
        /// <summary>
        /// the degree to which the character will try to stop a barrel roll with his arms
        /// </summary>
        [EuphoriaDetail("the degree to which the character will try to stop a barrel roll with his arms")]
        public float M_useArmToSlowDown
        {
            get { return m_useArmToSlowDown; }
            set
            {
                value = MathHelper.Clamp(value, -3.0f, 3.0f);
                SetArgument("m_useArmToSlowDown", value);
                m_useArmToSlowDown = value;
            }
        }

        private bool useZeroPose = false;
        /// <summary>
        /// Blends between a zeroPose and the Rollup, Faster the character is rotating the less the zeroPose
        /// </summary>
        [EuphoriaDetail("Blends between a zeroPose and the Rollup, Faster the character is rotating the less the zeroPose")]
        public bool UseZeroPose
        {
            get { return useZeroPose; }
            set
            {

                SetArgument("useZeroPose", value);
                useZeroPose = value;
            }
        }

        private bool spinWhenInAir = false;
        /// <summary>
        /// Applied cheat forces to spin the character when in the air, the forces are 40% of the forces applied when touching the ground.  Be careful little bunny rabbits, the character could spin unnaturally in the air.
        /// </summary>
        [EuphoriaDetail("Applied cheat forces to spin the character when in the air, the forces are 40% of the forces applied when touching the ground.  Be careful little bunny rabbits, the character could spin unnaturally in the air.")]
        public bool SpinWhenInAir
        {
            get { return spinWhenInAir; }
            set
            {

                SetArgument("spinWhenInAir", value);
                spinWhenInAir = value;
            }
        }

        private float m_armReachAmount = 1.4f;
        /// <summary>
        /// how much the character reaches with his arms to brace against the ground
        /// </summary>
        [EuphoriaDetail("how much the character reaches with his arms to brace against the ground")]
        public float M_armReachAmount
        {
            get { return m_armReachAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 3.0f);
                SetArgument("m_armReachAmount", value);
                m_armReachAmount = value;
            }
        }

        private float m_legPush = 1.0f;
        /// <summary>
        /// amount that the legs push outwards when tumbling
        /// </summary>
        [EuphoriaDetail("amount that the legs push outwards when tumbling")]
        public float M_legPush
        {
            get { return m_legPush; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("m_legPush", value);
                m_legPush = value;
            }
        }

        private bool tryToAvoidHeadButtingGround = false;
        /// <summary>
        /// Blends between a zeroPose and the Rollup, Faster the character is rotating the less the zeroPose
        /// </summary>
        [EuphoriaDetail("Blends between a zeroPose and the Rollup, Faster the character is rotating the less the zeroPose")]
        public bool TryToAvoidHeadButtingGround
        {
            get { return tryToAvoidHeadButtingGround; }
            set
            {

                SetArgument("tryToAvoidHeadButtingGround", value);
                tryToAvoidHeadButtingGround = value;
            }
        }

        private float armReachLength = 0.4f;
        /// <summary>
        /// the length that the arm reaches and so how much it straightens
        /// </summary>
        [EuphoriaDetail("the length that the arm reaches and so how much it straightens")]
        public float ArmReachLength
        {
            get { return armReachLength; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("armReachLength", value);
                armReachLength = value;
            }
        }

        private Vector3 customRollDir = new Vector3(0f, 0f, 1f);
        /// <summary>
        /// pass in a custom direction in to have the character try and roll in that direction
        /// </summary>
        [EuphoriaDetail("pass in a custom direction in to have the character try and roll in that direction")]
        public Vector3 CustomRollDir
        {
            get { return customRollDir; }
            set
            {
                value.X = MathHelper.Clamp(value.X, 1.0f, 1.0f);
                value.Y = MathHelper.Clamp(value.Y, 1.0f, 1.0f);
                value.Z = MathHelper.Clamp(value.Z, 1.0f, 1.0f);
                SetArgument("customRollDir", value);
                customRollDir = value;
            }
        }

        private bool useCustomRollDir = false;
        /// <summary>
        /// pass in true to use the customRollDir parameter
        /// </summary>
        [EuphoriaDetail("pass in true to use the customRollDir parameter")]
        public bool UseCustomRollDir
        {
            get { return useCustomRollDir; }
            set
            {

                SetArgument("useCustomRollDir", value);
                useCustomRollDir = value;
            }
        }

        private float stiffnessDecayTarget = 9.0f;
        /// <summary>
        /// The target linear velocity used to start the rolling.
        /// </summary>
        [EuphoriaDetail("The target linear velocity used to start the rolling.")]
        public float StiffnessDecayTarget
        {
            get { return stiffnessDecayTarget; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("stiffnessDecayTarget", value);
                stiffnessDecayTarget = value;
            }
        }

        private float stiffnessDecayTime = -1.0f;
        /// <summary>
        /// time, in seconds, to decay stiffness down to the stiffnessDecayTarget value (or -1 to disable)
        /// </summary>
        [EuphoriaDetail("time, in seconds, to decay stiffness down to the stiffnessDecayTarget value (or -1 to disable)")]
        public float StiffnessDecayTime
        {
            get { return stiffnessDecayTime; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 10.0f);
                SetArgument("stiffnessDecayTime", value);
                stiffnessDecayTime = value;
            }
        }

        private float asymmetricalLegs = 0.0f;
        /// <summary>
        /// 0 is no leg asymmetry in 'foetal' position.  greater than 0 a asymmetricalLegs-rand(30%), added/minus each joint of the legs in radians.  Random number changes about once every roll.  0.4 gives a lot of asymmetry
        /// </summary>
        [EuphoriaDetail("0 is no leg asymmetry in 'foetal' position.  greater than 0 a asymmetricalLegs-rand(30%), added/minus each joint of the legs in radians.  Random number changes about once every roll.  0.4 gives a lot of asymmetry")]
        public float AsymmetricalLegs
        {
            get { return asymmetricalLegs; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("asymmetricalLegs", value);
                asymmetricalLegs = value;
            }
        }

        private float zAxisSpinReduction = 0.0f;
        /// <summary>
        /// Tries to reduce the spin around the z axis. Scale 0 - 1
        /// </summary>
        [EuphoriaDetail("Tries to reduce the spin around the z axis. Scale 0 - 1")]
        public float ZAxisSpinReduction
        {
            get { return zAxisSpinReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("zAxisSpinReduction", value);
                zAxisSpinReduction = value;
            }
        }

        private float targetLinearVelocityDecayTime = 0.5f;
        /// <summary>
        /// Time for the targetlinearVelocity to decay to zero.
        /// </summary>
        [EuphoriaDetail("Time for the targetlinearVelocity to decay to zero.")]
        public float TargetLinearVelocityDecayTime
        {
            get { return targetLinearVelocityDecayTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("targetLinearVelocityDecayTime", value);
                targetLinearVelocityDecayTime = value;
            }
        }

        private float targetLinearVelocity = 1.0f;
        /// <summary>
        /// Helper torques are applied to match the spin of the character to the max of targetLinearVelocity and COMVelMag
        /// </summary>
        [EuphoriaDetail("Helper torques are applied to match the spin of the character to the max of targetLinearVelocity and COMVelMag")]
        public float TargetLinearVelocity
        {
            get { return targetLinearVelocity; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("targetLinearVelocity", value);
                targetLinearVelocity = value;
            }
        }

        private bool onlyApplyHelperForces = false;
        /// <summary>
        /// Don't use rollup if true
        /// </summary>
        [EuphoriaDetail("Don't use rollup if true")]
        public bool OnlyApplyHelperForces
        {
            get { return onlyApplyHelperForces; }
            set
            {

                SetArgument("onlyApplyHelperForces", value);
                onlyApplyHelperForces = value;
            }
        }

        private bool useVelocityOfObjectBelow = false;
        /// <summary>
        /// scale applied cheat forces/torques to (zero) if object underneath character has velocity greater than 1.f
        /// </summary>
        [EuphoriaDetail("scale applied cheat forces/torques to (zero) if object underneath character has velocity greater than 1.f")]
        public bool UseVelocityOfObjectBelow
        {
            get { return useVelocityOfObjectBelow; }
            set
            {

                SetArgument("useVelocityOfObjectBelow", value);
                useVelocityOfObjectBelow = value;
            }
        }

        private bool useRelativeVelocity = false;
        /// <summary>
        /// useVelocityOfObjectBelow uses a relative velocity of the character to the object underneath
        /// </summary>
        [EuphoriaDetail("useVelocityOfObjectBelow uses a relative velocity of the character to the object underneath")]
        public bool UseRelativeVelocity
        {
            get { return useRelativeVelocity; }
            set
            {

                SetArgument("useRelativeVelocity", value);
                useRelativeVelocity = value;
            }
        }

        private bool applyFoetalToLegs = false;
        /// <summary>
        /// if true, use rollup for upper body and a kind of foetal behavior for legs
        /// </summary>
        [EuphoriaDetail("if true, use rollup for upper body and a kind of foetal behavior for legs")]
        public bool ApplyFoetalToLegs
        {
            get { return applyFoetalToLegs; }
            set
            {

                SetArgument("applyFoetalToLegs", value);
                applyFoetalToLegs = value;
            }
        }

        private float movementLegsInFoetalPosition = 1.30f;
        /// <summary>
        /// Only used if applyFoetalToLegs = true : define the variation of angles for the joints of the legs
        /// </summary>
        [EuphoriaDetail("Only used if applyFoetalToLegs = true : define the variation of angles for the joints of the legs")]
        public float MovementLegsInFoetalPosition
        {
            get { return movementLegsInFoetalPosition; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("movementLegsInFoetalPosition", value);
                movementLegsInFoetalPosition = value;
            }
        }

        private float maxAngVelAroundFrontwardAxis = 2.0f;
        /// <summary>
        /// Only used if applyNewRollingCheatingTorques or applyHelPerTorqueToAlign defined to true : maximal angular velocity around frontward axis of the pelvis to apply cheating torques.
        /// </summary>
        [EuphoriaDetail("Only used if applyNewRollingCheatingTorques or applyHelPerTorqueToAlign defined to true : maximal angular velocity around frontward axis of the pelvis to apply cheating torques.")]
        public float MaxAngVelAroundFrontwardAxis
        {
            get { return maxAngVelAroundFrontwardAxis; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 10.0f);
                SetArgument("maxAngVelAroundFrontwardAxis", value);
                maxAngVelAroundFrontwardAxis = value;
            }
        }

        private float minAngVel = 0.5f;
        /// <summary>
        /// Only used if applyNewRollingCheatingTorques or applyHelPerTorqueToAlign defined to true : minimal angular velocity of the roll to apply cheating torques
        /// </summary>
        [EuphoriaDetail("Only used if applyNewRollingCheatingTorques or applyHelPerTorqueToAlign defined to true : minimal angular velocity of the roll to apply cheating torques")]
        public float MinAngVel
        {
            get { return minAngVel; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("minAngVel", value);
                minAngVel = value;
            }
        }

        private bool applyNewRollingCheatingTorques = false;
        /// <summary>
        /// if true will use the new way to apply cheating torques (like in fallOverWall), otherwise will use the old way
        /// </summary>
        [EuphoriaDetail("if true will use the new way to apply cheating torques (like in fallOverWall), otherwise will use the old way")]
        public bool ApplyNewRollingCheatingTorques
        {
            get { return applyNewRollingCheatingTorques; }
            set
            {

                SetArgument("applyNewRollingCheatingTorques", value);
                applyNewRollingCheatingTorques = value;
            }
        }

        private float maxAngVel = 5.0f;
        /// <summary>
        /// Only used if applyNewRollingCheatingTorques defined to true : maximal angular velocity of the roll to apply cheating torque
        /// </summary>
        [EuphoriaDetail("Only used if applyNewRollingCheatingTorques defined to true : maximal angular velocity of the roll to apply cheating torque")]
        public float MaxAngVel
        {
            get { return maxAngVel; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("maxAngVel", value);
                maxAngVel = value;
            }
        }

        private float magOfTorqueToRoll = 50.0f;
        /// <summary>
        /// Only used if applyNewRollingCheatingTorques defined to true : magnitude of the torque to roll down the stairs
        /// </summary>
        [EuphoriaDetail("Only used if applyNewRollingCheatingTorques defined to true : magnitude of the torque to roll down the stairs")]
        public float MagOfTorqueToRoll
        {
            get { return magOfTorqueToRoll; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 500.0f);
                SetArgument("magOfTorqueToRoll", value);
                magOfTorqueToRoll = value;
            }
        }

        private bool applyHelPerTorqueToAlign = false;
        /// <summary>
        /// apply torque to align the body orthogonally to the direction of the roll
        /// </summary>
        [EuphoriaDetail("apply torque to align the body orthogonally to the direction of the roll")]
        public bool ApplyHelPerTorqueToAlign
        {
            get { return applyHelPerTorqueToAlign; }
            set
            {

                SetArgument("applyHelPerTorqueToAlign", value);
                applyHelPerTorqueToAlign = value;
            }
        }

        private float delayToAlignBody = 0.2f;
        /// <summary>
        /// Only used if applyHelPerTorqueToAlign defined to true : delay to start to apply torques
        /// </summary>
        [EuphoriaDetail("Only used if applyHelPerTorqueToAlign defined to true : delay to start to apply torques")]
        public float DelayToAlignBody
        {
            get { return delayToAlignBody; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("delayToAlignBody", value);
                delayToAlignBody = value;
            }
        }

        private float magOfTorqueToAlign = 50.0f;
        /// <summary>
        /// Only used if applyHelPerTorqueToAlign defined to true : magnitude of the torque to align orthogonally the body
        /// </summary>
        [EuphoriaDetail("Only used if applyHelPerTorqueToAlign defined to true : magnitude of the torque to align orthogonally the body")]
        public float MagOfTorqueToAlign
        {
            get { return magOfTorqueToAlign; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 500.0f);
                SetArgument("magOfTorqueToAlign", value);
                magOfTorqueToAlign = value;
            }
        }

        private float airborneReduction = 0.85f;
        /// <summary>
        /// Ordinarily keep at 0.85.  Make this lower if you want spinning in the air.
        /// </summary>
        [EuphoriaDetail("Ordinarily keep at 0.85.  Make this lower if you want spinning in the air.")]
        public float AirborneReduction
        {
            get { return airborneReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("airborneReduction", value);
                airborneReduction = value;
            }
        }

        private bool applyMinMaxFriction = true;
        /// <summary>
        /// Pass-through to Roll Up. Controls whether or not behaviour enforces min/max friction.
        /// </summary>
        [EuphoriaDetail("Pass-through to Roll Up. Controls whether or not behaviour enforces min/max friction.")]
        public bool ApplyMinMaxFriction
        {
            get { return applyMinMaxFriction; }
            set
            {

                SetArgument("applyMinMaxFriction", value);
                applyMinMaxFriction = value;
            }
        }

        private bool limitSpinReduction = false;
        /// <summary>
        /// Scale zAxisSpinReduction back when rotating end-over-end (somersault) to give the body a chance to align with the axis of rotation.
        /// </summary>
        [EuphoriaDetail("Scale zAxisSpinReduction back when rotating end-over-end (somersault) to give the body a chance to align with the axis of rotation.")]
        public bool LimitSpinReduction
        {
            get { return limitSpinReduction; }
            set
            {

                SetArgument("limitSpinReduction", value);
                limitSpinReduction = value;
            }
        }


        public EuphoriaMessageRollDownStairs(bool startNow) : base("rollDownStairs", startNow)
        { }

        public new void Reset()
        {
            stiffness = 11.0f;
            damping = 1.4f;
            forcemag = 0.55f;
            m_useArmToSlowDown = -1.9f;
            useZeroPose = false;
            spinWhenInAir = false;
            m_armReachAmount = 1.4f;
            m_legPush = 1.0f;
            tryToAvoidHeadButtingGround = false;
            armReachLength = 0.4f;
            customRollDir = new Vector3(0f, 0f, 1f);
            useCustomRollDir = false;
            stiffnessDecayTarget = 9.0f;
            stiffnessDecayTime = -1.0f;
            asymmetricalLegs = 0.0f;
            zAxisSpinReduction = 0.0f;
            targetLinearVelocityDecayTime = 0.5f;
            targetLinearVelocity = 1.0f;
            onlyApplyHelperForces = false;
            useVelocityOfObjectBelow = false;
            useRelativeVelocity = false;
            applyFoetalToLegs = false;
            movementLegsInFoetalPosition = 1.30f;
            maxAngVelAroundFrontwardAxis = 2.0f;
            minAngVel = 0.5f;
            applyNewRollingCheatingTorques = false;
            maxAngVel = 5.0f;
            magOfTorqueToRoll = 50.0f;
            applyHelPerTorqueToAlign = false;
            delayToAlignBody = 0.2f;
            magOfTorqueToAlign = 50.0f;
            airborneReduction = 0.85f;
            applyMinMaxFriction = true;
            limitSpinReduction = false;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageShot : EuphoriaMessage
    {
        private float bodyStiffness = 11.00f;
        /// <summary>
        /// stiffness of body. Feeds through to roll_up
        /// </summary>
        [EuphoriaDetail("stiffness of body. Feeds through to roll_up")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private float spineDamping = 1.00f;
        /// <summary>
        /// stiffness of body. Feeds through to roll_up
        /// </summary>
        [EuphoriaDetail("stiffness of body. Feeds through to roll_up")]
        public float SpineDamping
        {
            get { return spineDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 2.00f);
                SetArgument("spineDamping", value);
                spineDamping = value;
            }
        }

        private float armStiffness = 10.00f;
        /// <summary>
        /// arm stiffness
        /// </summary>
        [EuphoriaDetail("arm stiffness")]
        public float ArmStiffness
        {
            get { return armStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("armStiffness", value);
                armStiffness = value;
            }
        }

        private float initialNeckStiffness = 14.00f;
        /// <summary>
        /// initial stiffness of neck after being shot.
        /// </summary>
        [EuphoriaDetail("initial stiffness of neck after being shot.")]
        public float InitialNeckStiffness
        {
            get { return initialNeckStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 3.00f, 16.00f);
                SetArgument("initialNeckStiffness", value);
                initialNeckStiffness = value;
            }
        }

        private float initialNeckDamping = 1.00f;
        /// <summary>
        /// intial damping of neck after being shot.
        /// </summary>
        [EuphoriaDetail("intial damping of neck after being shot.")]
        public float InitialNeckDamping
        {
            get { return initialNeckDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 10.00f);
                SetArgument("initialNeckDamping", value);
                initialNeckDamping = value;
            }
        }

        private float neckStiffness = 14.00f;
        /// <summary>
        /// stiffness of neck.
        /// </summary>
        [EuphoriaDetail("stiffness of neck.")]
        public float NeckStiffness
        {
            get { return neckStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 3.00f, 16.00f);
                SetArgument("neckStiffness", value);
                neckStiffness = value;
            }
        }

        private float neckDamping = 1.00f;
        /// <summary>
        /// damping of neck.
        /// </summary>
        [EuphoriaDetail("damping of neck.")]
        public float NeckDamping
        {
            get { return neckDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 2.00f);
                SetArgument("neckDamping", value);
                neckDamping = value;
            }
        }

        private float kMultOnLoose = 0.00f;
        /// <summary>
        /// how much to add to upperbody stiffness dependent on looseness
        /// </summary>
        [EuphoriaDetail("how much to add to upperbody stiffness dependent on looseness")]
        public float KMultOnLoose
        {
            get { return kMultOnLoose; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("kMultOnLoose", value);
                kMultOnLoose = value;
            }
        }

        private float kMult4Legs = 0.30f;
        /// <summary>
        /// how much to add to leg stiffnesses dependent on looseness
        /// </summary>
        [EuphoriaDetail("how much to add to leg stiffnesses dependent on looseness")]
        public float KMult4Legs
        {
            get { return kMult4Legs; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("kMult4Legs", value);
                kMult4Legs = value;
            }
        }

        private float loosenessAmount = 1.00f;
        /// <summary>
        /// how loose the character is made by a newBullet. between 0 and 1
        /// </summary>
        [EuphoriaDetail("how loose the character is made by a newBullet. between 0 and 1")]
        public float LoosenessAmount
        {
            get { return loosenessAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("loosenessAmount", value);
                loosenessAmount = value;
            }
        }

        private float looseness4Fall = 0.00f;
        /// <summary>
        /// how loose the character is made by a newBullet if falling
        /// </summary>
        [EuphoriaDetail("how loose the character is made by a newBullet if falling")]
        public float Looseness4Fall
        {
            get { return looseness4Fall; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("looseness4Fall", value);
                looseness4Fall = value;
            }
        }

        private float looseness4Stagger = 0.00f;
        /// <summary>
        /// how loose the upperBody of the character is made by a newBullet if staggerFall is running (and not falling).  Note atm the neck ramp values are ignored in staggerFall
        /// </summary>
        [EuphoriaDetail("how loose the upperBody of the character is made by a newBullet if staggerFall is running (and not falling).  Note atm the neck ramp values are ignored in staggerFall")]
        public float Looseness4Stagger
        {
            get { return looseness4Stagger; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("looseness4Stagger", value);
                looseness4Stagger = value;
            }
        }

        private float minArmsLooseness = 0.10f;
        /// <summary>
        /// minimum looseness to apply to the arms
        /// </summary>
        [EuphoriaDetail("minimum looseness to apply to the arms")]
        public float MinArmsLooseness
        {
            get { return minArmsLooseness; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("minArmsLooseness", value);
                minArmsLooseness = value;
            }
        }

        private float minLegsLooseness = 0.10f;
        /// <summary>
        /// minimum looseness to apply to the Legs
        /// </summary>
        [EuphoriaDetail("minimum looseness to apply to the Legs")]
        public float MinLegsLooseness
        {
            get { return minLegsLooseness; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("minLegsLooseness", value);
                minLegsLooseness = value;
            }
        }

        private float grabHoldTime = 2.00f;
        /// <summary>
        /// how long to hold for before returning to relaxed arm position
        /// </summary>
        [EuphoriaDetail("how long to hold for before returning to relaxed arm position")]
        public float GrabHoldTime
        {
            get { return grabHoldTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("grabHoldTime", value);
                grabHoldTime = value;
            }
        }

        private bool spineBlendExagCPain = false;
        /// <summary>
        /// true: spine is blended with zero pose, false: spine is blended with zero pose if not setting exag or cpain
        /// </summary>
        [EuphoriaDetail("true: spine is blended with zero pose, false: spine is blended with zero pose if not setting exag or cpain")]
        public bool SpineBlendExagCPain
        {
            get { return spineBlendExagCPain; }
            set
            {

                SetArgument("spineBlendExagCPain", value);
                spineBlendExagCPain = value;
            }
        }

        private float spineBlendZero = 0.60f;
        /// <summary>
        /// spine is always blended with zero pose this much and up to 1 as the character become stationary.  If negative no blend is ever applied.
        /// </summary>
        [EuphoriaDetail("spine is always blended with zero pose this much and up to 1 as the character become stationary.  If negative no blend is ever applied.")]
        public float SpineBlendZero
        {
            get { return spineBlendZero; }
            set
            {
                value = MathHelper.Clamp(value, -0.10f, 1.0f);
                SetArgument("spineBlendZero", value);
                spineBlendZero = value;
            }
        }

        private bool bulletProofVest = false;
        /// <summary>
        /// looseness applied to spine is different if bulletProofVest is true
        /// </summary>
        [EuphoriaDetail("looseness applied to spine is different if bulletProofVest is true")]
        public bool BulletProofVest
        {
            get { return bulletProofVest; }
            set
            {

                SetArgument("bulletProofVest", value);
                bulletProofVest = value;
            }
        }

        private bool alwaysResetLooseness = true;
        /// <summary>
        /// looseness always reset on shotNewBullet even if previous looseness ramp still running.  Except for the neck which has it's own ramp.
        /// </summary>
        [EuphoriaDetail("looseness always reset on shotNewBullet even if previous looseness ramp still running.  Except for the neck which has it's own ramp.")]
        public bool AlwaysResetLooseness
        {
            get { return alwaysResetLooseness; }
            set
            {

                SetArgument("alwaysResetLooseness", value);
                alwaysResetLooseness = value;
            }
        }

        private bool alwaysResetNeckLooseness = true;
        /// <summary>
        /// Neck looseness always reset on shotNewBullet even if previous looseness ramp still running
        /// </summary>
        [EuphoriaDetail("Neck looseness always reset on shotNewBullet even if previous looseness ramp still running")]
        public bool AlwaysResetNeckLooseness
        {
            get { return alwaysResetNeckLooseness; }
            set
            {

                SetArgument("alwaysResetNeckLooseness", value);
                alwaysResetNeckLooseness = value;
            }
        }

        private float angVelScale = 1.00f;
        /// <summary>
        /// How much to scale the angular velocity coming in from animation of a part if it is in angVelScaleMask (otherwise scale by 1.0)
        /// </summary>
        [EuphoriaDetail("How much to scale the angular velocity coming in from animation of a part if it is in angVelScaleMask (otherwise scale by 1.0)")]
        public float AngVelScale
        {
            get { return angVelScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("angVelScale", value);
                angVelScale = value;
            }
        }

        private string angVelScaleMask = "fb";
        /// <summary>
        /// Parts to scale the initial angular velocity by angVelScale (otherwize scale by 1.0)
        /// </summary>
        [EuphoriaDetail("Parts to scale the initial angular velocity by angVelScale (otherwize scale by 1.0)")]
        public string AngVelScaleMask
        {
            get { return angVelScaleMask; }
            set
            {

                SetArgument("angVelScaleMask", value);
                angVelScaleMask = value;
            }
        }

        private float flingWidth = 0.50f;
        /// <summary>
        /// Width of the fling behaviour.
        /// </summary>
        [EuphoriaDetail("Width of the fling behaviour.")]
        public float FlingWidth
        {
            get { return flingWidth; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("flingWidth", value);
                flingWidth = value;
            }
        }

        private float flingTime = 0.60f;
        /// <summary>
        /// Duration of the fling behaviour.
        /// </summary>
        [EuphoriaDetail("Duration of the fling behaviour.")]
        public float FlingTime
        {
            get { return flingTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("flingTime", value);
                flingTime = value;
            }
        }

        private float timeBeforeReachForWound = 0.20f;
        /// <summary>
        /// time, in seconds, before the character begins to grab for the wound on the first hit
        /// </summary>
        [EuphoriaDetail("time, in seconds, before the character begins to grab for the wound on the first hit")]
        public float TimeBeforeReachForWound
        {
            get { return timeBeforeReachForWound; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("timeBeforeReachForWound", value);
                timeBeforeReachForWound = value;
            }
        }

        private float exagDuration = 0.00f;
        /// <summary>
        /// exaggerate bullet duration (at exagMag/exagTwistMag)
        /// </summary>
        [EuphoriaDetail("exaggerate bullet duration (at exagMag/exagTwistMag)")]
        public float ExagDuration
        {
            get { return exagDuration; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("exagDuration", value);
                exagDuration = value;
            }
        }

        private float exagMag = 1.00f;
        /// <summary>
        /// exaggerate bullet spine Lean magnitude
        /// </summary>
        [EuphoriaDetail("exaggerate bullet spine Lean magnitude")]
        public float ExagMag
        {
            get { return exagMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("exagMag", value);
                exagMag = value;
            }
        }

        private float exagTwistMag = 0.50f;
        /// <summary>
        /// exaggerate bullet spine Twist magnitude
        /// </summary>
        [EuphoriaDetail("exaggerate bullet spine Twist magnitude")]
        public float ExagTwistMag
        {
            get { return exagTwistMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("exagTwistMag", value);
                exagTwistMag = value;
            }
        }

        private float exagSmooth2Zero = 0.00f;
        /// <summary>
        /// exaggerate bullet duration ramping to zero after exagDuration
        /// </summary>
        [EuphoriaDetail("exaggerate bullet duration ramping to zero after exagDuration")]
        public float ExagSmooth2Zero
        {
            get { return exagSmooth2Zero; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("exagSmooth2Zero", value);
                exagSmooth2Zero = value;
            }
        }

        private float exagZeroTime = 0.00f;
        /// <summary>
        /// exaggerate bullet time spent at 0 spine lean/twist after exagDuration + exagSmooth2Zero
        /// </summary>
        [EuphoriaDetail("exaggerate bullet time spent at 0 spine lean/twist after exagDuration + exagSmooth2Zero")]
        public float ExagZeroTime
        {
            get { return exagZeroTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("exagZeroTime", value);
                exagZeroTime = value;
            }
        }

        private float cpainSmooth2Time = 0.20f;
        /// <summary>
        /// conscious pain duration ramping from zero to cpainMag/cpainTwistMag
        /// </summary>
        [EuphoriaDetail("conscious pain duration ramping from zero to cpainMag/cpainTwistMag")]
        public float CpainSmooth2Time
        {
            get { return cpainSmooth2Time; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("cpainSmooth2Time", value);
                cpainSmooth2Time = value;
            }
        }

        private float cpainDuration = 0.00f;
        /// <summary>
        /// conscious pain duration at cpainMag/cpainTwistMag after cpainSmooth2Time
        /// </summary>
        [EuphoriaDetail("conscious pain duration at cpainMag/cpainTwistMag after cpainSmooth2Time")]
        public float CpainDuration
        {
            get { return cpainDuration; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("cpainDuration", value);
                cpainDuration = value;
            }
        }

        private float cpainMag = 1.00f;
        /// <summary>
        /// conscious pain spine Lean(back/Forward) magnitude (Replaces spinePainMultiplier)
        /// </summary>
        [EuphoriaDetail("conscious pain spine Lean(back/Forward) magnitude (Replaces spinePainMultiplier)")]
        public float CpainMag
        {
            get { return cpainMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.00f);
                SetArgument("cpainMag", value);
                cpainMag = value;
            }
        }

        private float cpainTwistMag = 0.50f;
        /// <summary>
        /// conscious pain spine Twist/Lean2Side magnitude Replaces spinePainTwistMultiplier)
        /// </summary>
        [EuphoriaDetail("conscious pain spine Twist/Lean2Side magnitude Replaces spinePainTwistMultiplier)")]
        public float CpainTwistMag
        {
            get { return cpainTwistMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("cpainTwistMag", value);
                cpainTwistMag = value;
            }
        }

        private float cpainSmooth2Zero = 1.50f;
        /// <summary>
        /// conscious pain ramping to zero after cpainSmooth2Time + cpainDuration (Replaces spinePainTime)
        /// </summary>
        [EuphoriaDetail("conscious pain ramping to zero after cpainSmooth2Time + cpainDuration (Replaces spinePainTime)")]
        public float CpainSmooth2Zero
        {
            get { return cpainSmooth2Zero; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("cpainSmooth2Zero", value);
                cpainSmooth2Zero = value;
            }
        }

        private bool crouching = false;
        /// <summary>
        /// is the guy crouching or not
        /// </summary>
        [EuphoriaDetail("is the guy crouching or not")]
        public bool Crouching
        {
            get { return crouching; }
            set
            {

                SetArgument("crouching", value);
                crouching = value;
            }
        }

        private bool chickenArms = false;
        /// <summary>
        /// Type of reaction
        /// </summary>
        [EuphoriaDetail("Type of reaction")]
        public bool ChickenArms
        {
            get { return chickenArms; }
            set
            {

                SetArgument("chickenArms", value);
                chickenArms = value;
            }
        }

        private bool reachForWound = true;
        /// <summary>
        /// Type of reaction
        /// </summary>
        [EuphoriaDetail("Type of reaction")]
        public bool ReachForWound
        {
            get { return reachForWound; }
            set
            {

                SetArgument("reachForWound", value);
                reachForWound = value;
            }
        }

        private bool fling = false;
        /// <summary>
        /// Type of reaction
        /// </summary>
        [EuphoriaDetail("Type of reaction")]
        public bool Fling
        {
            get { return fling; }
            set
            {

                SetArgument("fling", value);
                fling = value;
            }
        }

        private bool allowInjuredArm = false;
        /// <summary>
        /// injured arm code runs if arm hit (turns and steps and bends injured arm)
        /// </summary>
        [EuphoriaDetail("injured arm code runs if arm hit (turns and steps and bends injured arm)")]
        public bool AllowInjuredArm
        {
            get { return allowInjuredArm; }
            set
            {

                SetArgument("allowInjuredArm", value);
                allowInjuredArm = value;
            }
        }

        private bool allowInjuredLeg = true;
        /// <summary>
        /// when false injured leg is not bent and character does not bend to reach it
        /// </summary>
        [EuphoriaDetail("when false injured leg is not bent and character does not bend to reach it")]
        public bool AllowInjuredLeg
        {
            get { return allowInjuredLeg; }
            set
            {

                SetArgument("allowInjuredLeg", value);
                allowInjuredLeg = value;
            }
        }

        private bool allowInjuredLowerLegReach = false;
        /// <summary>
        /// when false don't try to reach for injured Lower Legs (shins/feet)
        /// </summary>
        [EuphoriaDetail("when false don't try to reach for injured Lower Legs (shins/feet)")]
        public bool AllowInjuredLowerLegReach
        {
            get { return allowInjuredLowerLegReach; }
            set
            {

                SetArgument("allowInjuredLowerLegReach", value);
                allowInjuredLowerLegReach = value;
            }
        }

        private bool allowInjuredThighReach = true;
        /// <summary>
        /// when false don't try to reach for injured Thighs
        /// </summary>
        [EuphoriaDetail("when false don't try to reach for injured Thighs")]
        public bool AllowInjuredThighReach
        {
            get { return allowInjuredThighReach; }
            set
            {

                SetArgument("allowInjuredThighReach", value);
                allowInjuredThighReach = value;
            }
        }

        private bool stableHandsAndNeck = false;
        /// <summary>
        /// additional stability for hands and neck (less loose)
        /// </summary>
        [EuphoriaDetail("additional stability for hands and neck (less loose)")]
        public bool StableHandsAndNeck
        {
            get { return stableHandsAndNeck; }
            set
            {

                SetArgument("stableHandsAndNeck", value);
                stableHandsAndNeck = value;
            }
        }

        private bool melee = false;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool Melee
        {
            get { return melee; }
            set
            {

                SetArgument("melee", value);
                melee = value;
            }
        }

        private int fallingReaction = 0;
        /// <summary>
        /// 0=Rollup, 1=Catchfall, 2=rollDownStairs, 3=smartFall
        /// </summary>
        [EuphoriaDetail("0=Rollup, 1=Catchfall, 2=rollDownStairs, 3=smartFall")]
        public int FallingReaction
        {
            get { return fallingReaction; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("fallingReaction", value);
                fallingReaction = value;
            }
        }

        private bool useExtendedCatchFall = false;
        /// <summary>
        /// keep the character active instead of relaxing at the end of the catch fall
        /// </summary>
        [EuphoriaDetail("keep the character active instead of relaxing at the end of the catch fall")]
        public bool UseExtendedCatchFall
        {
            get { return useExtendedCatchFall; }
            set
            {

                SetArgument("useExtendedCatchFall", value);
                useExtendedCatchFall = value;
            }
        }

        private float initialWeaknessZeroDuration = 0.00f;
        /// <summary>
        /// duration for which the character's upper body stays at minimum stiffness (not quite zero)
        /// </summary>
        [EuphoriaDetail("duration for which the character's upper body stays at minimum stiffness (not quite zero)")]
        public float InitialWeaknessZeroDuration
        {
            get { return initialWeaknessZeroDuration; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("initialWeaknessZeroDuration", value);
                initialWeaknessZeroDuration = value;
            }
        }

        private float initialWeaknessRampDuration = 0.40f;
        /// <summary>
        /// duration of the ramp to bring the character's upper body stiffness back to normal levels
        /// </summary>
        [EuphoriaDetail("duration of the ramp to bring the character's upper body stiffness back to normal levels")]
        public float InitialWeaknessRampDuration
        {
            get { return initialWeaknessRampDuration; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("initialWeaknessRampDuration", value);
                initialWeaknessRampDuration = value;
            }
        }

        private float initialNeckDuration = 0.00f;
        /// <summary>
        /// duration for which the neck stays at intial stiffness/damping
        /// </summary>
        [EuphoriaDetail("duration for which the neck stays at intial stiffness/damping")]
        public float InitialNeckDuration
        {
            get { return initialNeckDuration; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("initialNeckDuration", value);
                initialNeckDuration = value;
            }
        }

        private float initialNeckRampDuration = 0.40f;
        /// <summary>
        /// duration of the ramp to bring the neck stiffness/damping back to normal levels
        /// </summary>
        [EuphoriaDetail("duration of the ramp to bring the neck stiffness/damping back to normal levels")]
        public float InitialNeckRampDuration
        {
            get { return initialNeckRampDuration; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("initialNeckRampDuration", value);
                initialNeckRampDuration = value;
            }
        }

        private bool useCStrModulation = false;
        /// <summary>
        /// if enabled upper and lower body strength scales with character strength, using the range given by parameters below
        /// </summary>
        [EuphoriaDetail("if enabled upper and lower body strength scales with character strength, using the range given by parameters below")]
        public bool UseCStrModulation
        {
            get { return useCStrModulation; }
            set
            {

                SetArgument("useCStrModulation", value);
                useCStrModulation = value;
            }
        }

        private float cStrUpperMin = 0.10f;
        /// <summary>
        /// proportions to what the strength would be normally
        /// </summary>
        [EuphoriaDetail("proportions to what the strength would be normally")]
        public float CStrUpperMin
        {
            get { return cStrUpperMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 1.00f);
                SetArgument("cStrUpperMin", value);
                cStrUpperMin = value;
            }
        }

        private float cStrUpperMax = 1.00f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float CStrUpperMax
        {
            get { return cStrUpperMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 1.00f);
                SetArgument("cStrUpperMax", value);
                cStrUpperMax = value;
            }
        }

        private float cStrLowerMin = 0.10f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float CStrLowerMin
        {
            get { return cStrLowerMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 1.00f);
                SetArgument("cStrLowerMin", value);
                cStrLowerMin = value;
            }
        }

        private float cStrLowerMax = 1.00f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float CStrLowerMax
        {
            get { return cStrLowerMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.10f, 1.00f);
                SetArgument("cStrLowerMax", value);
                cStrLowerMax = value;
            }
        }

        private float deathTime = -1.00f;
        /// <summary>
        /// time to death (HACK for underwater). If -ve don't ever die
        /// </summary>
        [EuphoriaDetail("time to death (HACK for underwater). If -ve don't ever die")]
        public float DeathTime
        {
            get { return deathTime; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1000.0f);
                SetArgument("deathTime", value);
                deathTime = value;
            }
        }


        public EuphoriaMessageShot(bool startNow) : base("shot", startNow)
        { }

        public new void Reset()
        {
            bodyStiffness = 11.00f;
            spineDamping = 1.00f;
            armStiffness = 10.00f;
            initialNeckStiffness = 14.00f;
            initialNeckDamping = 1.00f;
            neckStiffness = 14.00f;
            neckDamping = 1.00f;
            kMultOnLoose = 0.00f;
            kMult4Legs = 0.30f;
            loosenessAmount = 1.00f;
            looseness4Fall = 0.00f;
            looseness4Stagger = 0.00f;
            minArmsLooseness = 0.10f;
            minLegsLooseness = 0.10f;
            grabHoldTime = 2.00f;
            spineBlendExagCPain = false;
            spineBlendZero = 0.60f;
            bulletProofVest = false;
            alwaysResetLooseness = true;
            alwaysResetNeckLooseness = true;
            angVelScale = 1.00f;
            angVelScaleMask = "fb";
            flingWidth = 0.50f;
            flingTime = 0.60f;
            timeBeforeReachForWound = 0.20f;
            exagDuration = 0.00f;
            exagMag = 1.00f;
            exagTwistMag = 0.50f;
            exagSmooth2Zero = 0.00f;
            exagZeroTime = 0.00f;
            cpainSmooth2Time = 0.20f;
            cpainDuration = 0.00f;
            cpainMag = 1.00f;
            cpainTwistMag = 0.50f;
            cpainSmooth2Zero = 1.50f;
            crouching = false;
            chickenArms = false;
            reachForWound = true;
            fling = false;
            allowInjuredArm = false;
            allowInjuredLeg = true;
            allowInjuredLowerLegReach = false;
            allowInjuredThighReach = true;
            stableHandsAndNeck = false;
            melee = false;
            fallingReaction = 0;
            useExtendedCatchFall = false;
            initialWeaknessZeroDuration = 0.00f;
            initialWeaknessRampDuration = 0.40f;
            initialNeckDuration = 0.00f;
            initialNeckRampDuration = 0.40f;
            useCStrModulation = false;
            cStrUpperMin = 0.10f;
            cStrUpperMax = 1.00f;
            cStrLowerMin = 0.10f;
            cStrLowerMax = 1.00f;
            deathTime = -1.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// shotNewBullet:  Send new wound information to the shot.  Can cause shot to restart it's performance in part or in whole.
    /// </summary>
    [EuphoriaDetail("shotNewBullet:  Send new wound information to the shot.  Can cause shot to restart it's performance in part or in whole.")]
    internal class EuphoriaMessageShotNewBullet : EuphoriaMessage
    {
        private int bodyPart = 0;
        /// <summary>
        /// part ID on the body where the bullet hit
        /// </summary>
        [EuphoriaDetail("part ID on the body where the bullet hit")]
        public int BodyPart
        {
            get { return bodyPart; }
            set
            {
                value = MathHelper.Clamp(value, 0, 21);
                SetArgument("bodyPart", value);
                bodyPart = value;
            }
        }

        private bool localHitPointInfo = true;
        /// <summary>
        /// if true then normal and hitPoint should be supplied in local coordinates of bodyPart.  If false then normal and hitPoint should be supplied in World coordinates
        /// </summary>
        [EuphoriaDetail("if true then normal and hitPoint should be supplied in local coordinates of bodyPart.  If false then normal and hitPoint should be supplied in World coordinates")]
        public bool LocalHitPointInfo
        {
            get { return localHitPointInfo; }
            set
            {

                SetArgument("localHitPointInfo", value);
                localHitPointInfo = value;
            }
        }

        private Vector3 normal = new Vector3(0f, 0f, -1f);
        /// <summary>
        /// Normal coming out of impact point on character.  Can be local or global depending on localHitPointInfo
        /// </summary>
        [EuphoriaDetail("Normal coming out of impact point on character.  Can be local or global depending on localHitPointInfo")]
        public Vector3 Normal
        {
            get { return normal; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -1.0f, 1.0f);
                value.Y = MathHelper.Clamp(value.Y, -1.0f, 1.0f);
                value.Z = MathHelper.Clamp(value.Z, -1.0f, 1.0f);
                SetArgument("normal", value);
                normal = value;
            }
        }

        private Vector3 hitPoint = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position of impact on character. Can be local or global depending on localHitPointInfo
        /// </summary>
        [EuphoriaDetail("position of impact on character. Can be local or global depending on localHitPointInfo")]
        public Vector3 HitPoint
        {
            get { return hitPoint; }
            set
            {

                SetArgument("hitPoint", value);
                hitPoint = value;
            }
        }

        private Vector3 bulletVel = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// bullet velocity in world coordinates
        /// </summary>
        [EuphoriaDetail("bullet velocity in world coordinates")]
        public Vector3 BulletVel
        {
            get { return bulletVel; }
            set
            {
                value.X = MathHelper.Clamp(value.X, -2000.0f, 2000.0f);
                value.Y = MathHelper.Clamp(value.Y, -2000.0f, 2000.0f);
                value.Z = MathHelper.Clamp(value.Z, -2000.0f, 2000.0f);
                SetArgument("bulletVel", value);
                bulletVel = value;
            }
        }


        public EuphoriaMessageShotNewBullet(bool startNow) : base("shotNewBullet", startNow)
        { }

        public new void Reset()
        {
            bodyPart = 0;
            localHitPointInfo = true;
            normal = new Vector3(0f, 0f, -1f);
            hitPoint = new Vector3(0f, 0f, 0f);
            bulletVel = new Vector3(0f, 0f, 0f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageShotSnap : EuphoriaMessage
    {
        private bool snap = false;
        /// <summary>
        /// Add a Snap to shot.
        /// </summary>
        [EuphoriaDetail("Add a Snap to shot.")]
        public bool Snap
        {
            get { return snap; }
            set
            {

                SetArgument("snap", value);
                snap = value;
            }
        }

        private float snapMag = 0.40f;
        /// <summary>
        /// The magnitude of the reaction
        /// </summary>
        [EuphoriaDetail("The magnitude of the reaction")]
        public float SnapMag
        {
            get { return snapMag; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 10.0f);
                SetArgument("snapMag", value);
                snapMag = value;
            }
        }

        private float snapMovingMult = 1.0f;
        /// <summary>
        /// movingMult*snapMag = The magnitude of the reaction if moving(comVelMag) faster than movingThresh
        /// </summary>
        [EuphoriaDetail("movingMult*snapMag = The magnitude of the reaction if moving(comVelMag) faster than movingThresh")]
        public float SnapMovingMult
        {
            get { return snapMovingMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("snapMovingMult", value);
                snapMovingMult = value;
            }
        }

        private float snapBalancingMult = 1.0f;
        /// <summary>
        /// balancingMult*snapMag = The magnitude of the reaction if balancing = (not lying on the floor/ not upper body not collided) and not airborne
        /// </summary>
        [EuphoriaDetail("balancingMult*snapMag = The magnitude of the reaction if balancing = (not lying on the floor/ not upper body not collided) and not airborne")]
        public float SnapBalancingMult
        {
            get { return snapBalancingMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("snapBalancingMult", value);
                snapBalancingMult = value;
            }
        }

        private float snapAirborneMult = 1.0f;
        /// <summary>
        /// airborneMult*snapMag = The magnitude of the reaction if airborne
        /// </summary>
        [EuphoriaDetail("airborneMult*snapMag = The magnitude of the reaction if airborne")]
        public float SnapAirborneMult
        {
            get { return snapAirborneMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("snapAirborneMult", value);
                snapAirborneMult = value;
            }
        }

        private float snapMovingThresh = 1.0f;
        /// <summary>
        /// If moving(comVelMag) faster than movingThresh then mvingMult applied to stunMag
        /// </summary>
        [EuphoriaDetail("If moving(comVelMag) faster than movingThresh then mvingMult applied to stunMag")]
        public float SnapMovingThresh
        {
            get { return snapMovingThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("snapMovingThresh", value);
                snapMovingThresh = value;
            }
        }

        private float snapDirectionRandomness = 0.30f;
        /// <summary>
        /// The character snaps in a prescribed way (decided by bullet direction) - Higher the value the more random this direction is.
        /// </summary>
        [EuphoriaDetail("The character snaps in a prescribed way (decided by bullet direction) - Higher the value the more random this direction is.")]
        public float SnapDirectionRandomness
        {
            get { return snapDirectionRandomness; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("snapDirectionRandomness", value);
                snapDirectionRandomness = value;
            }
        }

        private bool snapLeftArm = false;
        /// <summary>
        /// snap the leftArm.
        /// </summary>
        [EuphoriaDetail("snap the leftArm.")]
        public bool SnapLeftArm
        {
            get { return snapLeftArm; }
            set
            {

                SetArgument("snapLeftArm", value);
                snapLeftArm = value;
            }
        }

        private bool snapRightArm = false;
        /// <summary>
        /// snap the rightArm.
        /// </summary>
        [EuphoriaDetail("snap the rightArm.")]
        public bool SnapRightArm
        {
            get { return snapRightArm; }
            set
            {

                SetArgument("snapRightArm", value);
                snapRightArm = value;
            }
        }

        private bool snapLeftLeg = false;
        /// <summary>
        /// snap the leftLeg.
        /// </summary>
        [EuphoriaDetail("snap the leftLeg.")]
        public bool SnapLeftLeg
        {
            get { return snapLeftLeg; }
            set
            {

                SetArgument("snapLeftLeg", value);
                snapLeftLeg = value;
            }
        }

        private bool snapRightLeg = false;
        /// <summary>
        /// snap the rightLeg.
        /// </summary>
        [EuphoriaDetail("snap the rightLeg.")]
        public bool SnapRightLeg
        {
            get { return snapRightLeg; }
            set
            {

                SetArgument("snapRightLeg", value);
                snapRightLeg = value;
            }
        }

        private bool snapSpine = true;
        /// <summary>
        /// snap the spine.
        /// </summary>
        [EuphoriaDetail("snap the spine.")]
        public bool SnapSpine
        {
            get { return snapSpine; }
            set
            {

                SetArgument("snapSpine", value);
                snapSpine = value;
            }
        }

        private bool snapNeck = true;
        /// <summary>
        /// snap the neck.
        /// </summary>
        [EuphoriaDetail("snap the neck.")]
        public bool SnapNeck
        {
            get { return snapNeck; }
            set
            {

                SetArgument("snapNeck", value);
                snapNeck = value;
            }
        }

        private bool snapPhasedLegs = true;
        /// <summary>
        /// Legs are either in phase with each other or not
        /// </summary>
        [EuphoriaDetail("Legs are either in phase with each other or not")]
        public bool SnapPhasedLegs
        {
            get { return snapPhasedLegs; }
            set
            {

                SetArgument("snapPhasedLegs", value);
                snapPhasedLegs = value;
            }
        }

        private int snapHipType = 0;
        /// <summary>
        /// type of hip reaction 0=none, 1=side2side 2=steplike
        /// </summary>
        [EuphoriaDetail("type of hip reaction 0=none, 1=side2side 2=steplike")]
        public int SnapHipType
        {
            get { return snapHipType; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("snapHipType", value);
                snapHipType = value;
            }
        }

        private bool snapUseBulletDir = true;
        /// <summary>
        /// Legs are either in phase with each other or not
        /// </summary>
        [EuphoriaDetail("Legs are either in phase with each other or not")]
        public bool SnapUseBulletDir
        {
            get { return snapUseBulletDir; }
            set
            {

                SetArgument("snapUseBulletDir", value);
                snapUseBulletDir = value;
            }
        }

        private bool snapHitPart = false;
        /// <summary>
        /// Snap only around the wounded part//mmmmtodo check whether bodyPart doesn't have to be remembered for unSnap
        /// </summary>
        [EuphoriaDetail("Snap only around the wounded part//mmmmtodo check whether bodyPart doesn't have to be remembered for unSnap")]
        public bool SnapHitPart
        {
            get { return snapHitPart; }
            set
            {

                SetArgument("snapHitPart", value);
                snapHitPart = value;
            }
        }

        private float unSnapInterval = 0.010f;
        /// <summary>
        /// Interval before applying reverse snap
        /// </summary>
        [EuphoriaDetail("Interval before applying reverse snap")]
        public float UnSnapInterval
        {
            get { return unSnapInterval; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.0f);
                SetArgument("unSnapInterval", value);
                unSnapInterval = value;
            }
        }

        private float unSnapRatio = 0.70f;
        /// <summary>
        /// The magnitude of the reverse snap
        /// </summary>
        [EuphoriaDetail("The magnitude of the reverse snap")]
        public float UnSnapRatio
        {
            get { return unSnapRatio; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.0f);
                SetArgument("unSnapRatio", value);
                unSnapRatio = value;
            }
        }

        private bool snapUseTorques = true;
        /// <summary>
        /// use torques to make the snap otherwise use a change in the parts angular velocity
        /// </summary>
        [EuphoriaDetail("use torques to make the snap otherwise use a change in the parts angular velocity")]
        public bool SnapUseTorques
        {
            get { return snapUseTorques; }
            set
            {

                SetArgument("snapUseTorques", value);
                snapUseTorques = value;
            }
        }


        public EuphoriaMessageShotSnap(bool startNow) : base("shotSnap", startNow)
        { }

        public new void Reset()
        {
            snap = false;
            snapMag = 0.40f;
            snapMovingMult = 1.0f;
            snapBalancingMult = 1.0f;
            snapAirborneMult = 1.0f;
            snapMovingThresh = 1.0f;
            snapDirectionRandomness = 0.30f;
            snapLeftArm = false;
            snapRightArm = false;
            snapLeftLeg = false;
            snapRightLeg = false;
            snapSpine = true;
            snapNeck = true;
            snapPhasedLegs = true;
            snapHipType = 0;
            snapUseBulletDir = true;
            snapHitPart = false;
            unSnapInterval = 0.010f;
            unSnapRatio = 0.70f;
            snapUseTorques = true;
            base.Reset();
        }
    }


    /// <summary>
    /// shotShockSpin: configure the shockSpin effect in shot.  Spin/Lift the character using cheat torques/forces
    /// </summary>
    [EuphoriaDetail("shotShockSpin: configure the shockSpin effect in shot.  Spin/Lift the character using cheat torques/forces")]
    internal class EuphoriaMessageShotShockSpin : EuphoriaMessage
    {
        private bool addShockSpin = false;
        /// <summary>
        /// if enabled, add a short 'shock' of torque to the character's spine to exaggerate bullet impact
        /// </summary>
        [EuphoriaDetail("if enabled, add a short 'shock' of torque to the character's spine to exaggerate bullet impact")]
        public bool AddShockSpin
        {
            get { return addShockSpin; }
            set
            {

                SetArgument("addShockSpin", value);
                addShockSpin = value;
            }
        }

        private bool randomizeShockSpinDirection = false;
        /// <summary>
        /// for use with close-range shotgun blasts, or similar
        /// </summary>
        [EuphoriaDetail("for use with close-range shotgun blasts, or similar")]
        public bool RandomizeShockSpinDirection
        {
            get { return randomizeShockSpinDirection; }
            set
            {

                SetArgument("randomizeShockSpinDirection", value);
                randomizeShockSpinDirection = value;
            }
        }

        private bool alwaysAddShockSpin = false;
        /// <summary>
        /// if true, apply the shock spin no matter which body component was hit. otherwise only apply if the spine or clavicles get hit
        /// </summary>
        [EuphoriaDetail("if true, apply the shock spin no matter which body component was hit. otherwise only apply if the spine or clavicles get hit")]
        public bool AlwaysAddShockSpin
        {
            get { return alwaysAddShockSpin; }
            set
            {

                SetArgument("alwaysAddShockSpin", value);
                alwaysAddShockSpin = value;
            }
        }

        private float shockSpinMin = 50.0f;
        /// <summary>
        /// minimum amount of torque to add if using shock-spin feature
        /// </summary>
        [EuphoriaDetail("minimum amount of torque to add if using shock-spin feature")]
        public float ShockSpinMin
        {
            get { return shockSpinMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1000.0f);
                SetArgument("shockSpinMin", value);
                shockSpinMin = value;
            }
        }

        private float shockSpinMax = 90.0f;
        /// <summary>
        /// maxiumum amount of torque to add if using shock-spin feature
        /// </summary>
        [EuphoriaDetail("maxiumum amount of torque to add if using shock-spin feature")]
        public float ShockSpinMax
        {
            get { return shockSpinMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1000.0f);
                SetArgument("shockSpinMax", value);
                shockSpinMax = value;
            }
        }

        private float shockSpinLiftForceMult = 0.0f;
        /// <summary>
        /// if greater than 0, apply a force to lift the character up while the torque is applied, trying to produce a dramatic spun/twist shotgun-to-the-chest effect. this is a scale of the torque applied, so 8.0 or so would give a reasonable amount of lift
        /// </summary>
        [EuphoriaDetail("if greater than 0, apply a force to lift the character up while the torque is applied, trying to produce a dramatic spun/twist shotgun-to-the-chest effect. this is a scale of the torque applied, so 8.0 or so would give a reasonable amount of lift")]
        public float ShockSpinLiftForceMult
        {
            get { return shockSpinLiftForceMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("shockSpinLiftForceMult", value);
                shockSpinLiftForceMult = value;
            }
        }

        private float shockSpinDecayMult = 4.0f;
        /// <summary>
        /// multiplier used when decaying torque spin over time
        /// </summary>
        [EuphoriaDetail("multiplier used when decaying torque spin over time")]
        public float ShockSpinDecayMult
        {
            get { return shockSpinDecayMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("shockSpinDecayMult", value);
                shockSpinDecayMult = value;
            }
        }

        private float shockSpinScalePerComponent = 0.5f;
        /// <summary>
        /// torque applied is scaled by this amount across the spine components - spine2 recieving the full amount, then 3 and 1 and finally 0. each time, this value is used to scale it down. 0.5 means half the torque each time.
        /// </summary>
        [EuphoriaDetail("torque applied is scaled by this amount across the spine components - spine2 recieving the full amount, then 3 and 1 and finally 0. each time, this value is used to scale it down. 0.5 means half the torque each time.")]
        public float ShockSpinScalePerComponent
        {
            get { return shockSpinScalePerComponent; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("shockSpinScalePerComponent", value);
                shockSpinScalePerComponent = value;
            }
        }

        private float shockSpinMaxTwistVel = -1.0f;
        /// <summary>
        /// shock spin ends when twist velocity is greater than this value (try 6.0).  If set to -1 does not stop
        /// </summary>
        [EuphoriaDetail("shock spin ends when twist velocity is greater than this value (try 6.0).  If set to -1 does not stop")]
        public float ShockSpinMaxTwistVel
        {
            get { return shockSpinMaxTwistVel; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 200.0f);
                SetArgument("shockSpinMaxTwistVel", value);
                shockSpinMaxTwistVel = value;
            }
        }

        private bool shockSpinScaleByLeverArm = true;
        /// <summary>
        /// shock spin scales by lever arm of bullet i.e. bullet impact point to centre line
        /// </summary>
        [EuphoriaDetail("shock spin scales by lever arm of bullet i.e. bullet impact point to centre line")]
        public bool ShockSpinScaleByLeverArm
        {
            get { return shockSpinScaleByLeverArm; }
            set
            {

                SetArgument("shockSpinScaleByLeverArm", value);
                shockSpinScaleByLeverArm = value;
            }
        }

        private float shockSpinAirMult = 1.0f;
        /// <summary>
        /// shockSpin's torque is multipied by this value when both the character's feet are not in contact
        /// </summary>
        [EuphoriaDetail("shockSpin's torque is multipied by this value when both the character's feet are not in contact")]
        public float ShockSpinAirMult
        {
            get { return shockSpinAirMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("shockSpinAirMult", value);
                shockSpinAirMult = value;
            }
        }

        private float shockSpin1FootMult = 1.0f;
        /// <summary>
        /// shockSpin's torque is multipied by this value when the one of the character's feet are not in contact
        /// </summary>
        [EuphoriaDetail("shockSpin's torque is multipied by this value when the one of the character's feet are not in contact")]
        public float ShockSpin1FootMult
        {
            get { return shockSpin1FootMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("shockSpin1FootMult", value);
                shockSpin1FootMult = value;
            }
        }

        private float shockSpinFootGripMult = 1.0f;
        /// <summary>
        /// shockSpin scales the torques applied to the feet by footSlipCompensation
        /// </summary>
        [EuphoriaDetail("shockSpin scales the torques applied to the feet by footSlipCompensation")]
        public float ShockSpinFootGripMult
        {
            get { return shockSpinFootGripMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("shockSpinFootGripMult", value);
                shockSpinFootGripMult = value;
            }
        }

        private float bracedSideSpinMult = 1.0f;
        /// <summary>
        /// If shot on a side with a forward foot and both feet are on the ground and balanced, increase the shockspin to compensate for the balancer naturally resisting spin to that side
        /// </summary>
        [EuphoriaDetail("If shot on a side with a forward foot and both feet are on the ground and balanced, increase the shockspin to compensate for the balancer naturally resisting spin to that side")]
        public float BracedSideSpinMult
        {
            get { return bracedSideSpinMult; }
            set
            {
                value = MathHelper.Clamp(value, 1.0f, 5.0f);
                SetArgument("bracedSideSpinMult", value);
                bracedSideSpinMult = value;
            }
        }


        public EuphoriaMessageShotShockSpin(bool startNow) : base("shotShockSpin", startNow)
        { }

        public new void Reset()
        {
            addShockSpin = false;
            randomizeShockSpinDirection = false;
            alwaysAddShockSpin = false;
            shockSpinMin = 50.0f;
            shockSpinMax = 90.0f;
            shockSpinLiftForceMult = 0.0f;
            shockSpinDecayMult = 4.0f;
            shockSpinScalePerComponent = 0.5f;
            shockSpinMaxTwistVel = -1.0f;
            shockSpinScaleByLeverArm = true;
            shockSpinAirMult = 1.0f;
            shockSpin1FootMult = 1.0f;
            shockSpinFootGripMult = 1.0f;
            bracedSideSpinMult = 1.0f;
            base.Reset();
        }
    }


    /// <summary>
    /// shotFallToKnees:  configure the fall to knees shot.
    /// </summary>
    [EuphoriaDetail("shotFallToKnees:  configure the fall to knees shot.")]
    internal class EuphoriaMessageShotFallToKnees : EuphoriaMessage
    {
        private bool fallToKnees = false;
        /// <summary>
        /// Type of reaction
        /// </summary>
        [EuphoriaDetail("Type of reaction")]
        public bool FallToKnees
        {
            get { return fallToKnees; }
            set
            {

                SetArgument("fallToKnees", value);
                fallToKnees = value;
            }
        }

        private bool ftkAlwaysChangeFall = false;
        /// <summary>
        /// Always change fall behaviour.  If false only change when falling forward
        /// </summary>
        [EuphoriaDetail("Always change fall behaviour.  If false only change when falling forward")]
        public bool FtkAlwaysChangeFall
        {
            get { return ftkAlwaysChangeFall; }
            set
            {

                SetArgument("ftkAlwaysChangeFall", value);
                ftkAlwaysChangeFall = value;
            }
        }

        private float ftkBalanceTime = 0.70f;
        /// <summary>
        /// How long the balancer runs for before fallToKnees starts
        /// </summary>
        [EuphoriaDetail("How long the balancer runs for before fallToKnees starts")]
        public float FtkBalanceTime
        {
            get { return ftkBalanceTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("ftkBalanceTime", value);
                ftkBalanceTime = value;
            }
        }

        private float ftkHelperForce = 200.0f;
        /// <summary>
        /// Hip helper force magnitude - to help character lean over balance point of line between toes
        /// </summary>
        [EuphoriaDetail("Hip helper force magnitude - to help character lean over balance point of line between toes")]
        public float FtkHelperForce
        {
            get { return ftkHelperForce; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2000.00f);
                SetArgument("ftkHelperForce", value);
                ftkHelperForce = value;
            }
        }

        private bool ftkHelperForceOnSpine = true;
        /// <summary>
        /// Helper force applied to spine3 aswell
        /// </summary>
        [EuphoriaDetail("Helper force applied to spine3 aswell")]
        public bool FtkHelperForceOnSpine
        {
            get { return ftkHelperForceOnSpine; }
            set
            {

                SetArgument("ftkHelperForceOnSpine", value);
                ftkHelperForceOnSpine = value;
            }
        }

        private float ftkLeanHelp = 0.050f;
        /// <summary>
        /// Help balancer lean amount - to help character lean over balance point of line between toes.  Half of this is also applied as hipLean
        /// </summary>
        [EuphoriaDetail("Help balancer lean amount - to help character lean over balance point of line between toes.  Half of this is also applied as hipLean")]
        public float FtkLeanHelp
        {
            get { return ftkLeanHelp; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 0.30f);
                SetArgument("ftkLeanHelp", value);
                ftkLeanHelp = value;
            }
        }

        private float ftkSpineBend = -0.00f;
        /// <summary>
        /// Bend applied to spine when falling from knees. (+ve forward - try -0.1) (only if rds called)
        /// </summary>
        [EuphoriaDetail("Bend applied to spine when falling from knees. (+ve forward - try -0.1) (only if rds called)")]
        public float FtkSpineBend
        {
            get { return ftkSpineBend; }
            set
            {
                value = MathHelper.Clamp(value, -0.20f, 0.30f);
                SetArgument("ftkSpineBend", value);
                ftkSpineBend = value;
            }
        }

        private bool ftkStiffSpine = false;
        /// <summary>
        /// Stiffen spine when falling from knees (only if rds called)
        /// </summary>
        [EuphoriaDetail("Stiffen spine when falling from knees (only if rds called)")]
        public bool FtkStiffSpine
        {
            get { return ftkStiffSpine; }
            set
            {

                SetArgument("ftkStiffSpine", value);
                ftkStiffSpine = value;
            }
        }

        private float ftkImpactLooseness = 0.50f;
        /// <summary>
        /// Looseness (muscleStiffness = 1.01f - m_parameters.ftkImpactLooseness) applied to upperBody on knee impacts
        /// </summary>
        [EuphoriaDetail("Looseness (muscleStiffness = 1.01f - m_parameters.ftkImpactLooseness) applied to upperBody on knee impacts")]
        public float FtkImpactLooseness
        {
            get { return ftkImpactLooseness; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.0f);
                SetArgument("ftkImpactLooseness", value);
                ftkImpactLooseness = value;
            }
        }

        private float ftkImpactLoosenessTime = 0.20f;
        /// <summary>
        /// Time that looseness is applied after knee impacts
        /// </summary>
        [EuphoriaDetail("Time that looseness is applied after knee impacts")]
        public float FtkImpactLoosenessTime
        {
            get { return ftkImpactLoosenessTime; }
            set
            {
                value = MathHelper.Clamp(value, -0.10f, 1.00f);
                SetArgument("ftkImpactLoosenessTime", value);
                ftkImpactLoosenessTime = value;
            }
        }

        private float ftkBendRate = 0.70f;
        /// <summary>
        /// Rate at which the legs are bent to go from standing to on knees
        /// </summary>
        [EuphoriaDetail("Rate at which the legs are bent to go from standing to on knees")]
        public float FtkBendRate
        {
            get { return ftkBendRate; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 4.00f);
                SetArgument("ftkBendRate", value);
                ftkBendRate = value;
            }
        }

        private float ftkHipBlend = 0.30f;
        /// <summary>
        /// Blend from current hip to balancing on knees hip angle
        /// </summary>
        [EuphoriaDetail("Blend from current hip to balancing on knees hip angle")]
        public float FtkHipBlend
        {
            get { return ftkHipBlend; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("ftkHipBlend", value);
                ftkHipBlend = value;
            }
        }

        private float ftkLungeProb = 0.00f;
        /// <summary>
        /// Probability that a lunge reaction will be allowed
        /// </summary>
        [EuphoriaDetail("Probability that a lunge reaction will be allowed")]
        public float FtkLungeProb
        {
            get { return ftkLungeProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("ftkLungeProb", value);
                ftkLungeProb = value;
            }
        }

        private bool ftkKneeSpin = false;
        /// <summary>
        /// When on knees allow some spinning of the character.  If false then the balancers' footSlipCompensation remains on and tends to keep the character facing the same way as when it was balancing.
        /// </summary>
        [EuphoriaDetail("When on knees allow some spinning of the character.  If false then the balancers' footSlipCompensation remains on and tends to keep the character facing the same way as when it was balancing.")]
        public bool FtkKneeSpin
        {
            get { return ftkKneeSpin; }
            set
            {

                SetArgument("ftkKneeSpin", value);
                ftkKneeSpin = value;
            }
        }

        private float ftkFricMult = 1.00f;
        /// <summary>
        /// Multiplier on the reduction of friction for the feet based on angle away from horizontal - helps the character fall to knees quicker
        /// </summary>
        [EuphoriaDetail("Multiplier on the reduction of friction for the feet based on angle away from horizontal - helps the character fall to knees quicker")]
        public float FtkFricMult
        {
            get { return ftkFricMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("ftkFricMult", value);
                ftkFricMult = value;
            }
        }

        private float ftkHipAngleFall = 0.50f;
        /// <summary>
        /// Apply this hip angle when the character starts to fall backwards when on knees
        /// </summary>
        [EuphoriaDetail("Apply this hip angle when the character starts to fall backwards when on knees")]
        public float FtkHipAngleFall
        {
            get { return ftkHipAngleFall; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("ftkHipAngleFall", value);
                ftkHipAngleFall = value;
            }
        }

        private float ftkPitchForwards = 0.10f;
        /// <summary>
        /// Hip pitch applied (+ve forward, -ve backwards) if character is falling forwards on way down to it's knees
        /// </summary>
        [EuphoriaDetail("Hip pitch applied (+ve forward, -ve backwards) if character is falling forwards on way down to it's knees")]
        public float FtkPitchForwards
        {
            get { return ftkPitchForwards; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 0.50f);
                SetArgument("ftkPitchForwards", value);
                ftkPitchForwards = value;
            }
        }

        private float ftkPitchBackwards = 0.10f;
        /// <summary>
        /// Hip pitch applied (+ve forward, -ve backwards) if character is falling backwards on way down to it's knees
        /// </summary>
        [EuphoriaDetail("Hip pitch applied (+ve forward, -ve backwards) if character is falling backwards on way down to it's knees")]
        public float FtkPitchBackwards
        {
            get { return ftkPitchBackwards; }
            set
            {
                value = MathHelper.Clamp(value, -0.50f, 0.50f);
                SetArgument("ftkPitchBackwards", value);
                ftkPitchBackwards = value;
            }
        }

        private float ftkFallBelowStab = 0.50f;
        /// <summary>
        /// Balancer instability below which the character starts to bend legs even if it isn't going to fall on to it's knees (i.e. if going backwards). 0.3 almost ensures a fall to knees but means the character will keep stepping backward until it slows down enough.
        /// </summary>
        [EuphoriaDetail("Balancer instability below which the character starts to bend legs even if it isn't going to fall on to it's knees (i.e. if going backwards). 0.3 almost ensures a fall to knees but means the character will keep stepping backward until it slows down enough.")]
        public float FtkFallBelowStab
        {
            get { return ftkFallBelowStab; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 15.00f);
                SetArgument("ftkFallBelowStab", value);
                ftkFallBelowStab = value;
            }
        }

        private float ftkBalanceAbortThreshold = 2.00f;
        /// <summary>
        /// when the character gives up and goes into a fall
        /// </summary>
        [EuphoriaDetail("when the character gives up and goes into a fall")]
        public float FtkBalanceAbortThreshold
        {
            get { return ftkBalanceAbortThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 4.00f);
                SetArgument("ftkBalanceAbortThreshold", value);
                ftkBalanceAbortThreshold = value;
            }
        }

        private int ftkOnKneesArmType = 2;
        /// <summary>
        /// Type of arm response when on knees falling forward 0=useFallArms (from RollDownstairs or catchFall), 1= armsIn, 2=armsOut
        /// </summary>
        [EuphoriaDetail("Type of arm response when on knees falling forward 0=useFallArms (from RollDownstairs or catchFall), 1= armsIn, 2=armsOut")]
        public int FtkOnKneesArmType
        {
            get { return ftkOnKneesArmType; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("ftkOnKneesArmType", value);
                ftkOnKneesArmType = value;
            }
        }

        private float ftkReleaseReachForWound = -1.00f;
        /// <summary>
        /// Release the reachForWound this amount of time after the knees have hit.  If  LT  0.0 then keep reaching for wound regardless of fall/onground state.
        /// </summary>
        [EuphoriaDetail("Release the reachForWound this amount of time after the knees have hit.  If  LT  0.0 then keep reaching for wound regardless of fall/onground state.")]
        public float FtkReleaseReachForWound
        {
            get { return ftkReleaseReachForWound; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 5.00f);
                SetArgument("ftkReleaseReachForWound", value);
                ftkReleaseReachForWound = value;
            }
        }

        private bool ftkReachForWound = true;
        /// <summary>
        /// true = Keep reaching for wound regardless of fall/onground state.  false = respect the shotConfigureArms params: reachFalling, reachFallingWithOneHand, reachOnFloor
        /// </summary>
        [EuphoriaDetail("true = Keep reaching for wound regardless of fall/onground state.  false = respect the shotConfigureArms params: reachFalling, reachFallingWithOneHand, reachOnFloor")]
        public bool FtkReachForWound
        {
            get { return ftkReachForWound; }
            set
            {

                SetArgument("ftkReachForWound", value);
                ftkReachForWound = value;
            }
        }

        private bool ftkReleasePointGun = false;
        /// <summary>
        /// Override the pointGun when knees hit
        /// </summary>
        [EuphoriaDetail("Override the pointGun when knees hit")]
        public bool FtkReleasePointGun
        {
            get { return ftkReleasePointGun; }
            set
            {

                SetArgument("ftkReleasePointGun", value);
                ftkReleasePointGun = value;
            }
        }

        private bool ftkFailMustCollide = true;
        /// <summary>
        /// The upper body of the character must be colliding and other failure conditions met to fail
        /// </summary>
        [EuphoriaDetail("The upper body of the character must be colliding and other failure conditions met to fail")]
        public bool FtkFailMustCollide
        {
            get { return ftkFailMustCollide; }
            set
            {

                SetArgument("ftkFailMustCollide", value);
                ftkFailMustCollide = value;
            }
        }


        public EuphoriaMessageShotFallToKnees(bool startNow) : base("shotFallToKnees", startNow)
        { }

        public new void Reset()
        {
            fallToKnees = false;
            ftkAlwaysChangeFall = false;
            ftkBalanceTime = 0.70f;
            ftkHelperForce = 200.0f;
            ftkHelperForceOnSpine = true;
            ftkLeanHelp = 0.050f;
            ftkSpineBend = -0.00f;
            ftkStiffSpine = false;
            ftkImpactLooseness = 0.50f;
            ftkImpactLoosenessTime = 0.20f;
            ftkBendRate = 0.70f;
            ftkHipBlend = 0.30f;
            ftkLungeProb = 0.00f;
            ftkKneeSpin = false;
            ftkFricMult = 1.00f;
            ftkHipAngleFall = 0.50f;
            ftkPitchForwards = 0.10f;
            ftkPitchBackwards = 0.10f;
            ftkFallBelowStab = 0.50f;
            ftkBalanceAbortThreshold = 2.00f;
            ftkOnKneesArmType = 2;
            ftkReleaseReachForWound = -1.00f;
            ftkReachForWound = true;
            ftkReleasePointGun = false;
            ftkFailMustCollide = true;
            base.Reset();
        }
    }


    /// <summary>
    /// shotFromBehind:  configure the shot from behind reaction
    /// </summary>
    [EuphoriaDetail("shotFromBehind:  configure the shot from behind reaction")]
    internal class EuphoriaMessageShotFromBehind : EuphoriaMessage
    {
        private bool shotFromBehind = false;
        /// <summary>
        /// Type of reaction
        /// </summary>
        [EuphoriaDetail("Type of reaction")]
        public bool ShotFromBehind
        {
            get { return shotFromBehind; }
            set
            {

                SetArgument("shotFromBehind", value);
                shotFromBehind = value;
            }
        }

        private float sfbSpineAmount = 4.00f;
        /// <summary>
        /// SpineBend.
        /// </summary>
        [EuphoriaDetail("SpineBend.")]
        public float SfbSpineAmount
        {
            get { return sfbSpineAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sfbSpineAmount", value);
                sfbSpineAmount = value;
            }
        }

        private float sfbNeckAmount = 1.00f;
        /// <summary>
        /// Neck Bend.
        /// </summary>
        [EuphoriaDetail("Neck Bend.")]
        public float SfbNeckAmount
        {
            get { return sfbNeckAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sfbNeckAmount", value);
                sfbNeckAmount = value;
            }
        }

        private float sfbHipAmount = 1.00f;
        /// <summary>
        /// hip Pitch
        /// </summary>
        [EuphoriaDetail("hip Pitch")]
        public float SfbHipAmount
        {
            get { return sfbHipAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sfbHipAmount", value);
                sfbHipAmount = value;
            }
        }

        private float sfbKneeAmount = 0.050f;
        /// <summary>
        /// knee bend
        /// </summary>
        [EuphoriaDetail("knee bend")]
        public float SfbKneeAmount
        {
            get { return sfbKneeAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("sfbKneeAmount", value);
                sfbKneeAmount = value;
            }
        }

        private float sfbPeriod = 0.70f;
        /// <summary>
        /// shotFromBehind reaction period after being shot
        /// </summary>
        [EuphoriaDetail("shotFromBehind reaction period after being shot")]
        public float SfbPeriod
        {
            get { return sfbPeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 10.00f);
                SetArgument("sfbPeriod", value);
                sfbPeriod = value;
            }
        }

        private float sfbForceBalancePeriod = 0.30f;
        /// <summary>
        /// amount of time not taking a step
        /// </summary>
        [EuphoriaDetail("amount of time not taking a step")]
        public float SfbForceBalancePeriod
        {
            get { return sfbForceBalancePeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sfbForceBalancePeriod", value);
                sfbForceBalancePeriod = value;
            }
        }

        private float sfbArmsOnset = 0.00f;
        /// <summary>
        /// amount of time before applying spread out arms pose
        /// </summary>
        [EuphoriaDetail("amount of time before applying spread out arms pose")]
        public float SfbArmsOnset
        {
            get { return sfbArmsOnset; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sfbArmsOnset", value);
                sfbArmsOnset = value;
            }
        }

        private float sfbKneesOnset = 0.00f;
        /// <summary>
        /// amount of time before bending knees a bit
        /// </summary>
        [EuphoriaDetail("amount of time before bending knees a bit")]
        public float SfbKneesOnset
        {
            get { return sfbKneesOnset; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sfbKneesOnset", value);
                sfbKneesOnset = value;
            }
        }

        private float sfbNoiseGain = 0.00f;
        /// <summary>
        /// Controls additional independent randomized bending of left/right elbows
        /// </summary>
        [EuphoriaDetail("Controls additional independent randomized bending of left/right elbows")]
        public float SfbNoiseGain
        {
            get { return sfbNoiseGain; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("sfbNoiseGain", value);
                sfbNoiseGain = value;
            }
        }

        private int sfbIgnoreFail = 0;
        /// <summary>
        /// 0=balancer fails as normal,  1= ignore backArchedBack and leanedTooFarBack balancer failures,  2= ignore backArchedBack balancer failure only,  3= ignore leanedTooFarBack balancer failure only
        /// </summary>
        [EuphoriaDetail("0=balancer fails as normal,  1= ignore backArchedBack and leanedTooFarBack balancer failures,  2= ignore backArchedBack balancer failure only,  3= ignore leanedTooFarBack balancer failure only")]
        public int SfbIgnoreFail
        {
            get { return sfbIgnoreFail; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("sfbIgnoreFail", value);
                sfbIgnoreFail = value;
            }
        }


        public EuphoriaMessageShotFromBehind(bool startNow) : base("shotFromBehind", startNow)
        { }

        public new void Reset()
        {
            shotFromBehind = false;
            sfbSpineAmount = 4.00f;
            sfbNeckAmount = 1.00f;
            sfbHipAmount = 1.00f;
            sfbKneeAmount = 0.050f;
            sfbPeriod = 0.70f;
            sfbForceBalancePeriod = 0.30f;
            sfbArmsOnset = 0.00f;
            sfbKneesOnset = 0.00f;
            sfbNoiseGain = 0.00f;
            sfbIgnoreFail = 0;
            base.Reset();
        }
    }


    /// <summary>
    /// shotInGuts:  configure the shot in guts reaction
    /// </summary>
    [EuphoriaDetail("shotInGuts:  configure the shot in guts reaction")]
    internal class EuphoriaMessageShotInGuts : EuphoriaMessage
    {
        private bool shotInGuts = false;
        /// <summary>
        /// Type of reaction
        /// </summary>
        [EuphoriaDetail("Type of reaction")]
        public bool ShotInGuts
        {
            get { return shotInGuts; }
            set
            {

                SetArgument("shotInGuts", value);
                shotInGuts = value;
            }
        }

        private float sigSpineAmount = 2.00f;
        /// <summary>
        /// SpineBend.
        /// </summary>
        [EuphoriaDetail("SpineBend.")]
        public float SigSpineAmount
        {
            get { return sigSpineAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sigSpineAmount", value);
                sigSpineAmount = value;
            }
        }

        private float sigNeckAmount = 1.00f;
        /// <summary>
        /// Neck Bend.
        /// </summary>
        [EuphoriaDetail("Neck Bend.")]
        public float SigNeckAmount
        {
            get { return sigNeckAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sigNeckAmount", value);
                sigNeckAmount = value;
            }
        }

        private float sigHipAmount = 1.00f;
        /// <summary>
        /// hip Pitch
        /// </summary>
        [EuphoriaDetail("hip Pitch")]
        public float SigHipAmount
        {
            get { return sigHipAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sigHipAmount", value);
                sigHipAmount = value;
            }
        }

        private float sigKneeAmount = 0.050f;
        /// <summary>
        /// knee bend
        /// </summary>
        [EuphoriaDetail("knee bend")]
        public float SigKneeAmount
        {
            get { return sigKneeAmount; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("sigKneeAmount", value);
                sigKneeAmount = value;
            }
        }

        private float sigPeriod = 2.00f;
        /// <summary>
        /// active time after being shot
        /// </summary>
        [EuphoriaDetail("active time after being shot")]
        public float SigPeriod
        {
            get { return sigPeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 10.00f);
                SetArgument("sigPeriod", value);
                sigPeriod = value;
            }
        }

        private float sigForceBalancePeriod = 0.00f;
        /// <summary>
        /// amount of time not taking a step
        /// </summary>
        [EuphoriaDetail("amount of time not taking a step")]
        public float SigForceBalancePeriod
        {
            get { return sigForceBalancePeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sigForceBalancePeriod", value);
                sigForceBalancePeriod = value;
            }
        }

        private float sigKneesOnset = 0.00f;
        /// <summary>
        /// amount of time not taking a step
        /// </summary>
        [EuphoriaDetail("amount of time not taking a step")]
        public float SigKneesOnset
        {
            get { return sigKneesOnset; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("sigKneesOnset", value);
                sigKneesOnset = value;
            }
        }


        public EuphoriaMessageShotInGuts(bool startNow) : base("shotInGuts", startNow)
        { }

        public new void Reset()
        {
            shotInGuts = false;
            sigSpineAmount = 2.00f;
            sigNeckAmount = 1.00f;
            sigHipAmount = 1.00f;
            sigKneeAmount = 0.050f;
            sigPeriod = 2.00f;
            sigForceBalancePeriod = 0.00f;
            sigKneesOnset = 0.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageShotHeadLook : EuphoriaMessage
    {
        private bool useHeadLook = false;
        /// <summary>
        /// Use headLook.  Default: looks at provided target or if this is zero -  looks forward or in velocity direction. If reachForWound is enabled, switches between looking at the wound and at the default target.
        /// </summary>
        [EuphoriaDetail("Use headLook.  Default: looks at provided target or if this is zero -  looks forward or in velocity direction. If reachForWound is enabled, switches between looking at the wound and at the default target.")]
        public bool UseHeadLook
        {
            get { return useHeadLook; }
            set
            {

                SetArgument("useHeadLook", value);
                useHeadLook = value;
            }
        }

        private Vector3 headLook = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position to look at with headlook flag
        /// </summary>
        [EuphoriaDetail("position to look at with headlook flag")]
        public Vector3 HeadLook
        {
            get { return headLook; }
            set
            {

                SetArgument("headLook", value);
                headLook = value;
            }
        }

        private float headLookAtWoundMinTimer = 0.250f;
        /// <summary>
        /// Min time to look at wound
        /// </summary>
        [EuphoriaDetail("Min time to look at wound")]
        public float HeadLookAtWoundMinTimer
        {
            get { return headLookAtWoundMinTimer; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("headLookAtWoundMinTimer", value);
                headLookAtWoundMinTimer = value;
            }
        }

        private float headLookAtWoundMaxTimer = 0.80f;
        /// <summary>
        /// Max time to look at wound
        /// </summary>
        [EuphoriaDetail("Max time to look at wound")]
        public float HeadLookAtWoundMaxTimer
        {
            get { return headLookAtWoundMaxTimer; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("headLookAtWoundMaxTimer", value);
                headLookAtWoundMaxTimer = value;
            }
        }

        private float headLookAtHeadPosMaxTimer = 1.70f;
        /// <summary>
        /// Min time to look headLook or if zero - forward or in velocity direction
        /// </summary>
        [EuphoriaDetail("Min time to look headLook or if zero - forward or in velocity direction")]
        public float HeadLookAtHeadPosMaxTimer
        {
            get { return headLookAtHeadPosMaxTimer; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("headLookAtHeadPosMaxTimer", value);
                headLookAtHeadPosMaxTimer = value;
            }
        }

        private float headLookAtHeadPosMinTimer = 0.60f;
        /// <summary>
        /// Max time to look headLook or if zero - forward or in velocity direction
        /// </summary>
        [EuphoriaDetail("Max time to look headLook or if zero - forward or in velocity direction")]
        public float HeadLookAtHeadPosMinTimer
        {
            get { return headLookAtHeadPosMinTimer; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("headLookAtHeadPosMinTimer", value);
                headLookAtHeadPosMinTimer = value;
            }
        }


        public EuphoriaMessageShotHeadLook(bool startNow) : base("shotHeadLook", startNow)
        { }

        public new void Reset()
        {
            useHeadLook = false;
            headLook = new Vector3(0f, 0f, 0f);
            headLookAtWoundMinTimer = 0.250f;
            headLookAtWoundMaxTimer = 0.80f;
            headLookAtHeadPosMaxTimer = 1.70f;
            headLookAtHeadPosMinTimer = 0.60f;
            base.Reset();
        }
    }


    /// <summary>
    /// shotConfigureArms:  configure the arm reactions in shot
    /// </summary>
    [EuphoriaDetail("shotConfigureArms:  configure the arm reactions in shot")]
    internal class EuphoriaMessageShotConfigureArms : EuphoriaMessage
    {
        private bool brace = true;
        /// <summary>
        /// blind brace with arms if appropriate
        /// </summary>
        [EuphoriaDetail("blind brace with arms if appropriate")]
        public bool Brace
        {
            get { return brace; }
            set
            {

                SetArgument("brace", value);
                brace = value;
            }
        }

        private bool pointGun = false;
        /// <summary>
        /// Point gun if appropriate.
        /// </summary>
        [EuphoriaDetail("Point gun if appropriate.")]
        public bool PointGun
        {
            get { return pointGun; }
            set
            {

                SetArgument("pointGun", value);
                pointGun = value;
            }
        }

        private bool useArmsWindmill = true;
        /// <summary>
        /// armsWindmill if going backwards fast enough
        /// </summary>
        [EuphoriaDetail("armsWindmill if going backwards fast enough")]
        public bool UseArmsWindmill
        {
            get { return useArmsWindmill; }
            set
            {

                SetArgument("useArmsWindmill", value);
                useArmsWindmill = value;
            }
        }

        private int releaseWound = 1;
        /// <summary>
        /// release wound if going sideways/forward fast enough.  0 = don't. 1 = only if bracing. 2 = any default arm reaction
        /// </summary>
        [EuphoriaDetail("release wound if going sideways/forward fast enough.  0 = don't. 1 = only if bracing. 2 = any default arm reaction")]
        public int ReleaseWound
        {
            get { return releaseWound; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("releaseWound", value);
                releaseWound = value;
            }
        }

        private int reachFalling = 0;
        /// <summary>
        /// reachForWound when falling 0 = false, 1 = true, 2 = once per shot performance
        /// </summary>
        [EuphoriaDetail("reachForWound when falling 0 = false, 1 = true, 2 = once per shot performance")]
        public int ReachFalling
        {
            get { return reachFalling; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("reachFalling", value);
                reachFalling = value;
            }
        }

        private int reachFallingWithOneHand = 3;
        /// <summary>
        /// Force character to reach for wound with only one hand when falling or fallen.  0= allow 2 handed reach, 1= left only if 2 handed possible, 2= right only if 2 handed possible, 3 = one handed but automatic (allows switching of hands)
        /// </summary>
        [EuphoriaDetail("Force character to reach for wound with only one hand when falling or fallen.  0= allow 2 handed reach, 1= left only if 2 handed possible, 2= right only if 2 handed possible, 3 = one handed but automatic (allows switching of hands)")]
        public int ReachFallingWithOneHand
        {
            get { return reachFallingWithOneHand; }
            set
            {
                value = MathHelper.Clamp(value, 0, 3);
                SetArgument("reachFallingWithOneHand", value);
                reachFallingWithOneHand = value;
            }
        }

        private int reachOnFloor = 0;
        /// <summary>
        /// reachForWound when on floor - 0 = false, 1 = true, 2 = once per shot performance
        /// </summary>
        [EuphoriaDetail("reachForWound when on floor - 0 = false, 1 = true, 2 = once per shot performance")]
        public int ReachOnFloor
        {
            get { return reachOnFloor; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("reachOnFloor", value);
                reachOnFloor = value;
            }
        }

        private float alwaysReachTime = 0.30f;
        /// <summary>
        /// Inhibit arms brace for this amount of time after reachForWound has begun
        /// </summary>
        [EuphoriaDetail("Inhibit arms brace for this amount of time after reachForWound has begun")]
        public float AlwaysReachTime
        {
            get { return alwaysReachTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("alwaysReachTime", value);
                alwaysReachTime = value;
            }
        }

        private float aWSpeedMult = 1.0f;
        /// <summary>
        /// For armsWindmill, multiplier on character speed - increase of speed of circling is proportional to character speed (max speed of circliing increase = 1.5). eg. lowering the value increases the range of velocity that the 0-1.5 is applied over
        /// </summary>
        [EuphoriaDetail("For armsWindmill, multiplier on character speed - increase of speed of circling is proportional to character speed (max speed of circliing increase = 1.5). eg. lowering the value increases the range of velocity that the 0-1.5 is applied over")]
        public float AWSpeedMult
        {
            get { return aWSpeedMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("AWSpeedMult", value);
                AWSpeedMult = value;
            }
        }

        private float aWRadiusMult = 1.0f;
        /// <summary>
        /// For armsWindmill, multiplier on character speed - increase of radii is proportional to character speed (max radius increase = 0.45). eg. lowering the value increases the range of velocity that the 0-0.45 is applied over
        /// </summary>
        [EuphoriaDetail("For armsWindmill, multiplier on character speed - increase of radii is proportional to character speed (max radius increase = 0.45). eg. lowering the value increases the range of velocity that the 0-0.45 is applied over")]
        public float AWRadiusMult
        {
            get { return aWRadiusMult; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("AWRadiusMult", value);
                AWRadiusMult = value;
            }
        }

        private float aWStiffnessAdd = 4.0f;
        /// <summary>
        /// For armsWindmill, added arm stiffness ranges from 0 to AWStiffnessAdd
        /// </summary>
        [EuphoriaDetail("For armsWindmill, added arm stiffness ranges from 0 to AWStiffnessAdd")]
        public float AWStiffnessAdd
        {
            get { return aWStiffnessAdd; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("AWStiffnessAdd", value);
                AWStiffnessAdd = value;
            }
        }

        private int reachWithOneHand = 0;
        /// <summary>
        /// Force character to reach for wound with only one hand.  0= allow 2 handed reach, 1= left only if 2 handed possible, 2= right only if 2 handed possible
        /// </summary>
        [EuphoriaDetail("Force character to reach for wound with only one hand.  0= allow 2 handed reach, 1= left only if 2 handed possible, 2= right only if 2 handed possible")]
        public int ReachWithOneHand
        {
            get { return reachWithOneHand; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("reachWithOneHand", value);
                reachWithOneHand = value;
            }
        }

        private bool allowLeftPistolRFW = true;
        /// <summary>
        /// Allow character to reach for wound with left hand if holding a pistol.  It never will for a rifle. If pointGun is running this will only happen if the hand cannot point and pointGun:poseUnusedGunArm = false
        /// </summary>
        [EuphoriaDetail("Allow character to reach for wound with left hand if holding a pistol.  It never will for a rifle. If pointGun is running this will only happen if the hand cannot point and pointGun:poseUnusedGunArm = false")]
        public bool AllowLeftPistolRFW
        {
            get { return allowLeftPistolRFW; }
            set
            {

                SetArgument("allowLeftPistolRFW", value);
                allowLeftPistolRFW = value;
            }
        }

        private bool allowRightPistolRFW = false;
        /// <summary>
        /// Allow character to reach for wound with right hand if holding a pistol. It never will for a rifle. If pointGun is running this will only happen if the hand cannot point and pointGun:poseUnusedGunArm = false
        /// </summary>
        [EuphoriaDetail("Allow character to reach for wound with right hand if holding a pistol. It never will for a rifle. If pointGun is running this will only happen if the hand cannot point and pointGun:poseUnusedGunArm = false")]
        public bool AllowRightPistolRFW
        {
            get { return allowRightPistolRFW; }
            set
            {

                SetArgument("allowRightPistolRFW", value);
                allowRightPistolRFW = value;
            }
        }

        private bool rfwWithPistol = false;
        /// <summary>
        /// Override pointGun and reachForWound if desired if holding a pistol.  It never will for a rifle
        /// </summary>
        [EuphoriaDetail("Override pointGun and reachForWound if desired if holding a pistol.  It never will for a rifle")]
        public bool RfwWithPistol
        {
            get { return rfwWithPistol; }
            set
            {

                SetArgument("rfwWithPistol", value);
                rfwWithPistol = value;
            }
        }

        private bool fling2 = false;
        /// <summary>
        /// Type of reaction
        /// </summary>
        [EuphoriaDetail("Type of reaction")]
        public bool Fling2
        {
            get { return fling2; }
            set
            {

                SetArgument("fling2", value);
                fling2 = value;
            }
        }

        private bool fling2Left = true;
        /// <summary>
        /// Fling the left arm
        /// </summary>
        [EuphoriaDetail("Fling the left arm")]
        public bool Fling2Left
        {
            get { return fling2Left; }
            set
            {

                SetArgument("fling2Left", value);
                fling2Left = value;
            }
        }

        private bool fling2Right = true;
        /// <summary>
        /// Fling the right arm
        /// </summary>
        [EuphoriaDetail("Fling the right arm")]
        public bool Fling2Right
        {
            get { return fling2Right; }
            set
            {

                SetArgument("fling2Right", value);
                fling2Right = value;
            }
        }

        private bool fling2OverrideStagger = false;
        /// <summary>
        /// Override stagger arms even if staggerFall:m_upperBodyReaction = true
        /// </summary>
        [EuphoriaDetail("Override stagger arms even if staggerFall:m_upperBodyReaction = true")]
        public bool Fling2OverrideStagger
        {
            get { return fling2OverrideStagger; }
            set
            {

                SetArgument("fling2OverrideStagger", value);
                fling2OverrideStagger = value;
            }
        }

        private float fling2TimeBefore = 0.10f;
        /// <summary>
        /// Time after hit that the fling will start (allows for a bit of loose arm movement from bullet impact.snap etc)
        /// </summary>
        [EuphoriaDetail("Time after hit that the fling will start (allows for a bit of loose arm movement from bullet impact.snap etc)")]
        public float Fling2TimeBefore
        {
            get { return fling2TimeBefore; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("fling2TimeBefore", value);
                fling2TimeBefore = value;
            }
        }

        private float fling2Time = 0.50f;
        /// <summary>
        /// Duration of the fling behaviour.
        /// </summary>
        [EuphoriaDetail("Duration of the fling behaviour.")]
        public float Fling2Time
        {
            get { return fling2Time; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("fling2Time", value);
                fling2Time = value;
            }
        }

        private float fling2MStiffL = 0.950f;
        /// <summary>
        /// MuscleStiffness of the left arm.  If negative then uses the shots underlying muscle stiffness from controlStiffness (i.e. respects looseness)
        /// </summary>
        [EuphoriaDetail("MuscleStiffness of the left arm.  If negative then uses the shots underlying muscle stiffness from controlStiffness (i.e. respects looseness)")]
        public float Fling2MStiffL
        {
            get { return fling2MStiffL; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.50f);
                SetArgument("fling2MStiffL", value);
                fling2MStiffL = value;
            }
        }

        private float fling2MStiffR = -1.00f;
        /// <summary>
        /// MuscleStiffness of the right arm.  If negative then uses the shots underlying muscle stiffness from controlStiffness (i.e. respects looseness)
        /// </summary>
        [EuphoriaDetail("MuscleStiffness of the right arm.  If negative then uses the shots underlying muscle stiffness from controlStiffness (i.e. respects looseness)")]
        public float Fling2MStiffR
        {
            get { return fling2MStiffR; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.50f);
                SetArgument("fling2MStiffR", value);
                fling2MStiffR = value;
            }
        }

        private float fling2RelaxTimeL = 0.50f;
        /// <summary>
        /// Maximum time before the left arm relaxes in the fling.  It will relax automatically when the arm has completed it's bent arm fling.  This is what causes the arm to straighten.
        /// </summary>
        [EuphoriaDetail("Maximum time before the left arm relaxes in the fling.  It will relax automatically when the arm has completed it's bent arm fling.  This is what causes the arm to straighten.")]
        public float Fling2RelaxTimeL
        {
            get { return fling2RelaxTimeL; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("fling2RelaxTimeL", value);
                fling2RelaxTimeL = value;
            }
        }

        private float fling2RelaxTimeR = 0.50f;
        /// <summary>
        /// Maximum time before the right arm relaxes in the fling.  It will relax automatically when the arm has completed it's bent arm fling.  This is what causes the arm to straighten.
        /// </summary>
        [EuphoriaDetail("Maximum time before the right arm relaxes in the fling.  It will relax automatically when the arm has completed it's bent arm fling.  This is what causes the arm to straighten.")]
        public float Fling2RelaxTimeR
        {
            get { return fling2RelaxTimeR; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("fling2RelaxTimeR", value);
                fling2RelaxTimeR = value;
            }
        }

        private float fling2AngleMinL = -1.50f;
        /// <summary>
        /// Min fling angle for left arm.  Fling angle is random in the range fling2AngleMin:fling2AngleMax. Angle of fling in radians measured from the body horizontal sideways from shoulder. positive is up, 0 shoulder level, negative down
        /// </summary>
        [EuphoriaDetail("Min fling angle for left arm.  Fling angle is random in the range fling2AngleMin:fling2AngleMax. Angle of fling in radians measured from the body horizontal sideways from shoulder. positive is up, 0 shoulder level, negative down")]
        public float Fling2AngleMinL
        {
            get { return fling2AngleMinL; }
            set
            {
                value = MathHelper.Clamp(value, -1.50f, 1.00f);
                SetArgument("fling2AngleMinL", value);
                fling2AngleMinL = value;
            }
        }

        private float fling2AngleMaxL = 1.00f;
        /// <summary>
        /// Max fling angle for left arm
        /// </summary>
        [EuphoriaDetail("Max fling angle for left arm")]
        public float Fling2AngleMaxL
        {
            get { return fling2AngleMaxL; }
            set
            {
                value = MathHelper.Clamp(value, -1.50f, 1.00f);
                SetArgument("fling2AngleMaxL", value);
                fling2AngleMaxL = value;
            }
        }

        private float fling2AngleMinR = -1.50f;
        /// <summary>
        /// Min fling angle for right arm.
        /// </summary>
        [EuphoriaDetail("Min fling angle for right arm.")]
        public float Fling2AngleMinR
        {
            get { return fling2AngleMinR; }
            set
            {
                value = MathHelper.Clamp(value, -1.50f, 1.00f);
                SetArgument("fling2AngleMinR", value);
                fling2AngleMinR = value;
            }
        }

        private float fling2AngleMaxR = 1.00f;
        /// <summary>
        /// Max fling angle for right arm
        /// </summary>
        [EuphoriaDetail("Max fling angle for right arm")]
        public float Fling2AngleMaxR
        {
            get { return fling2AngleMaxR; }
            set
            {
                value = MathHelper.Clamp(value, -1.50f, 1.00f);
                SetArgument("fling2AngleMaxR", value);
                fling2AngleMaxR = value;
            }
        }

        private float fling2LengthMinL = 0.250f;
        /// <summary>
        /// Min left arm length.  Armlength is random in the range fling2LengthMin:fling2LengthMax.  Armlength maps one to one with elbow angle.  (These values are scaled internally for the female character)
        /// </summary>
        [EuphoriaDetail("Min left arm length.  Armlength is random in the range fling2LengthMin:fling2LengthMax.  Armlength maps one to one with elbow angle.  (These values are scaled internally for the female character)")]
        public float Fling2LengthMinL
        {
            get { return fling2LengthMinL; }
            set
            {
                value = MathHelper.Clamp(value, 0.250f, 0.60f);
                SetArgument("fling2LengthMinL", value);
                fling2LengthMinL = value;
            }
        }

        private float fling2LengthMaxL = 0.60f;
        /// <summary>
        /// Max left arm length.
        /// </summary>
        [EuphoriaDetail("Max left arm length.")]
        public float Fling2LengthMaxL
        {
            get { return fling2LengthMaxL; }
            set
            {
                value = MathHelper.Clamp(value, 0.250f, 0.60f);
                SetArgument("fling2LengthMaxL", value);
                fling2LengthMaxL = value;
            }
        }

        private float fling2LengthMinR = 0.250f;
        /// <summary>
        /// Min right arm length.
        /// </summary>
        [EuphoriaDetail("Min right arm length.")]
        public float Fling2LengthMinR
        {
            get { return fling2LengthMinR; }
            set
            {
                value = MathHelper.Clamp(value, 0.250f, 0.60f);
                SetArgument("fling2LengthMinR", value);
                fling2LengthMinR = value;
            }
        }

        private float fling2LengthMaxR = 0.60f;
        /// <summary>
        /// Max right arm length.
        /// </summary>
        [EuphoriaDetail("Max right arm length.")]
        public float Fling2LengthMaxR
        {
            get { return fling2LengthMaxR; }
            set
            {
                value = MathHelper.Clamp(value, 0.250f, 0.60f);
                SetArgument("fling2LengthMaxR", value);
                fling2LengthMaxR = value;
            }
        }

        private bool bust = false;
        /// <summary>
        /// Has the character got a bust.  If so then cupBust (move bust reach targets below bust) or bustElbowLift and cupSize (stop upperArm penetrating bust and move bust targets to surface of bust) are implemented.
        /// </summary>
        [EuphoriaDetail("Has the character got a bust.  If so then cupBust (move bust reach targets below bust) or bustElbowLift and cupSize (stop upperArm penetrating bust and move bust targets to surface of bust) are implemented.")]
        public bool Bust
        {
            get { return bust; }
            set
            {

                SetArgument("bust", value);
                bust = value;
            }
        }

        private float bustElbowLift = 0.70f;
        /// <summary>
        /// Lift the elbows up this much extra to avoid upper arm penetrating the bust (when target hits spine2 or spine3)
        /// </summary>
        [EuphoriaDetail("Lift the elbows up this much extra to avoid upper arm penetrating the bust (when target hits spine2 or spine3)")]
        public float BustElbowLift
        {
            get { return bustElbowLift; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("bustElbowLift", value);
                bustElbowLift = value;
            }
        }

        private float cupSize = 0.10f;
        /// <summary>
        /// Amount reach target to bust (spine2) will be offset forward by
        /// </summary>
        [EuphoriaDetail("Amount reach target to bust (spine2) will be offset forward by")]
        public float CupSize
        {
            get { return cupSize; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("cupSize", value);
                cupSize = value;
            }
        }

        private bool cupBust = false;
        /// <summary>
        /// All reach targets above or on the bust will cause a reach below the bust. (specifically moves spine3 and spine2 targets to spine1). bustElbowLift and cupSize are ignored.
        /// </summary>
        [EuphoriaDetail("All reach targets above or on the bust will cause a reach below the bust. (specifically moves spine3 and spine2 targets to spine1). bustElbowLift and cupSize are ignored.")]
        public bool CupBust
        {
            get { return cupBust; }
            set
            {

                SetArgument("cupBust", value);
                cupBust = value;
            }
        }


        public EuphoriaMessageShotConfigureArms(bool startNow) : base("shotConfigureArms", startNow)
        { }

        public new void Reset()
        {
            brace = true;
            pointGun = false;
            useArmsWindmill = true;
            releaseWound = 1;
            reachFalling = 0;
            reachFallingWithOneHand = 3;
            reachOnFloor = 0;
            alwaysReachTime = 0.30f;
            aWSpeedMult = 1.0f;
            aWRadiusMult = 1.0f;
            aWStiffnessAdd = 4.0f;
            reachWithOneHand = 0;
            allowLeftPistolRFW = true;
            allowRightPistolRFW = false;
            rfwWithPistol = false;
            fling2 = false;
            fling2Left = true;
            fling2Right = true;
            fling2OverrideStagger = false;
            fling2TimeBefore = 0.10f;
            fling2Time = 0.50f;
            fling2MStiffL = 0.950f;
            fling2MStiffR = -1.00f;
            fling2RelaxTimeL = 0.50f;
            fling2RelaxTimeR = 0.50f;
            fling2AngleMinL = -1.50f;
            fling2AngleMaxL = 1.00f;
            fling2AngleMinR = -1.50f;
            fling2AngleMaxR = 1.00f;
            fling2LengthMinL = 0.250f;
            fling2LengthMaxL = 0.60f;
            fling2LengthMinR = 0.250f;
            fling2LengthMaxR = 0.60f;
            bust = false;
            bustElbowLift = 0.70f;
            cupSize = 0.10f;
            cupBust = false;
            base.Reset();
        }
    }


    /// <summary>
    /// smartFall: Clone of High Fall with a wider range of operating conditions.
    /// </summary>
    [EuphoriaDetail("smartFall: Clone of High Fall with a wider range of operating conditions.")]
    internal class EuphoriaMessageSmartFall : EuphoriaMessage
    {
        private float bodyStiffness = 11.00f;
        /// <summary>
        /// stiffness of body. Value feeds through to bodyBalance (synched with defaults), to armsWindmill (14 for this value at default ), legs pedal, head look and roll down stairs directly
        /// </summary>
        [EuphoriaDetail("stiffness of body. Value feeds through to bodyBalance (synched with defaults), to armsWindmill (14 for this value at default ), legs pedal, head look and roll down stairs directly")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.00f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private float bodydamping = 1.00f;
        /// <summary>
        /// The damping of the joints.
        /// </summary>
        [EuphoriaDetail("The damping of the joints.")]
        public float Bodydamping
        {
            get { return bodydamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 3.00f);
                SetArgument("bodydamping", value);
                bodydamping = value;
            }
        }

        private float catchfalltime = 0.300f;
        /// <summary>
        /// The length of time before the impact that the character transitions to the landing.
        /// </summary>
        [EuphoriaDetail("The length of time before the impact that the character transitions to the landing.")]
        public float Catchfalltime
        {
            get { return catchfalltime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("catchfalltime", value);
                catchfalltime = value;
            }
        }

        private float crashOrLandCutOff = 0.8680f;
        /// <summary>
        /// 0.52angle is 0.868 dot//A threshold for deciding how far away from upright the character needs to be before bailing out (going into a foetal) instead of trying to land (keeping stretched out).  NB: never does bailout if ignorWorldCollisions true
        /// </summary>
        [EuphoriaDetail("0.52angle is 0.868 dot//A threshold for deciding how far away from upright the character needs to be before bailing out (going into a foetal) instead of trying to land (keeping stretched out).  NB: never does bailout if ignorWorldCollisions true")]
        public float CrashOrLandCutOff
        {
            get { return crashOrLandCutOff; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("crashOrLandCutOff", value);
                crashOrLandCutOff = value;
            }
        }

        private float pdStrength = 0.00f;
        /// <summary>
        /// Strength of the controller to keep the character at angle aimAngleBase from vertical.
        /// </summary>
        [EuphoriaDetail("Strength of the controller to keep the character at angle aimAngleBase from vertical.")]
        public float PdStrength
        {
            get { return pdStrength; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("pdStrength", value);
                pdStrength = value;
            }
        }

        private float pdDamping = 1.00f;
        /// <summary>
        /// Damping multiplier of the controller to keep the character at angle aimAngleBase from vertical.  The actual damping is pdDamping*pdStrength*constant*angVel.
        /// </summary>
        [EuphoriaDetail("Damping multiplier of the controller to keep the character at angle aimAngleBase from vertical.  The actual damping is pdDamping*pdStrength*constant*angVel.")]
        public float PdDamping
        {
            get { return pdDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 5.00f);
                SetArgument("pdDamping", value);
                pdDamping = value;
            }
        }

        private float armAngSpeed = 7.850f;
        /// <summary>
        /// arm circling speed in armWindMillAdaptive
        /// </summary>
        [EuphoriaDetail("arm circling speed in armWindMillAdaptive")]
        public float ArmAngSpeed
        {
            get { return armAngSpeed; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 20.0f);
                SetArgument("armAngSpeed", value);
                armAngSpeed = value;
            }
        }

        private float armAmplitude = 2.00f;
        /// <summary>
        /// in armWindMillAdaptive
        /// </summary>
        [EuphoriaDetail("in armWindMillAdaptive")]
        public float ArmAmplitude
        {
            get { return armAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("armAmplitude", value);
                armAmplitude = value;
            }
        }

        private float armPhase = 3.10f;
        /// <summary>
        /// in armWindMillAdaptive 3.1 opposite for stuntman.  1.0 old default.  0.0 in phase.
        /// </summary>
        [EuphoriaDetail("in armWindMillAdaptive 3.1 opposite for stuntman.  1.0 old default.  0.0 in phase.")]
        public float ArmPhase
        {
            get { return armPhase; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 6.283185f);
                SetArgument("armPhase", value);
                armPhase = value;
            }
        }

        private bool armBendElbows = true;
        /// <summary>
        /// in armWindMillAdaptive bend the elbows as a function of armAngle.  For stuntman true otherwise false.
        /// </summary>
        [EuphoriaDetail("in armWindMillAdaptive bend the elbows as a function of armAngle.  For stuntman true otherwise false.")]
        public bool ArmBendElbows
        {
            get { return armBendElbows; }
            set
            {

                SetArgument("armBendElbows", value);
                armBendElbows = value;
            }
        }

        private float legRadius = 0.40f;
        /// <summary>
        /// radius of legs on pedal
        /// </summary>
        [EuphoriaDetail("radius of legs on pedal")]
        public float LegRadius
        {
            get { return legRadius; }
            set
            {
                value = MathHelper.Clamp(value, 0.010f, 0.50f);
                SetArgument("legRadius", value);
                legRadius = value;
            }
        }

        private float legAngSpeed = 7.850f;
        /// <summary>
        /// in pedal
        /// </summary>
        [EuphoriaDetail("in pedal")]
        public float LegAngSpeed
        {
            get { return legAngSpeed; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 15.0f);
                SetArgument("legAngSpeed", value);
                legAngSpeed = value;
            }
        }

        private float legAsymmetry = 4.00f;
        /// <summary>
        /// 0.0 for stuntman.  Random offset applied per leg to the angular speed to desynchronise the pedaling - set to 0 to disable, otherwise should be set to less than the angularSpeed value.
        /// </summary>
        [EuphoriaDetail("0.0 for stuntman.  Random offset applied per leg to the angular speed to desynchronise the pedaling - set to 0 to disable, otherwise should be set to less than the angularSpeed value.")]
        public float LegAsymmetry
        {
            get { return legAsymmetry; }
            set
            {
                value = MathHelper.Clamp(value, -10.00f, 10.00f);
                SetArgument("legAsymmetry", value);
                legAsymmetry = value;
            }
        }

        private float arms2LegsPhase = 0.00f;
        /// <summary>
        /// phase angle between the arms and legs circling angle
        /// </summary>
        [EuphoriaDetail("phase angle between the arms and legs circling angle")]
        public float Arms2LegsPhase
        {
            get { return arms2LegsPhase; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 6.50f);
                SetArgument("arms2LegsPhase", value);
                arms2LegsPhase = value;
            }
        }

        private int arms2LegsSync = 1;
        /// <summary>
        /// 0=not synched, 1=always synched, 2= synch at start only.  Synchs the arms angle to what the leg angle is.  All speed/direction parameters of armswindmill are overwritten if = 1.  If 2 and you want synced arms/legs then armAngSpeed=legAngSpeed, legAsymmetry = 0.0 (to stop randomizations of the leg cicle speed)
        /// </summary>
        [EuphoriaDetail("0=not synched, 1=always synched, 2= synch at start only.  Synchs the arms angle to what the leg angle is.  All speed/direction parameters of armswindmill are overwritten if = 1.  If 2 and you want synced arms/legs then armAngSpeed=legAngSpeed, legAsymmetry = 0.0 (to stop randomizations of the leg cicle speed)")]
        public int Arms2LegsSync
        {
            get { return arms2LegsSync; }
            set
            {
                value = MathHelper.Clamp(value, 0, 2);
                SetArgument("arms2LegsSync", value);
                arms2LegsSync = value;
            }
        }

        private float armsUp = -3.10f;
        /// <summary>
        /// Where to put the arms when preparing to land. Approx 1 = above head, 0 = head height, -1 = down.   LT -2.0 use catchFall arms,  LT -3.0 use prepare for landing pose if Agent is due to land vertically, feet first.
        /// </summary>
        [EuphoriaDetail("Where to put the arms when preparing to land. Approx 1 = above head, 0 = head height, -1 = down.   LT -2.0 use catchFall arms,  LT -3.0 use prepare for landing pose if Agent is due to land vertically, feet first.")]
        public float ArmsUp
        {
            get { return armsUp; }
            set
            {
                value = MathHelper.Clamp(value, -4.00f, 2.00f);
                SetArgument("armsUp", value);
                armsUp = value;
            }
        }

        private bool orientateBodyToFallDirection = false;
        /// <summary>
        /// toggle to orientate to fall direction.  i.e. orientate so that the character faces the horizontal velocity direction
        /// </summary>
        [EuphoriaDetail("toggle to orientate to fall direction.  i.e. orientate so that the character faces the horizontal velocity direction")]
        public bool OrientateBodyToFallDirection
        {
            get { return orientateBodyToFallDirection; }
            set
            {

                SetArgument("orientateBodyToFallDirection", value);
                orientateBodyToFallDirection = value;
            }
        }

        private bool orientateTwist = true;
        /// <summary>
        /// If false don't worry about the twist angle of the character when orientating the character.  If false this allows the twist axis of the character to be free (You can get a nice twisting highFall like the one in dieHard 4 when the car goes into the helicopter)
        /// </summary>
        [EuphoriaDetail("If false don't worry about the twist angle of the character when orientating the character.  If false this allows the twist axis of the character to be free (You can get a nice twisting highFall like the one in dieHard 4 when the car goes into the helicopter)")]
        public bool OrientateTwist
        {
            get { return orientateTwist; }
            set
            {

                SetArgument("orientateTwist", value);
                orientateTwist = value;
            }
        }

        private float orientateMax = 300.00f;
        /// <summary>
        /// DEVEL parameter - suggest you don't edit it.  Maximum torque the orientation controller can apply.  If 0 then no helper torques will be used.  300 will orientate the character soflty for all but extreme angles away from aimAngleBase.  If abs (current -aimAngleBase) is getting near 3.0 then this can be reduced to give a softer feel.
        /// </summary>
        [EuphoriaDetail("DEVEL parameter - suggest you don't edit it.  Maximum torque the orientation controller can apply.  If 0 then no helper torques will be used.  300 will orientate the character soflty for all but extreme angles away from aimAngleBase.  If abs (current -aimAngleBase) is getting near 3.0 then this can be reduced to give a softer feel.")]
        public float OrientateMax
        {
            get { return orientateMax; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2000.00f);
                SetArgument("orientateMax", value);
                orientateMax = value;
            }
        }

        private bool alanRickman = false;
        /// <summary>
        /// If true then orientate the character to face the point from where it started falling.  HighFall like the one in dieHard with Alan Rickman
        /// </summary>
        [EuphoriaDetail("If true then orientate the character to face the point from where it started falling.  HighFall like the one in dieHard with Alan Rickman")]
        public bool AlanRickman
        {
            get { return alanRickman; }
            set
            {

                SetArgument("alanRickman", value);
                alanRickman = value;
            }
        }

        private bool fowardRoll = false;
        /// <summary>
        /// Try to execute a forward Roll on landing
        /// </summary>
        [EuphoriaDetail("Try to execute a forward Roll on landing")]
        public bool FowardRoll
        {
            get { return fowardRoll; }
            set
            {

                SetArgument("fowardRoll", value);
                fowardRoll = value;
            }
        }

        private bool useZeroPose_withFowardRoll = false;
        /// <summary>
        /// Blend to a zero pose when forward roll is attempted.
        /// </summary>
        [EuphoriaDetail("Blend to a zero pose when forward roll is attempted.")]
        public bool UseZeroPose_withFowardRoll
        {
            get { return useZeroPose_withFowardRoll; }
            set
            {

                SetArgument("useZeroPose_withFowardRoll", value);
                useZeroPose_withFowardRoll = value;
            }
        }

        private float aimAngleBase = 0.180f;
        /// <summary>
        /// Angle from vertical the pdController is driving to ( positive = forwards)
        /// </summary>
        [EuphoriaDetail("Angle from vertical the pdController is driving to ( positive = forwards)")]
        public float AimAngleBase
        {
            get { return aimAngleBase; }
            set
            {
                value = MathHelper.Clamp(value, -3.141593f, 3.141593f);
                SetArgument("aimAngleBase", value);
                aimAngleBase = value;
            }
        }

        private float fowardVelRotation = -0.020f;
        /// <summary>
        /// scale to add/subtract from aimAngle based on forward speed (Internal)
        /// </summary>
        [EuphoriaDetail("scale to add/subtract from aimAngle based on forward speed (Internal)")]
        public float FowardVelRotation
        {
            get { return fowardVelRotation; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("fowardVelRotation", value);
                fowardVelRotation = value;
            }
        }

        private float footVelCompScale = 0.050f;
        /// <summary>
        /// Scale to change to amount of vel that is added to the foot ik from the velocity (Internal)
        /// </summary>
        [EuphoriaDetail("Scale to change to amount of vel that is added to the foot ik from the velocity (Internal)")]
        public float FootVelCompScale
        {
            get { return footVelCompScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("footVelCompScale", value);
                footVelCompScale = value;
            }
        }

        private float sideD = 0.20f;
        /// <summary>
        /// sideoffset for the feet during prepareForLanding. +ve = right.
        /// </summary>
        [EuphoriaDetail("sideoffset for the feet during prepareForLanding. +ve = right.")]
        public float SideD
        {
            get { return sideD; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("sideD", value);
                sideD = value;
            }
        }

        private float fowardOffsetOfLegIK = 0.00f;
        /// <summary>
        /// Forward offset for the feet during prepareForLanding
        /// </summary>
        [EuphoriaDetail("Forward offset for the feet during prepareForLanding")]
        public float FowardOffsetOfLegIK
        {
            get { return fowardOffsetOfLegIK; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("fowardOffsetOfLegIK", value);
                fowardOffsetOfLegIK = value;
            }
        }

        private float legL = 1.00f;
        /// <summary>
        /// Leg Length for ik (Internal)//unused
        /// </summary>
        [EuphoriaDetail("Leg Length for ik (Internal)//unused")]
        public float LegL
        {
            get { return legL; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.00f);
                SetArgument("legL", value);
                legL = value;
            }
        }

        private float catchFallCutOff = 0.8780f;
        /// <summary>
        /// 0.5angle is 0.878 dot. Cutoff to go to the catchFall ( internal) //mmmtodo do like crashOrLandCutOff
        /// </summary>
        [EuphoriaDetail("0.5angle is 0.878 dot. Cutoff to go to the catchFall ( internal) //mmmtodo do like crashOrLandCutOff")]
        public float CatchFallCutOff
        {
            get { return catchFallCutOff; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("catchFallCutOff", value);
                catchFallCutOff = value;
            }
        }

        private float legStrength = 12.00f;
        /// <summary>
        /// Strength of the legs at landing
        /// </summary>
        [EuphoriaDetail("Strength of the legs at landing")]
        public float LegStrength
        {
            get { return legStrength; }
            set
            {
                value = MathHelper.Clamp(value, 6.00f, 16.0f);
                SetArgument("legStrength", value);
                legStrength = value;
            }
        }

        private bool balance = true;
        /// <summary>
        /// If true have enough strength to balance.  If false not enough strength in legs to balance (even though bodyBlance called)
        /// </summary>
        [EuphoriaDetail("If true have enough strength to balance.  If false not enough strength in legs to balance (even though bodyBlance called)")]
        public bool Balance
        {
            get { return balance; }
            set
            {

                SetArgument("balance", value);
                balance = value;
            }
        }

        private bool ignorWorldCollisions = false;
        /// <summary>
        /// Never go into bailout (foetal)
        /// </summary>
        [EuphoriaDetail("Never go into bailout (foetal)")]
        public bool IgnorWorldCollisions
        {
            get { return ignorWorldCollisions; }
            set
            {

                SetArgument("ignorWorldCollisions", value);
                ignorWorldCollisions = value;
            }
        }

        private bool adaptiveCircling = true;
        /// <summary>
        /// stuntman type fall.  Arm and legs circling direction controlled by angmom and orientation
        /// </summary>
        [EuphoriaDetail("stuntman type fall.  Arm and legs circling direction controlled by angmom and orientation")]
        public bool AdaptiveCircling
        {
            get { return adaptiveCircling; }
            set
            {

                SetArgument("adaptiveCircling", value);
                adaptiveCircling = value;
            }
        }

        private bool hula = true;
        /// <summary>
        /// With stuntman type fall.  Hula reaction if can't see floor and not rotating fast
        /// </summary>
        [EuphoriaDetail("With stuntman type fall.  Hula reaction if can't see floor and not rotating fast")]
        public bool Hula
        {
            get { return hula; }
            set
            {

                SetArgument("hula", value);
                hula = value;
            }
        }

        private float maxSpeedForRecoverableFall = 15.00f;
        /// <summary>
        /// Character needs to be moving less than this speed to consider fall as a recoverable one.
        /// </summary>
        [EuphoriaDetail("Character needs to be moving less than this speed to consider fall as a recoverable one.")]
        public float MaxSpeedForRecoverableFall
        {
            get { return maxSpeedForRecoverableFall; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("maxSpeedForRecoverableFall", value);
                maxSpeedForRecoverableFall = value;
            }
        }

        private float minSpeedForBrace = 10.00f;
        /// <summary>
        /// Character needs to be moving at least this fast horizontally to start bracing for impact if there is an object along its trajectory.
        /// </summary>
        [EuphoriaDetail("Character needs to be moving at least this fast horizontally to start bracing for impact if there is an object along its trajectory.")]
        public float MinSpeedForBrace
        {
            get { return minSpeedForBrace; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("minSpeedForBrace", value);
                minSpeedForBrace = value;
            }
        }

        private float landingNormal = 0.60f;
        /// <summary>
        /// Ray-cast normal doted with up direction has to be greater than this number to consider object flat enough to land on it.
        /// </summary>
        [EuphoriaDetail("Ray-cast normal doted with up direction has to be greater than this number to consider object flat enough to land on it.")]
        public float LandingNormal
        {
            get { return landingNormal; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("landingNormal", value);
                landingNormal = value;
            }
        }

        private float rdsForceMag = 0.80f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float RdsForceMag
        {
            get { return rdsForceMag; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("rdsForceMag", value);
                rdsForceMag = value;
            }
        }

        private float rdsTargetLinVeDecayTime = 0.5f;
        /// <summary>
        /// RDS: Time for the targetlinearVelocity to decay to zero.
        /// </summary>
        [EuphoriaDetail("RDS: Time for the targetlinearVelocity to decay to zero.")]
        public float RdsTargetLinVeDecayTime
        {
            get { return rdsTargetLinVeDecayTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("rdsTargetLinVeDecayTime", value);
                rdsTargetLinVeDecayTime = value;
            }
        }

        private float rdsTargetLinearVelocity = 1.0f;
        /// <summary>
        /// RDS: Helper torques are applied to match the spin of the character to the max of targetLinearVelocity and COMVelMag. -1 to use initial character velocity.
        /// </summary>
        [EuphoriaDetail("RDS: Helper torques are applied to match the spin of the character to the max of targetLinearVelocity and COMVelMag. -1 to use initial character velocity.")]
        public float RdsTargetLinearVelocity
        {
            get { return rdsTargetLinearVelocity; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 30.0f);
                SetArgument("rdsTargetLinearVelocity", value);
                rdsTargetLinearVelocity = value;
            }
        }

        private bool rdsUseStartingFriction = false;
        /// <summary>
        /// Start Catch Fall/RDS state with specified friction. Catch fall will overwrite based on setFallingReaction.
        /// </summary>
        [EuphoriaDetail("Start Catch Fall/RDS state with specified friction. Catch fall will overwrite based on setFallingReaction.")]
        public bool RdsUseStartingFriction
        {
            get { return rdsUseStartingFriction; }
            set
            {

                SetArgument("rdsUseStartingFriction", value);
                rdsUseStartingFriction = value;
            }
        }

        private float rdsStartingFriction = 0.00f;
        /// <summary>
        /// Catch Fall/RDS starting friction. Catch fall will overwrite based on setFallingReaction.
        /// </summary>
        [EuphoriaDetail("Catch Fall/RDS starting friction. Catch fall will overwrite based on setFallingReaction.")]
        public float RdsStartingFriction
        {
            get { return rdsStartingFriction; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.0f);
                SetArgument("rdsStartingFriction", value);
                rdsStartingFriction = value;
            }
        }

        private float rdsStartingFrictionMin = 0.00f;
        /// <summary>
        /// Catch Fall/RDS starting friction minimum. Catch fall will overwrite based on setFallingReaction.
        /// </summary>
        [EuphoriaDetail("Catch Fall/RDS starting friction minimum. Catch fall will overwrite based on setFallingReaction.")]
        public float RdsStartingFrictionMin
        {
            get { return rdsStartingFrictionMin; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("rdsStartingFrictionMin", value);
                rdsStartingFrictionMin = value;
            }
        }

        private float rdsForceVelThreshold = 10.0f;
        /// <summary>
        /// Velocity threshold under which RDS force mag will be applied.
        /// </summary>
        [EuphoriaDetail("Velocity threshold under which RDS force mag will be applied.")]
        public float RdsForceVelThreshold
        {
            get { return rdsForceVelThreshold; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.0f);
                SetArgument("rdsForceVelThreshold", value);
                rdsForceVelThreshold = value;
            }
        }

        private int initialState = 0;
        /// <summary>
        /// Force initial state (used in vehicle bail out to start SF_CatchFall (6) earlier.
        /// </summary>
        [EuphoriaDetail("Force initial state (used in vehicle bail out to start SF_CatchFall (6) earlier.")]
        public int InitialState
        {
            get { return initialState; }
            set
            {
                value = MathHelper.Clamp(value, 0, 7);
                SetArgument("initialState", value);
                initialState = value;
            }
        }

        private bool changeExtremityFriction = false;
        /// <summary>
        /// Allow friction changes to be applied to the hands and feet.
        /// </summary>
        [EuphoriaDetail("Allow friction changes to be applied to the hands and feet.")]
        public bool ChangeExtremityFriction
        {
            get { return changeExtremityFriction; }
            set
            {

                SetArgument("changeExtremityFriction", value);
                changeExtremityFriction = value;
            }
        }

        private bool teeter = false;
        /// <summary>
        /// Set up an immediate teeter in the direction of trave if initial state is SF_Balance.
        /// </summary>
        [EuphoriaDetail("Set up an immediate teeter in the direction of trave if initial state is SF_Balance.")]
        public bool Teeter
        {
            get { return teeter; }
            set
            {

                SetArgument("teeter", value);
                teeter = value;
            }
        }

        private float teeterOffset = 0.30f;
        /// <summary>
        /// Offset the default Teeter edge in the direction of travel. Will need to be tweaked depending on how close to the real edge AI tends to trigger the behaviour.
        /// </summary>
        [EuphoriaDetail("Offset the default Teeter edge in the direction of travel. Will need to be tweaked depending on how close to the real edge AI tends to trigger the behaviour.")]
        public float TeeterOffset
        {
            get { return teeterOffset; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("teeterOffset", value);
                teeterOffset = value;
            }
        }

        private float stopRollingTime = 2.00f;
        /// <summary>
        /// Time in seconds before ped should start actively trying to stop rolling.
        /// </summary>
        [EuphoriaDetail("Time in seconds before ped should start actively trying to stop rolling.")]
        public float StopRollingTime
        {
            get { return stopRollingTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("stopRollingTime", value);
                stopRollingTime = value;
            }
        }

        private float reboundScale = 0.00f;
        /// <summary>
        /// Scale for rebound assistance.  0=off, 1=very bouncy, 2=jbone crazy  Try 0.5?
        /// </summary>
        [EuphoriaDetail("Scale for rebound assistance.  0=off, 1=very bouncy, 2=jbone crazy  Try 0.5?")]
        public float ReboundScale
        {
            get { return reboundScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 2.00f);
                SetArgument("reboundScale", value);
                reboundScale = value;
            }
        }

        private string reboundMask = "uk";
        /// <summary>
        /// Part mask to apply rebound assistance.
        /// </summary>
        [EuphoriaDetail("Part mask to apply rebound assistance.")]
        public string ReboundMask
        {
            get { return reboundMask; }
            set
            {

                SetArgument("reboundMask", value);
                reboundMask = value;
            }
        }

        private bool forceHeadAvoid = false;
        /// <summary>
        /// Force head avoid to be active during Catch Fall even when character is not on the ground.
        /// </summary>
        [EuphoriaDetail("Force head avoid to be active during Catch Fall even when character is not on the ground.")]
        public bool ForceHeadAvoid
        {
            get { return forceHeadAvoid; }
            set
            {

                SetArgument("forceHeadAvoid", value);
                forceHeadAvoid = value;
            }
        }

        private float cfZAxisSpinReduction = 0.50f;
        /// <summary>
        /// Pass-through parameter for Catch Fall spin reduction.  Increase to stop more spin. 0..1.
        /// </summary>
        [EuphoriaDetail("Pass-through parameter for Catch Fall spin reduction.  Increase to stop more spin. 0..1.")]
        public float CfZAxisSpinReduction
        {
            get { return cfZAxisSpinReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("cfZAxisSpinReduction", value);
                cfZAxisSpinReduction = value;
            }
        }

        private float splatWhenStopped = 0.00f;
        /// <summary>
        /// Transition to splat state when com vel is below value, regardless of character health or fall velocity.  Set to zero to disable.
        /// </summary>
        [EuphoriaDetail("Transition to splat state when com vel is below value, regardless of character health or fall velocity.  Set to zero to disable.")]
        public float SplatWhenStopped
        {
            get { return splatWhenStopped; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("splatWhenStopped", value);
                splatWhenStopped = value;
            }
        }

        private float blendHeadWhenStopped = 0.00f;
        /// <summary>
        /// Blend head to neutral pose com vel approaches zero.  Linear between zero and value.  Set to zero to disable.
        /// </summary>
        [EuphoriaDetail("Blend head to neutral pose com vel approaches zero.  Linear between zero and value.  Set to zero to disable.")]
        public float BlendHeadWhenStopped
        {
            get { return blendHeadWhenStopped; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 100.00f);
                SetArgument("blendHeadWhenStopped", value);
                blendHeadWhenStopped = value;
            }
        }

        private float spreadLegs = 0.10f;
        /// <summary>
        /// Spread legs amount for Pedal during fall.
        /// </summary>
        [EuphoriaDetail("Spread legs amount for Pedal during fall.")]
        public float SpreadLegs
        {
            get { return spreadLegs; }
            set
            {
                value = MathHelper.Clamp(value, -1.00f, 1.00f);
                SetArgument("spreadLegs", value);
                spreadLegs = value;
            }
        }


        public EuphoriaMessageSmartFall(bool startNow) : base("smartFall", startNow)
        { }

        public new void Reset()
        {
            bodyStiffness = 11.00f;
            bodydamping = 1.00f;
            catchfalltime = 0.300f;
            crashOrLandCutOff = 0.8680f;
            pdStrength = 0.00f;
            pdDamping = 1.00f;
            armAngSpeed = 7.850f;
            armAmplitude = 2.00f;
            armPhase = 3.10f;
            armBendElbows = true;
            legRadius = 0.40f;
            legAngSpeed = 7.850f;
            legAsymmetry = 4.00f;
            arms2LegsPhase = 0.00f;
            arms2LegsSync = 1;
            armsUp = -3.10f;
            orientateBodyToFallDirection = false;
            orientateTwist = true;
            orientateMax = 300.00f;
            alanRickman = false;
            fowardRoll = false;
            useZeroPose_withFowardRoll = false;
            aimAngleBase = 0.180f;
            fowardVelRotation = -0.020f;
            footVelCompScale = 0.050f;
            sideD = 0.20f;
            fowardOffsetOfLegIK = 0.00f;
            legL = 1.00f;
            catchFallCutOff = 0.8780f;
            legStrength = 12.00f;
            balance = true;
            ignorWorldCollisions = false;
            adaptiveCircling = true;
            hula = true;
            maxSpeedForRecoverableFall = 15.00f;
            minSpeedForBrace = 10.00f;
            landingNormal = 0.60f;
            rdsForceMag = 0.80f;
            rdsTargetLinVeDecayTime = 0.5f;
            rdsTargetLinearVelocity = 1.0f;
            rdsUseStartingFriction = false;
            rdsStartingFriction = 0.00f;
            rdsStartingFrictionMin = 0.00f;
            rdsForceVelThreshold = 10.0f;
            initialState = 0;
            changeExtremityFriction = false;
            teeter = false;
            teeterOffset = 0.30f;
            stopRollingTime = 2.00f;
            reboundScale = 0.00f;
            reboundMask = "uk";
            forceHeadAvoid = false;
            cfZAxisSpinReduction = 0.50f;
            splatWhenStopped = 0.00f;
            blendHeadWhenStopped = 0.00f;
            spreadLegs = 0.10f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageStaggerFall : EuphoriaMessage
    {
        private float armStiffness = 12.0f;
        /// <summary>
        /// stiffness of arms. catch_fall's stiffness scales with this value, but has default values when this is default
        /// </summary>
        [EuphoriaDetail("stiffness of arms. catch_fall's stiffness scales with this value, but has default values when this is default")]
        public float ArmStiffness
        {
            get { return armStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("armStiffness", value);
                armStiffness = value;
            }
        }

        private float armDamping = 1.0f;
        /// <summary>
        /// Sets damping value for the arms
        /// </summary>
        [EuphoriaDetail("Sets damping value for the arms")]
        public float ArmDamping
        {
            get { return armDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armDamping", value);
                armDamping = value;
            }
        }

        private float spineDamping = 1.0f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float SpineDamping
        {
            get { return spineDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("spineDamping", value);
                spineDamping = value;
            }
        }

        private float spineStiffness = 10.0f;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public float SpineStiffness
        {
            get { return spineStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("spineStiffness", value);
                spineStiffness = value;
            }
        }

        private float armStiffnessStart = 3.0f;
        /// <summary>
        /// armStiffness during the yanked timescale ie timeAtStartValues
        /// </summary>
        [EuphoriaDetail("armStiffness during the yanked timescale ie timeAtStartValues")]
        public float ArmStiffnessStart
        {
            get { return armStiffnessStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("armStiffnessStart", value);
                armStiffnessStart = value;
            }
        }

        private float armDampingStart = 0.1f;
        /// <summary>
        /// armDamping during the yanked timescale ie timeAtStartValues
        /// </summary>
        [EuphoriaDetail("armDamping during the yanked timescale ie timeAtStartValues")]
        public float ArmDampingStart
        {
            get { return armDampingStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armDampingStart", value);
                armDampingStart = value;
            }
        }

        private float spineDampingStart = 0.1f;
        /// <summary>
        /// spineDamping during the yanked timescale ie timeAtStartValues
        /// </summary>
        [EuphoriaDetail("spineDamping during the yanked timescale ie timeAtStartValues")]
        public float SpineDampingStart
        {
            get { return spineDampingStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("spineDampingStart", value);
                spineDampingStart = value;
            }
        }

        private float spineStiffnessStart = 3.0f;
        /// <summary>
        /// spineStiffness during the yanked timescale ie timeAtStartValues
        /// </summary>
        [EuphoriaDetail("spineStiffness during the yanked timescale ie timeAtStartValues")]
        public float SpineStiffnessStart
        {
            get { return spineStiffnessStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("spineStiffnessStart", value);
                spineStiffnessStart = value;
            }
        }

        private float timeAtStartValues = 0.0f;
        /// <summary>
        /// time spent with Start values for arms and spine stiffness and damping ie for whiplash efffect
        /// </summary>
        [EuphoriaDetail("time spent with Start values for arms and spine stiffness and damping ie for whiplash efffect")]
        public float TimeAtStartValues
        {
            get { return timeAtStartValues; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("timeAtStartValues", value);
                timeAtStartValues = value;
            }
        }

        private float rampTimeFromStartValues = 0.0f;
        /// <summary>
        /// time spent ramping from Start to end values for arms and spine stiffness and damping ie for whiplash efffect (occurs after timeAtStartValues)
        /// </summary>
        [EuphoriaDetail("time spent ramping from Start to end values for arms and spine stiffness and damping ie for whiplash efffect (occurs after timeAtStartValues)")]
        public float RampTimeFromStartValues
        {
            get { return rampTimeFromStartValues; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rampTimeFromStartValues", value);
                rampTimeFromStartValues = value;
            }
        }

        private float staggerStepProb = 0.0f;
        /// <summary>
        /// Probability per step of time spent in a stagger step
        /// </summary>
        [EuphoriaDetail("Probability per step of time spent in a stagger step")]
        public float StaggerStepProb
        {
            get { return staggerStepProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("staggerStepProb", value);
                staggerStepProb = value;
            }
        }

        private int stepsTillStartEnd = 2;
        /// <summary>
        /// steps taken before lowerBodyStiffness starts ramping down by perStepReduction1
        /// </summary>
        [EuphoriaDetail("steps taken before lowerBodyStiffness starts ramping down by perStepReduction1")]
        public int StepsTillStartEnd
        {
            get { return stepsTillStartEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0, 100);
                SetArgument("stepsTillStartEnd", value);
                stepsTillStartEnd = value;
            }
        }

        private float timeStartEnd = 100.0f;
        /// <summary>
        /// time from start of behaviour before lowerBodyStiffness starts ramping down for rampTimeToEndValues to endValues
        /// </summary>
        [EuphoriaDetail("time from start of behaviour before lowerBodyStiffness starts ramping down for rampTimeToEndValues to endValues")]
        public float TimeStartEnd
        {
            get { return timeStartEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 100.0f);
                SetArgument("timeStartEnd", value);
                timeStartEnd = value;
            }
        }

        private float rampTimeToEndValues = 0.0f;
        /// <summary>
        /// time spent ramping from lowerBodyStiffness to lowerBodyStiffnessEnd
        /// </summary>
        [EuphoriaDetail("time spent ramping from lowerBodyStiffness to lowerBodyStiffnessEnd")]
        public float RampTimeToEndValues
        {
            get { return rampTimeToEndValues; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("rampTimeToEndValues", value);
                rampTimeToEndValues = value;
            }
        }

        private float lowerBodyStiffness = 13.0f;
        /// <summary>
        /// lowerBodyStiffness should be 12
        /// </summary>
        [EuphoriaDetail("lowerBodyStiffness should be 12")]
        public float LowerBodyStiffness
        {
            get { return lowerBodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("lowerBodyStiffness", value);
                lowerBodyStiffness = value;
            }
        }

        private float lowerBodyStiffnessEnd = 8.0f;
        /// <summary>
        /// lowerBodyStiffness at end
        /// </summary>
        [EuphoriaDetail("lowerBodyStiffness at end")]
        public float LowerBodyStiffnessEnd
        {
            get { return lowerBodyStiffnessEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("lowerBodyStiffnessEnd", value);
                lowerBodyStiffnessEnd = value;
            }
        }

        private float predictionTime = 0.10f;
        /// <summary>
        /// amount of time (seconds) into the future that the character tries to step to. bigger values try to recover with fewer, bigger steps. smaller values recover with smaller steps, and generally recover less.
        /// </summary>
        [EuphoriaDetail("amount of time (seconds) into the future that the character tries to step to. bigger values try to recover with fewer, bigger steps. smaller values recover with smaller steps, and generally recover less.")]
        public float PredictionTime
        {
            get { return predictionTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("predictionTime", value);
                predictionTime = value;
            }
        }

        private float perStepReduction1 = 0.70f;
        /// <summary>
        /// LowerBody stiffness will be reduced every step to make the character fallover
        /// </summary>
        [EuphoriaDetail("LowerBody stiffness will be reduced every step to make the character fallover")]
        public float PerStepReduction1
        {
            get { return perStepReduction1; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("perStepReduction1", value);
                perStepReduction1 = value;
            }
        }

        private float leanInDirRate = 1.0f;
        /// <summary>
        /// leanInDirection will be increased from 0 to leanInDirMax linearly at this rate
        /// </summary>
        [EuphoriaDetail("leanInDirection will be increased from 0 to leanInDirMax linearly at this rate")]
        public float LeanInDirRate
        {
            get { return leanInDirRate; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("leanInDirRate", value);
                leanInDirRate = value;
            }
        }

        private float leanInDirMaxF = 0.10f;
        /// <summary>
        /// Max of leanInDirection magnitude when going forwards
        /// </summary>
        [EuphoriaDetail("Max of leanInDirection magnitude when going forwards")]
        public float LeanInDirMaxF
        {
            get { return leanInDirMaxF; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanInDirMaxF", value);
                leanInDirMaxF = value;
            }
        }

        private float leanInDirMaxB = 0.30f;
        /// <summary>
        /// Max of leanInDirection magnitude when going backwards
        /// </summary>
        [EuphoriaDetail("Max of leanInDirection magnitude when going backwards")]
        public float LeanInDirMaxB
        {
            get { return leanInDirMaxB; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanInDirMaxB", value);
                leanInDirMaxB = value;
            }
        }

        private float leanHipsMaxF = 0.00f;
        /// <summary>
        /// Max of leanInDirectionHips magnitude when going forwards
        /// </summary>
        [EuphoriaDetail("Max of leanInDirectionHips magnitude when going forwards")]
        public float LeanHipsMaxF
        {
            get { return leanHipsMaxF; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanHipsMaxF", value);
                leanHipsMaxF = value;
            }
        }

        private float leanHipsMaxB = 0.00f;
        /// <summary>
        /// Max of leanInDirectionHips magnitude when going backwards
        /// </summary>
        [EuphoriaDetail("Max of leanInDirectionHips magnitude when going backwards")]
        public float LeanHipsMaxB
        {
            get { return leanHipsMaxB; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("leanHipsMaxB", value);
                leanHipsMaxB = value;
            }
        }

        private float lean2multF = -1.00f;
        /// <summary>
        /// Lean of spine to side in side velocity direction when going forwards
        /// </summary>
        [EuphoriaDetail("Lean of spine to side in side velocity direction when going forwards")]
        public float Lean2multF
        {
            get { return lean2multF; }
            set
            {
                value = MathHelper.Clamp(value, -5.00f, 5.00f);
                SetArgument("lean2multF", value);
                lean2multF = value;
            }
        }

        private float lean2multB = -2.00f;
        /// <summary>
        /// Lean of spine to side in side velocity direction when going backwards
        /// </summary>
        [EuphoriaDetail("Lean of spine to side in side velocity direction when going backwards")]
        public float Lean2multB
        {
            get { return lean2multB; }
            set
            {
                value = MathHelper.Clamp(value, -5.00f, 5.00f);
                SetArgument("lean2multB", value);
                lean2multB = value;
            }
        }

        private float pushOffDist = 0.20f;
        /// <summary>
        /// amount stance foot is behind com in the direction of velocity before the leg tries to pushOff to increase momentum.  Increase to lower the probability of the pushOff making the character bouncy
        /// </summary>
        [EuphoriaDetail("amount stance foot is behind com in the direction of velocity before the leg tries to pushOff to increase momentum.  Increase to lower the probability of the pushOff making the character bouncy")]
        public float PushOffDist
        {
            get { return pushOffDist; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("pushOffDist", value);
                pushOffDist = value;
            }
        }

        private float maxPushoffVel = 20.00f;
        /// <summary>
        /// stance leg will only pushOff to increase momentum if the vertical hip velocity is less than this value. 0.4 seems like a good value.  The higher it is the the less this functionality is applied.  If it is very low or negative this can stop the pushOff altogether
        /// </summary>
        [EuphoriaDetail("stance leg will only pushOff to increase momentum if the vertical hip velocity is less than this value. 0.4 seems like a good value.  The higher it is the the less this functionality is applied.  If it is very low or negative this can stop the pushOff altogether")]
        public float MaxPushoffVel
        {
            get { return maxPushoffVel; }
            set
            {
                value = MathHelper.Clamp(value, -20.0f, 20.0f);
                SetArgument("maxPushoffVel", value);
                maxPushoffVel = value;
            }
        }

        private float hipBendMult = 0.00f;
        /// <summary>
        /// hipBend scaled with velocity
        /// </summary>
        [EuphoriaDetail("hipBend scaled with velocity")]
        public float HipBendMult
        {
            get { return hipBendMult; }
            set
            {
                value = MathHelper.Clamp(value, -10.0f, 10.0f);
                SetArgument("hipBendMult", value);
                hipBendMult = value;
            }
        }

        private bool alwaysBendForwards = false;
        /// <summary>
        /// bend forwards at the hip (hipBendMult) whether moving backwards or forwards
        /// </summary>
        [EuphoriaDetail("bend forwards at the hip (hipBendMult) whether moving backwards or forwards")]
        public bool AlwaysBendForwards
        {
            get { return alwaysBendForwards; }
            set
            {

                SetArgument("alwaysBendForwards", value);
                alwaysBendForwards = value;
            }
        }

        private float spineBendMult = 0.40f;
        /// <summary>
        /// spine bend scaled with velocity
        /// </summary>
        [EuphoriaDetail("spine bend scaled with velocity")]
        public float SpineBendMult
        {
            get { return spineBendMult; }
            set
            {
                value = MathHelper.Clamp(value, -10.0f, 10.0f);
                SetArgument("spineBendMult", value);
                spineBendMult = value;
            }
        }

        private bool useHeadLook = true;
        /// <summary>
        /// enable and provide a look-at target to make the character's head turn to face it while balancing, balancer default is 0.2
        /// </summary>
        [EuphoriaDetail("enable and provide a look-at target to make the character's head turn to face it while balancing, balancer default is 0.2")]
        public bool UseHeadLook
        {
            get { return useHeadLook; }
            set
            {

                SetArgument("useHeadLook", value);
                useHeadLook = value;
            }
        }

        private Vector3 headLookPos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position of thing to look at
        /// </summary>
        [EuphoriaDetail("position of thing to look at")]
        public Vector3 HeadLookPos
        {
            get { return headLookPos; }
            set
            {

                SetArgument("headLookPos", value);
                headLookPos = value;
            }
        }

        private int headLookInstanceIndex = -1;
        /// <summary>
        /// level index of thing to look at
        /// </summary>
        [EuphoriaDetail("level index of thing to look at")]
        public int HeadLookInstanceIndex
        {
            get { return headLookInstanceIndex; }
            set
            {

                SetArgument("headLookInstanceIndex", value);
                headLookInstanceIndex = value;
            }
        }

        private float headLookAtVelProb = 1.0f;
        /// <summary>
        /// Probability [0-1] that headLook will be looking in the direction of velocity when stepping
        /// </summary>
        [EuphoriaDetail("Probability [0-1] that headLook will be looking in the direction of velocity when stepping")]
        public float HeadLookAtVelProb
        {
            get { return headLookAtVelProb; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("headLookAtVelProb", value);
                headLookAtVelProb = value;
            }
        }

        private float turnOffProb = 0.0f;
        /// <summary>
        /// Weighted Probability that turn will be off. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability that turn will be off. This is one of six turn type weights.")]
        public float TurnOffProb
        {
            get { return turnOffProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turnOffProb", value);
                turnOffProb = value;
            }
        }

        private float turn2TargetProb = 0.0f;
        /// <summary>
        /// Weighted Probability of turning towards headLook target. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning towards headLook target. This is one of six turn type weights.")]
        public float Turn2TargetProb
        {
            get { return turn2TargetProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turn2TargetProb", value);
                turn2TargetProb = value;
            }
        }

        private float turn2VelProb = 1.0f;
        /// <summary>
        /// Weighted Probability of turning towards velocity. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning towards velocity. This is one of six turn type weights.")]
        public float Turn2VelProb
        {
            get { return turn2VelProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turn2VelProb", value);
                turn2VelProb = value;
            }
        }

        private float turnAwayProb = 0.0f;
        /// <summary>
        /// Weighted Probability of turning away from headLook target. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning away from headLook target. This is one of six turn type weights.")]
        public float TurnAwayProb
        {
            get { return turnAwayProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turnAwayProb", value);
                turnAwayProb = value;
            }
        }

        private float turnLeftProb = 0.0f;
        /// <summary>
        /// Weighted Probability of turning left. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning left. This is one of six turn type weights.")]
        public float TurnLeftProb
        {
            get { return turnLeftProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turnLeftProb", value);
                turnLeftProb = value;
            }
        }

        private float turnRightProb = 0.0f;
        /// <summary>
        /// Weighted Probability of turning right. This is one of six turn type weights.
        /// </summary>
        [EuphoriaDetail("Weighted Probability of turning right. This is one of six turn type weights.")]
        public float TurnRightProb
        {
            get { return turnRightProb; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("turnRightProb", value);
                turnRightProb = value;
            }
        }

        private bool useBodyTurn = false;
        /// <summary>
        /// enable and provide a positive bodyTurnTimeout and provide a look-at target to make the character turn to face it while balancing
        /// </summary>
        [EuphoriaDetail("enable and provide a positive bodyTurnTimeout and provide a look-at target to make the character turn to face it while balancing")]
        public bool UseBodyTurn
        {
            get { return useBodyTurn; }
            set
            {

                SetArgument("useBodyTurn", value);
                useBodyTurn = value;
            }
        }

        private bool upperBodyReaction = true;
        /// <summary>
        /// enable upper body reaction ie blindBrace and armswindmill
        /// </summary>
        [EuphoriaDetail("enable upper body reaction ie blindBrace and armswindmill")]
        public bool UpperBodyReaction
        {
            get { return upperBodyReaction; }
            set
            {

                SetArgument("upperBodyReaction", value);
                upperBodyReaction = value;
            }
        }


        public EuphoriaMessageStaggerFall(bool startNow) : base("staggerFall", startNow)
        { }

        public new void Reset()
        {
            armStiffness = 12.0f;
            armDamping = 1.0f;
            spineDamping = 1.0f;
            spineStiffness = 10.0f;
            armStiffnessStart = 3.0f;
            armDampingStart = 0.1f;
            spineDampingStart = 0.1f;
            spineStiffnessStart = 3.0f;
            timeAtStartValues = 0.0f;
            rampTimeFromStartValues = 0.0f;
            staggerStepProb = 0.0f;
            stepsTillStartEnd = 2;
            timeStartEnd = 100.0f;
            rampTimeToEndValues = 0.0f;
            lowerBodyStiffness = 13.0f;
            lowerBodyStiffnessEnd = 8.0f;
            predictionTime = 0.10f;
            perStepReduction1 = 0.70f;
            leanInDirRate = 1.0f;
            leanInDirMaxF = 0.10f;
            leanInDirMaxB = 0.30f;
            leanHipsMaxF = 0.00f;
            leanHipsMaxB = 0.00f;
            lean2multF = -1.00f;
            lean2multB = -2.00f;
            pushOffDist = 0.20f;
            maxPushoffVel = 20.00f;
            hipBendMult = 0.00f;
            alwaysBendForwards = false;
            spineBendMult = 0.40f;
            useHeadLook = true;
            headLookPos = new Vector3(0f, 0f, 0f);
            headLookInstanceIndex = -1;
            headLookAtVelProb = 1.0f;
            turnOffProb = 0.0f;
            turn2TargetProb = 0.0f;
            turn2VelProb = 1.0f;
            turnAwayProb = 0.0f;
            turnLeftProb = 0.0f;
            turnRightProb = 0.0f;
            useBodyTurn = false;
            upperBodyReaction = true;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageTeeter : EuphoriaMessage
    {
        private Vector3 edgeLeft = new Vector3(39.470f, 38.890f, 21.120f);
        /// <summary>
        /// Defines the left edge point (left of character facing edge)
        /// </summary>
        [EuphoriaDetail("Defines the left edge point (left of character facing edge)")]
        public Vector3 EdgeLeft
        {
            get { return edgeLeft; }
            set
            {

                SetArgument("edgeLeft", value);
                edgeLeft = value;
            }
        }

        private Vector3 edgeRight = new Vector3(39.470f, 39.890f, 21.120f);
        /// <summary>
        /// Defines the right edge point (right of character facing edge)
        /// </summary>
        [EuphoriaDetail("Defines the right edge point (right of character facing edge)")]
        public Vector3 EdgeRight
        {
            get { return edgeRight; }
            set
            {

                SetArgument("edgeRight", value);
                edgeRight = value;
            }
        }

        private bool useExclusionZone = true;
        /// <summary>
        /// stop stepping across the line defined by edgeLeft and edgeRight
        /// </summary>
        [EuphoriaDetail("stop stepping across the line defined by edgeLeft and edgeRight")]
        public bool UseExclusionZone
        {
            get { return useExclusionZone; }
            set
            {

                SetArgument("useExclusionZone", value);
                useExclusionZone = value;
            }
        }

        private bool useHeadLook = true;
        /// <summary>
        /// 
        /// </summary>
        [EuphoriaDetail("")]
        public bool UseHeadLook
        {
            get { return useHeadLook; }
            set
            {

                SetArgument("useHeadLook", value);
                useHeadLook = value;
            }
        }

        private bool callHighFall = true;
        /// <summary>
        /// call highFall if fallen over the edge.  If false just call blended writhe (to go over the top of the fall behaviour of the underlying behaviour e.g. bodyBalance)
        /// </summary>
        [EuphoriaDetail("call highFall if fallen over the edge.  If false just call blended writhe (to go over the top of the fall behaviour of the underlying behaviour e.g. bodyBalance)")]
        public bool CallHighFall
        {
            get { return callHighFall; }
            set
            {

                SetArgument("callHighFall", value);
                callHighFall = value;
            }
        }

        private bool leanAway = true;
        /// <summary>
        /// lean away from the edge based on velocity towards the edge (if closer than 2m from edge)
        /// </summary>
        [EuphoriaDetail("lean away from the edge based on velocity towards the edge (if closer than 2m from edge)")]
        public bool LeanAway
        {
            get { return leanAway; }
            set
            {

                SetArgument("leanAway", value);
                leanAway = value;
            }
        }

        private float preTeeterTime = 2.00f;
        /// <summary>
        /// Time-to-edge threshold to start pre-teeter (windmilling, etc).
        /// </summary>
        [EuphoriaDetail("Time-to-edge threshold to start pre-teeter (windmilling, etc).")]
        public float PreTeeterTime
        {
            get { return preTeeterTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("preTeeterTime", value);
                preTeeterTime = value;
            }
        }

        private float leanAwayTime = 1.00f;
        /// <summary>
        /// Time-to-edge threshold to start leaning away from a potential fall.
        /// </summary>
        [EuphoriaDetail("Time-to-edge threshold to start leaning away from a potential fall.")]
        public float LeanAwayTime
        {
            get { return leanAwayTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("leanAwayTime", value);
                leanAwayTime = value;
            }
        }

        private float leanAwayScale = 0.50f;
        /// <summary>
        /// Scales stay upright lean and hip pitch.
        /// </summary>
        [EuphoriaDetail("Scales stay upright lean and hip pitch.")]
        public float LeanAwayScale
        {
            get { return leanAwayScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 1.00f);
                SetArgument("leanAwayScale", value);
                leanAwayScale = value;
            }
        }

        private float teeterTime = 1.00f;
        /// <summary>
        /// Time-to-edge threshold to start full-on teeter (more aggressive lean, drop-and-twist, etc).
        /// </summary>
        [EuphoriaDetail("Time-to-edge threshold to start full-on teeter (more aggressive lean, drop-and-twist, etc).")]
        public float TeeterTime
        {
            get { return teeterTime; }
            set
            {
                value = MathHelper.Clamp(value, 0.00f, 10.00f);
                SetArgument("teeterTime", value);
                teeterTime = value;
            }
        }


        public EuphoriaMessageTeeter(bool startNow) : base("teeter", startNow)
        { }

        public new void Reset()
        {
            edgeLeft = new Vector3(39.470f, 38.890f, 21.120f);
            edgeRight = new Vector3(39.470f, 39.890f, 21.120f);
            useExclusionZone = true;
            useHeadLook = true;
            callHighFall = true;
            leanAway = true;
            preTeeterTime = 2.00f;
            leanAwayTime = 1.00f;
            leanAwayScale = 0.50f;
            teeterTime = 1.00f;
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageUpperBodyFlinch : EuphoriaMessage
    {
        private float handDistanceLeftRight = 0.1f;
        /// <summary>
        /// Left-Right distance between the hands
        /// </summary>
        [EuphoriaDetail("Left-Right distance between the hands")]
        public float HandDistanceLeftRight
        {
            get { return handDistanceLeftRight; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("handDistanceLeftRight", value);
                handDistanceLeftRight = value;
            }
        }

        private float handDistanceFrontBack = 0.06f;
        /// <summary>
        /// Front-Back distance between the hands
        /// </summary>
        [EuphoriaDetail("Front-Back distance between the hands")]
        public float HandDistanceFrontBack
        {
            get { return handDistanceFrontBack; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("handDistanceFrontBack", value);
                handDistanceFrontBack = value;
            }
        }

        private float handDistanceVertical = 0.1f;
        /// <summary>
        /// Vertical distance between the hands
        /// </summary>
        [EuphoriaDetail("Vertical distance between the hands")]
        public float HandDistanceVertical
        {
            get { return handDistanceVertical; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("handDistanceVertical", value);
                handDistanceVertical = value;
            }
        }

        private float bodyStiffness = 11.0f;
        /// <summary>
        /// stiffness of body. Value carries over to head look, spine twist
        /// </summary>
        [EuphoriaDetail("stiffness of body. Value carries over to head look, spine twist")]
        public float BodyStiffness
        {
            get { return bodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("bodyStiffness", value);
                bodyStiffness = value;
            }
        }

        private float bodyDamping = 1.0f;
        /// <summary>
        /// damping value used for upper body
        /// </summary>
        [EuphoriaDetail("damping value used for upper body")]
        public float BodyDamping
        {
            get { return bodyDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("bodyDamping", value);
                bodyDamping = value;
            }
        }

        private float backBendAmount = -0.55f;
        /// <summary>
        /// Amount to bend the back during the flinch
        /// </summary>
        [EuphoriaDetail("Amount to bend the back during the flinch")]
        public float BackBendAmount
        {
            get { return backBendAmount; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("backBendAmount", value);
                backBendAmount = value;
            }
        }

        private bool useRightArm = true;
        /// <summary>
        /// Toggle to use the right arm.
        /// </summary>
        [EuphoriaDetail("Toggle to use the right arm.")]
        public bool UseRightArm
        {
            get { return useRightArm; }
            set
            {

                SetArgument("useRightArm", value);
                useRightArm = value;
            }
        }

        private bool useLeftArm = true;
        /// <summary>
        /// Toggle to Use the Left arm
        /// </summary>
        [EuphoriaDetail("Toggle to Use the Left arm")]
        public bool UseLeftArm
        {
            get { return useLeftArm; }
            set
            {

                SetArgument("useLeftArm", value);
                useLeftArm = value;
            }
        }

        private float noiseScale = 0.1f;
        /// <summary>
        /// Amplitude of the perlin noise applied to the arms positions in the flicnh to the front part of the behaviour.
        /// </summary>
        [EuphoriaDetail("Amplitude of the perlin noise applied to the arms positions in the flicnh to the front part of the behaviour.")]
        public float NoiseScale
        {
            get { return noiseScale; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("noiseScale", value);
                noiseScale = value;
            }
        }

        private bool newHit = true;
        /// <summary>
        /// Relaxes the character for 1 frame if set.
        /// </summary>
        [EuphoriaDetail("Relaxes the character for 1 frame if set.")]
        public bool NewHit
        {
            get { return newHit; }
            set
            {

                SetArgument("newHit", value);
                newHit = value;
            }
        }

        private bool protectHeadToggle = false;
        /// <summary>
        /// Always protect head. Note if false then character flinches if target is in front, protects head if target is behind
        /// </summary>
        [EuphoriaDetail("Always protect head. Note if false then character flinches if target is in front, protects head if target is behind")]
        public bool ProtectHeadToggle
        {
            get { return protectHeadToggle; }
            set
            {

                SetArgument("protectHeadToggle", value);
                protectHeadToggle = value;
            }
        }

        private bool dontBraceHead = false;
        /// <summary>
        /// don't protect head only brace from front. Turned on by bcr
        /// </summary>
        [EuphoriaDetail("don't protect head only brace from front. Turned on by bcr")]
        public bool DontBraceHead
        {
            get { return dontBraceHead; }
            set
            {

                SetArgument("dontBraceHead", value);
                dontBraceHead = value;
            }
        }

        private bool applyStiffness = true;
        /// <summary>
        /// Turned of by bcr
        /// </summary>
        [EuphoriaDetail("Turned of by bcr")]
        public bool ApplyStiffness
        {
            get { return applyStiffness; }
            set
            {

                SetArgument("applyStiffness", value);
                applyStiffness = value;
            }
        }

        private bool headLookAwayFromTarget = false;
        /// <summary>
        /// Look away from target (unless protecting head then look between feet)
        /// </summary>
        [EuphoriaDetail("Look away from target (unless protecting head then look between feet)")]
        public bool HeadLookAwayFromTarget
        {
            get { return headLookAwayFromTarget; }
            set
            {

                SetArgument("headLookAwayFromTarget", value);
                headLookAwayFromTarget = value;
            }
        }

        private bool useHeadLook = true;
        /// <summary>
        /// Use headlook
        /// </summary>
        [EuphoriaDetail("Use headlook")]
        public bool UseHeadLook
        {
            get { return useHeadLook; }
            set
            {

                SetArgument("useHeadLook", value);
                useHeadLook = value;
            }
        }

        private int turnTowards = 1;
        /// <summary>
        /// ve balancer turn Towards, negative balancer turn Away, 0 balancer won't turn. NB.There is a 50% chance that the character will not turn even if this parameter is set to turn
        /// </summary>
        [EuphoriaDetail("ve balancer turn Towards, negative balancer turn Away, 0 balancer won't turn. NB.There is a 50% chance that the character will not turn even if this parameter is set to turn")]
        public int TurnTowards
        {
            get { return turnTowards; }
            set
            {
                value = MathHelper.Clamp(value, -2, 2);
                SetArgument("turnTowards", value);
                turnTowards = value;
            }
        }

        private Vector3 pos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position in world-space of object to flinch from
        /// </summary>
        [EuphoriaDetail("position in world-space of object to flinch from")]
        public Vector3 Pos
        {
            get { return pos; }
            set
            {

                SetArgument("pos", value);
                pos = value;
            }
        }


        public EuphoriaMessageUpperBodyFlinch(bool startNow) : base("upperBodyFlinch", startNow)
        { }

        public new void Reset()
        {
            handDistanceLeftRight = 0.1f;
            handDistanceFrontBack = 0.06f;
            handDistanceVertical = 0.1f;
            bodyStiffness = 11.0f;
            bodyDamping = 1.0f;
            backBendAmount = -0.55f;
            useRightArm = true;
            useLeftArm = true;
            noiseScale = 0.1f;
            newHit = true;
            protectHeadToggle = false;
            dontBraceHead = false;
            applyStiffness = true;
            headLookAwayFromTarget = false;
            useHeadLook = true;
            turnTowards = 1;
            pos = new Vector3(0f, 0f, 0f);
            base.Reset();
        }
    }


    /// <summary>
    /// 
    /// </summary>
    internal class EuphoriaMessageYanked : EuphoriaMessage
    {
        private float armStiffness = 11.0f;
        /// <summary>
        /// stiffness of arms when upright.
        /// </summary>
        [EuphoriaDetail("stiffness of arms when upright.")]
        public float ArmStiffness
        {
            get { return armStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("armStiffness", value);
                armStiffness = value;
            }
        }

        private float armDamping = 1.0f;
        /// <summary>
        /// Sets damping value for the arms when upright.
        /// </summary>
        [EuphoriaDetail("Sets damping value for the arms when upright.")]
        public float ArmDamping
        {
            get { return armDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armDamping", value);
                armDamping = value;
            }
        }

        private float spineDamping = 1.0f;
        /// <summary>
        /// Spine Damping when upright.
        /// </summary>
        [EuphoriaDetail("Spine Damping when upright.")]
        public float SpineDamping
        {
            get { return spineDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("spineDamping", value);
                spineDamping = value;
            }
        }

        private float spineStiffness = 10.0f;
        /// <summary>
        /// Spine Stiffness  when upright..
        /// </summary>
        [EuphoriaDetail("Spine Stiffness  when upright..")]
        public float SpineStiffness
        {
            get { return spineStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 6.0f, 16.0f);
                SetArgument("spineStiffness", value);
                spineStiffness = value;
            }
        }

        private float armStiffnessStart = 3.0f;
        /// <summary>
        /// armStiffness during the yanked timescale ie timeAtStartValues
        /// </summary>
        [EuphoriaDetail("armStiffness during the yanked timescale ie timeAtStartValues")]
        public float ArmStiffnessStart
        {
            get { return armStiffnessStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("armStiffnessStart", value);
                armStiffnessStart = value;
            }
        }

        private float armDampingStart = 0.1f;
        /// <summary>
        /// armDamping during the yanked timescale ie timeAtStartValues
        /// </summary>
        [EuphoriaDetail("armDamping during the yanked timescale ie timeAtStartValues")]
        public float ArmDampingStart
        {
            get { return armDampingStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("armDampingStart", value);
                armDampingStart = value;
            }
        }

        private float spineDampingStart = 0.1f;
        /// <summary>
        /// spineDamping during the yanked timescale ie timeAtStartValues
        /// </summary>
        [EuphoriaDetail("spineDamping during the yanked timescale ie timeAtStartValues")]
        public float SpineDampingStart
        {
            get { return spineDampingStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("spineDampingStart", value);
                spineDampingStart = value;
            }
        }

        private float spineStiffnessStart = 3.0f;
        /// <summary>
        /// spineStiffness during the yanked timescale ie timeAtStartValues
        /// </summary>
        [EuphoriaDetail("spineStiffness during the yanked timescale ie timeAtStartValues")]
        public float SpineStiffnessStart
        {
            get { return spineStiffnessStart; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("spineStiffnessStart", value);
                spineStiffnessStart = value;
            }
        }

        private float timeAtStartValues = 0.4f;
        /// <summary>
        /// time spent with Start values for arms and spine stiffness and damping ie for whiplash efffect
        /// </summary>
        [EuphoriaDetail("time spent with Start values for arms and spine stiffness and damping ie for whiplash efffect")]
        public float TimeAtStartValues
        {
            get { return timeAtStartValues; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("timeAtStartValues", value);
                timeAtStartValues = value;
            }
        }

        private float rampTimeFromStartValues = 0.1f;
        /// <summary>
        /// time spent ramping from Start to end values for arms and spine stiffness and damping ie for whiplash efffect (occurs after timeAtStartValues)
        /// </summary>
        [EuphoriaDetail("time spent ramping from Start to end values for arms and spine stiffness and damping ie for whiplash efffect (occurs after timeAtStartValues)")]
        public float RampTimeFromStartValues
        {
            get { return rampTimeFromStartValues; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rampTimeFromStartValues", value);
                rampTimeFromStartValues = value;
            }
        }

        private int stepsTillStartEnd = 2;
        /// <summary>
        /// steps taken before lowerBodyStiffness starts ramping down
        /// </summary>
        [EuphoriaDetail("steps taken before lowerBodyStiffness starts ramping down")]
        public int StepsTillStartEnd
        {
            get { return stepsTillStartEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0, 100);
                SetArgument("stepsTillStartEnd", value);
                stepsTillStartEnd = value;
            }
        }

        private float timeStartEnd = 100.0f;
        /// <summary>
        /// time from start of behaviour before lowerBodyStiffness starts ramping down by perStepReduction1
        /// </summary>
        [EuphoriaDetail("time from start of behaviour before lowerBodyStiffness starts ramping down by perStepReduction1")]
        public float TimeStartEnd
        {
            get { return timeStartEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 100.0f);
                SetArgument("timeStartEnd", value);
                timeStartEnd = value;
            }
        }

        private float rampTimeToEndValues = 0.0f;
        /// <summary>
        /// time spent ramping from lowerBodyStiffness to lowerBodyStiffnessEnd
        /// </summary>
        [EuphoriaDetail("time spent ramping from lowerBodyStiffness to lowerBodyStiffnessEnd")]
        public float RampTimeToEndValues
        {
            get { return rampTimeToEndValues; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("rampTimeToEndValues", value);
                rampTimeToEndValues = value;
            }
        }

        private float lowerBodyStiffness = 12.0f;
        /// <summary>
        /// lowerBodyStiffness should be 12
        /// </summary>
        [EuphoriaDetail("lowerBodyStiffness should be 12")]
        public float LowerBodyStiffness
        {
            get { return lowerBodyStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("lowerBodyStiffness", value);
                lowerBodyStiffness = value;
            }
        }

        private float lowerBodyStiffnessEnd = 8.0f;
        /// <summary>
        /// lowerBodyStiffness at end
        /// </summary>
        [EuphoriaDetail("lowerBodyStiffness at end")]
        public float LowerBodyStiffnessEnd
        {
            get { return lowerBodyStiffnessEnd; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("lowerBodyStiffnessEnd", value);
                lowerBodyStiffnessEnd = value;
            }
        }

        private float perStepReduction = 1.50f;
        /// <summary>
        /// LowerBody stiffness will be reduced every step to make the character fallover
        /// </summary>
        [EuphoriaDetail("LowerBody stiffness will be reduced every step to make the character fallover")]
        public float PerStepReduction
        {
            get { return perStepReduction; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("perStepReduction", value);
                perStepReduction = value;
            }
        }

        private float hipPitchForward = 0.60f;
        /// <summary>
        /// Amount to bend forward at the hips (+ve forward, -ve backwards).  Behaviour switches between hipPitchForward and hipPitchBack
        /// </summary>
        [EuphoriaDetail("Amount to bend forward at the hips (+ve forward, -ve backwards).  Behaviour switches between hipPitchForward and hipPitchBack")]
        public float HipPitchForward
        {
            get { return hipPitchForward; }
            set
            {
                value = MathHelper.Clamp(value, -1.30f, 1.30f);
                SetArgument("hipPitchForward", value);
                hipPitchForward = value;
            }
        }

        private float hipPitchBack = 1.0f;
        /// <summary>
        /// Amount to bend backwards at the hips (+ve backwards, -ve forwards).  Behaviour switches between hipPitchForward and hipPitchBack
        /// </summary>
        [EuphoriaDetail("Amount to bend backwards at the hips (+ve backwards, -ve forwards).  Behaviour switches between hipPitchForward and hipPitchBack")]
        public float HipPitchBack
        {
            get { return hipPitchBack; }
            set
            {
                value = MathHelper.Clamp(value, -1.30f, 1.30f);
                SetArgument("hipPitchBack", value);
                hipPitchBack = value;
            }
        }

        private float spineBend = 0.70f;
        /// <summary>
        /// Bend/Twist the spine amount
        /// </summary>
        [EuphoriaDetail("Bend/Twist the spine amount")]
        public float SpineBend
        {
            get { return spineBend; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 1.0f);
                SetArgument("spineBend", value);
                spineBend = value;
            }
        }

        private float footFriction = 1.0f;
        /// <summary>
        /// Foot friction when standing/stepping.  0.5 gives a good slide sometimes
        /// </summary>
        [EuphoriaDetail("Foot friction when standing/stepping.  0.5 gives a good slide sometimes")]
        public float FootFriction
        {
            get { return footFriction; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("footFriction", value);
                footFriction = value;
            }
        }

        private float turnThresholdMin = 0.60f;
        /// <summary>
        /// min angle at which the turn with toggle to the other direction (actual toggle angle is chosen randomly in range min to max). If it is 1 then it will never toggle. If negative then no turn is applied.
        /// </summary>
        [EuphoriaDetail("min angle at which the turn with toggle to the other direction (actual toggle angle is chosen randomly in range min to max). If it is 1 then it will never toggle. If negative then no turn is applied.")]
        public float TurnThresholdMin
        {
            get { return turnThresholdMin; }
            set
            {
                value = MathHelper.Clamp(value, -0.10f, 1.00f);
                SetArgument("turnThresholdMin", value);
                turnThresholdMin = value;
            }
        }

        private float turnThresholdMax = 0.60f;
        /// <summary>
        /// max angle at which the turn with toggle to the other direction (actual toggle angle is chosen randomly in range min to max). If it is 1 then it will never toggle. If negative then no turn is applied.
        /// </summary>
        [EuphoriaDetail("max angle at which the turn with toggle to the other direction (actual toggle angle is chosen randomly in range min to max). If it is 1 then it will never toggle. If negative then no turn is applied.")]
        public float TurnThresholdMax
        {
            get { return turnThresholdMax; }
            set
            {
                value = MathHelper.Clamp(value, -0.10f, 1.00f);
                SetArgument("turnThresholdMax", value);
                turnThresholdMax = value;
            }
        }

        private bool useHeadLook = false;
        /// <summary>
        /// enable and provide a look-at target to make the character's head turn to face it while balancing
        /// </summary>
        [EuphoriaDetail("enable and provide a look-at target to make the character's head turn to face it while balancing")]
        public bool UseHeadLook
        {
            get { return useHeadLook; }
            set
            {

                SetArgument("useHeadLook", value);
                useHeadLook = value;
            }
        }

        private Vector3 headLookPos = new Vector3(0f, 0f, 0f);
        /// <summary>
        /// position of thing to look at
        /// </summary>
        [EuphoriaDetail("position of thing to look at")]
        public Vector3 HeadLookPos
        {
            get { return headLookPos; }
            set
            {

                SetArgument("headLookPos", value);
                headLookPos = value;
            }
        }

        private int headLookInstanceIndex = -1;
        /// <summary>
        /// level index of thing to look at
        /// </summary>
        [EuphoriaDetail("level index of thing to look at")]
        public int HeadLookInstanceIndex
        {
            get { return headLookInstanceIndex; }
            set
            {

                SetArgument("headLookInstanceIndex", value);
                headLookInstanceIndex = value;
            }
        }

        private float headLookAtVelProb = -1.0f;
        /// <summary>
        /// Probability [0-1] that headLook will be looking in the direction of velocity when stepping
        /// </summary>
        [EuphoriaDetail("Probability [0-1] that headLook will be looking in the direction of velocity when stepping")]
        public float HeadLookAtVelProb
        {
            get { return headLookAtVelProb; }
            set
            {
                value = MathHelper.Clamp(value, -1.0f, 1.0f);
                SetArgument("headLookAtVelProb", value);
                headLookAtVelProb = value;
            }
        }

        private float comVelRDSThresh = 2.0f;
        /// <summary>
        /// for handsAndKnees catchfall ONLY: comVel above which rollDownstairs will start
        /// </summary>
        [EuphoriaDetail("for handsAndKnees catchfall ONLY: comVel above which rollDownstairs will start")]
        public float ComVelRDSThresh
        {
            get { return comVelRDSThresh; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 20.0f);
                SetArgument("comVelRDSThresh", value);
                comVelRDSThresh = value;
            }
        }

        private float hulaPeriod = 0.25f;
        /// <summary>
        /// 0.25 A complete wiggle will take 4*hulaPeriod
        /// </summary>
        [EuphoriaDetail("0.25 A complete wiggle will take 4*hulaPeriod")]
        public float HulaPeriod
        {
            get { return hulaPeriod; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("hulaPeriod", value);
                hulaPeriod = value;
            }
        }

        private float hipAmplitude = 1.0f;
        /// <summary>
        /// Amount of hip movement
        /// </summary>
        [EuphoriaDetail("Amount of hip movement")]
        public float HipAmplitude
        {
            get { return hipAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("hipAmplitude", value);
                hipAmplitude = value;
            }
        }

        private float spineAmplitude = 1.0f;
        /// <summary>
        /// Amount of spine movement
        /// </summary>
        [EuphoriaDetail("Amount of spine movement")]
        public float SpineAmplitude
        {
            get { return spineAmplitude; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 4.0f);
                SetArgument("spineAmplitude", value);
                spineAmplitude = value;
            }
        }

        private float minRelaxPeriod = 0.3f;
        /// <summary>
        /// wriggle relaxes for a minimum of minRelaxPeriod (if it is negative it is a multiplier on the time previously spent wriggling)
        /// </summary>
        [EuphoriaDetail("wriggle relaxes for a minimum of minRelaxPeriod (if it is negative it is a multiplier on the time previously spent wriggling)")]
        public float MinRelaxPeriod
        {
            get { return minRelaxPeriod; }
            set
            {
                value = MathHelper.Clamp(value, -5.0f, 5.0f);
                SetArgument("minRelaxPeriod", value);
                minRelaxPeriod = value;
            }
        }

        private float maxRelaxPeriod = 1.5f;
        /// <summary>
        /// wriggle relaxes for a maximum of maxRelaxPeriod (if it is negative it is a multiplier on the time previously spent wriggling)
        /// </summary>
        [EuphoriaDetail("wriggle relaxes for a maximum of maxRelaxPeriod (if it is negative it is a multiplier on the time previously spent wriggling)")]
        public float MaxRelaxPeriod
        {
            get { return maxRelaxPeriod; }
            set
            {
                value = MathHelper.Clamp(value, -5.0f, 5.0f);
                SetArgument("maxRelaxPeriod", value);
                maxRelaxPeriod = value;
            }
        }

        private float rollHelp = 0.5f;
        /// <summary>
        /// Amount of cheat torque applied to turn the character over
        /// </summary>
        [EuphoriaDetail("Amount of cheat torque applied to turn the character over")]
        public float RollHelp
        {
            get { return rollHelp; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("rollHelp", value);
                rollHelp = value;
            }
        }

        private float groundLegStiffness = 11f;
        /// <summary>
        /// Leg Stiffness when on the ground
        /// </summary>
        [EuphoriaDetail("Leg Stiffness when on the ground")]
        public float GroundLegStiffness
        {
            get { return groundLegStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("groundLegStiffness", value);
                groundLegStiffness = value;
            }
        }

        private float groundArmStiffness = 11f;
        /// <summary>
        /// Arm Stiffness when on the ground
        /// </summary>
        [EuphoriaDetail("Arm Stiffness when on the ground")]
        public float GroundArmStiffness
        {
            get { return groundArmStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("groundArmStiffness", value);
                groundArmStiffness = value;
            }
        }

        private float groundSpineStiffness = 14f;
        /// <summary>
        /// Spine Stiffness when on the ground
        /// </summary>
        [EuphoriaDetail("Spine Stiffness when on the ground")]
        public float GroundSpineStiffness
        {
            get { return groundSpineStiffness; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 16.0f);
                SetArgument("groundSpineStiffness", value);
                groundSpineStiffness = value;
            }
        }

        private float groundLegDamping = 0.5f;
        /// <summary>
        /// Leg Damping when on the ground
        /// </summary>
        [EuphoriaDetail("Leg Damping when on the ground")]
        public float GroundLegDamping
        {
            get { return groundLegDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("groundLegDamping", value);
                groundLegDamping = value;
            }
        }

        private float groundArmDamping = 0.5f;
        /// <summary>
        /// Arm Damping when on the ground
        /// </summary>
        [EuphoriaDetail("Arm Damping when on the ground")]
        public float GroundArmDamping
        {
            get { return groundArmDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("groundArmDamping", value);
                groundArmDamping = value;
            }
        }

        private float groundSpineDamping = 0.5f;
        /// <summary>
        /// Spine Damping when on the ground
        /// </summary>
        [EuphoriaDetail("Spine Damping when on the ground")]
        public float GroundSpineDamping
        {
            get { return groundSpineDamping; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 2.0f);
                SetArgument("groundSpineDamping", value);
                groundSpineDamping = value;
            }
        }

        private float groundFriction = 8.0f;
        /// <summary>
        /// Friction multiplier on bodyParts when on ground.  Character can look too slidy with groundFriction = 1.  Higher values give a more jerky reation but this seems timestep dependent especially for dragged by the feet.
        /// </summary>
        [EuphoriaDetail("Friction multiplier on bodyParts when on ground.  Character can look too slidy with groundFriction = 1.  Higher values give a more jerky reation but this seems timestep dependent especially for dragged by the feet.")]
        public float GroundFriction
        {
            get { return groundFriction; }
            set
            {
                value = MathHelper.Clamp(value, 0.0f, 10.0f);
                SetArgument("groundFriction", value);
                groundFriction = value;
            }
        }


        public EuphoriaMessageYanked(bool startNow) : base("yanked", startNow)
        { }

        public new void Reset()
        {
            armStiffness = 11.0f;
            armDamping = 1.0f;
            spineDamping = 1.0f;
            spineStiffness = 10.0f;
            armStiffnessStart = 3.0f;
            armDampingStart = 0.1f;
            spineDampingStart = 0.1f;
            spineStiffnessStart = 3.0f;
            timeAtStartValues = 0.4f;
            rampTimeFromStartValues = 0.1f;
            stepsTillStartEnd = 2;
            timeStartEnd = 100.0f;
            rampTimeToEndValues = 0.0f;
            lowerBodyStiffness = 12.0f;
            lowerBodyStiffnessEnd = 8.0f;
            perStepReduction = 1.50f;
            hipPitchForward = 0.60f;
            hipPitchBack = 1.0f;
            spineBend = 0.70f;
            footFriction = 1.0f;
            turnThresholdMin = 0.60f;
            turnThresholdMax = 0.60f;
            useHeadLook = false;
            headLookPos = new Vector3(0f, 0f, 0f);
            headLookInstanceIndex = -1;
            headLookAtVelProb = -1.0f;
            comVelRDSThresh = 2.0f;
            hulaPeriod = 0.25f;
            hipAmplitude = 1.0f;
            spineAmplitude = 1.0f;
            minRelaxPeriod = 0.3f;
            maxRelaxPeriod = 1.5f;
            rollHelp = 0.5f;
            groundLegStiffness = 11f;
            groundArmStiffness = 11f;
            groundSpineStiffness = 14f;
            groundLegDamping = 0.5f;
            groundArmDamping = 0.5f;
            groundSpineDamping = 0.5f;
            groundFriction = 8.0f;
            base.Reset();
        }
    }
}
